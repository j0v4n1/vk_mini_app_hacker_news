import {
  Icon12Circle,
  Icon12Dropdown,
  Icon12OnlineMobile,
  Icon16Cancel,
  Icon16Chevron,
  Icon16Clear,
  Icon16Done,
  Icon16Dropdown,
  Icon16SearchOutline,
  Icon16Spinner,
  Icon20CalendarOutline,
  Icon20Cancel,
  Icon20CheckBoxIndetermanate,
  Icon20CheckBoxOff,
  Icon20CheckBoxOn,
  Icon20CheckCircleOn,
  Icon20ChevronLeftOutline,
  Icon20ChevronRightOutline,
  Icon20ChevronUp,
  Icon20Dropdown,
  Icon24ArrowLeftOutline,
  Icon24Attach,
  Icon24Cancel,
  Icon24CancelOutline,
  Icon24CheckBoxOff,
  Icon24CheckBoxOn,
  Icon24CheckCircleOff,
  Icon24CheckCircleOn,
  Icon24CheckCircleOutline,
  Icon24Chevron,
  Icon24ChevronCompactLeft,
  Icon24ChevronCompactRight,
  Icon24ChevronDown,
  Icon24ChevronLeftOutline,
  Icon24ChevronUp,
  Icon24Dismiss,
  Icon24DismissDark,
  Icon24DoneOutline,
  Icon24PenOutline,
  Icon24Reorder,
  Icon24ReorderIos,
  Icon24Send,
  Icon24Spinner,
  Icon28AddCircleOutline,
  Icon28ArrowLeftOutline,
  Icon28AttachOutline,
  Icon28CancelOutline,
  Icon28CheckCircleOutline,
  Icon28ChevronBack,
  Icon28ChevronLeftOutline,
  Icon28ChevronRightCircle,
  Icon28DoneOutline,
  Icon28EditOutline,
  Icon28Send,
  Icon32Spinner,
  Icon44Spinner,
  Icon48WritebarDone,
  Icon48WritebarSend,
  _class_call_check,
  _create_class,
  _define_property,
  _object_spread,
  _object_spread_props,
  _object_without_properties
} from "./chunk-5DXCPHEU.js";
import {
  require_react_dom
} from "./chunk-QO4NA2F3.js";
import {
  require_react
} from "./chunk-GMHSYVPX.js";
import {
  __commonJS,
  __toESM
} from "./chunk-UV5CTPV7.js";

// node_modules/@vkontakte/vkui/dist/shared/breakpoints.js
var require_breakpoints = __commonJS({
  "node_modules/@vkontakte/vkui/dist/shared/breakpoints.js"(exports, module) {
    var BREAKPOINTS2 = {
      DESKTOP: 1280,
      TABLET: 1024,
      SMALL_TABLET: 768,
      MOBILE: 320,
      MOBILE_LANDSCAPE_HEIGHT: 415,
      MEDIUM_HEIGHT: 720
    };
    function widthPlus(a) {
      return `(min-width: ${a}px)`;
    }
    function widthMinus(b) {
      return `(max-width: ${b - 0.1}px)`;
    }
    function widthHalfInterval(a, b) {
      return `${widthPlus(a)} and ${widthMinus(b)}`;
    }
    function heightPlus(a) {
      return `(min-height: ${a}px)`;
    }
    function heightMinus(b) {
      return `(max-height: ${b - 0.1}px)`;
    }
    function heightHalfInterval(a, b) {
      return `${heightPlus(a)} and ${heightMinus(b)}`;
    }
    var MEDIA_QUERIES2 = {
      DESKTOP_PLUS: widthPlus(BREAKPOINTS2.DESKTOP),
      TABLET: widthHalfInterval(BREAKPOINTS2.TABLET, BREAKPOINTS2.DESKTOP),
      SMALL_TABLET_PLUS: widthPlus(BREAKPOINTS2.SMALL_TABLET),
      SMALL_TABLET: widthHalfInterval(BREAKPOINTS2.SMALL_TABLET, BREAKPOINTS2.TABLET),
      MOBILE: widthHalfInterval(BREAKPOINTS2.MOBILE, BREAKPOINTS2.SMALL_TABLET),
      MEDIUM_HEIGHT: heightPlus(BREAKPOINTS2.MEDIUM_HEIGHT),
      MOBILE_LANDSCAPE_HEIGHT: heightPlus(BREAKPOINTS2.MOBILE_LANDSCAPE_HEIGHT)
    };
    module.exports = {
      BREAKPOINTS: BREAKPOINTS2,
      MEDIA_QUERIES: MEDIA_QUERIES2,
      widthHalfInterval,
      widthPlus,
      widthMinus,
      heightHalfInterval,
      heightPlus,
      heightMinus
    };
  }
});

// node_modules/dayjs/dayjs.min.js
var require_dayjs_min = __commonJS({
  "node_modules/dayjs/dayjs.min.js"(exports, module) {
    !function(t, e) {
      "object" == typeof exports && "undefined" != typeof module ? module.exports = e() : "function" == typeof define && define.amd ? define(e) : (t = "undefined" != typeof globalThis ? globalThis : t || self).dayjs = e();
    }(exports, function() {
      "use strict";
      var t = 1e3, e = 6e4, n = 36e5, r = "millisecond", i = "second", s = "minute", u = "hour", a = "day", o = "week", c = "month", f = "quarter", h = "year", d = "date", l = "Invalid Date", $ = /^(\d{4})[-/]?(\d{1,2})?[-/]?(\d{0,2})[Tt\s]*(\d{1,2})?:?(\d{1,2})?:?(\d{1,2})?[.:]?(\d+)?$/, y = /\[([^\]]+)]|Y{1,4}|M{1,4}|D{1,2}|d{1,4}|H{1,2}|h{1,2}|a|A|m{1,2}|s{1,2}|Z{1,2}|SSS/g, M = { name: "en", weekdays: "Sunday_Monday_Tuesday_Wednesday_Thursday_Friday_Saturday".split("_"), months: "January_February_March_April_May_June_July_August_September_October_November_December".split("_"), ordinal: function(t2) {
        var e2 = ["th", "st", "nd", "rd"], n2 = t2 % 100;
        return "[" + t2 + (e2[(n2 - 20) % 10] || e2[n2] || e2[0]) + "]";
      } }, m = function(t2, e2, n2) {
        var r2 = String(t2);
        return !r2 || r2.length >= e2 ? t2 : "" + Array(e2 + 1 - r2.length).join(n2) + t2;
      }, v = { s: m, z: function(t2) {
        var e2 = -t2.utcOffset(), n2 = Math.abs(e2), r2 = Math.floor(n2 / 60), i2 = n2 % 60;
        return (e2 <= 0 ? "+" : "-") + m(r2, 2, "0") + ":" + m(i2, 2, "0");
      }, m: function t2(e2, n2) {
        if (e2.date() < n2.date())
          return -t2(n2, e2);
        var r2 = 12 * (n2.year() - e2.year()) + (n2.month() - e2.month()), i2 = e2.clone().add(r2, c), s2 = n2 - i2 < 0, u2 = e2.clone().add(r2 + (s2 ? -1 : 1), c);
        return +(-(r2 + (n2 - i2) / (s2 ? i2 - u2 : u2 - i2)) || 0);
      }, a: function(t2) {
        return t2 < 0 ? Math.ceil(t2) || 0 : Math.floor(t2);
      }, p: function(t2) {
        return { M: c, y: h, w: o, d: a, D: d, h: u, m: s, s: i, ms: r, Q: f }[t2] || String(t2 || "").toLowerCase().replace(/s$/, "");
      }, u: function(t2) {
        return void 0 === t2;
      } }, g = "en", D = {};
      D[g] = M;
      var p = "$isDayjsObject", S = function(t2) {
        return t2 instanceof _ || !(!t2 || !t2[p]);
      }, w = function t2(e2, n2, r2) {
        var i2;
        if (!e2)
          return g;
        if ("string" == typeof e2) {
          var s2 = e2.toLowerCase();
          D[s2] && (i2 = s2), n2 && (D[s2] = n2, i2 = s2);
          var u2 = e2.split("-");
          if (!i2 && u2.length > 1)
            return t2(u2[0]);
        } else {
          var a2 = e2.name;
          D[a2] = e2, i2 = a2;
        }
        return !r2 && i2 && (g = i2), i2 || !r2 && g;
      }, O = function(t2, e2) {
        if (S(t2))
          return t2.clone();
        var n2 = "object" == typeof e2 ? e2 : {};
        return n2.date = t2, n2.args = arguments, new _(n2);
      }, b = v;
      b.l = w, b.i = S, b.w = function(t2, e2) {
        return O(t2, { locale: e2.$L, utc: e2.$u, x: e2.$x, $offset: e2.$offset });
      };
      var _ = function() {
        function M2(t2) {
          this.$L = w(t2.locale, null, true), this.parse(t2), this.$x = this.$x || t2.x || {}, this[p] = true;
        }
        var m2 = M2.prototype;
        return m2.parse = function(t2) {
          this.$d = function(t3) {
            var e2 = t3.date, n2 = t3.utc;
            if (null === e2)
              return /* @__PURE__ */ new Date(NaN);
            if (b.u(e2))
              return /* @__PURE__ */ new Date();
            if (e2 instanceof Date)
              return new Date(e2);
            if ("string" == typeof e2 && !/Z$/i.test(e2)) {
              var r2 = e2.match($);
              if (r2) {
                var i2 = r2[2] - 1 || 0, s2 = (r2[7] || "0").substring(0, 3);
                return n2 ? new Date(Date.UTC(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2)) : new Date(r2[1], i2, r2[3] || 1, r2[4] || 0, r2[5] || 0, r2[6] || 0, s2);
              }
            }
            return new Date(e2);
          }(t2), this.init();
        }, m2.init = function() {
          var t2 = this.$d;
          this.$y = t2.getFullYear(), this.$M = t2.getMonth(), this.$D = t2.getDate(), this.$W = t2.getDay(), this.$H = t2.getHours(), this.$m = t2.getMinutes(), this.$s = t2.getSeconds(), this.$ms = t2.getMilliseconds();
        }, m2.$utils = function() {
          return b;
        }, m2.isValid = function() {
          return !(this.$d.toString() === l);
        }, m2.isSame = function(t2, e2) {
          var n2 = O(t2);
          return this.startOf(e2) <= n2 && n2 <= this.endOf(e2);
        }, m2.isAfter = function(t2, e2) {
          return O(t2) < this.startOf(e2);
        }, m2.isBefore = function(t2, e2) {
          return this.endOf(e2) < O(t2);
        }, m2.$g = function(t2, e2, n2) {
          return b.u(t2) ? this[e2] : this.set(n2, t2);
        }, m2.unix = function() {
          return Math.floor(this.valueOf() / 1e3);
        }, m2.valueOf = function() {
          return this.$d.getTime();
        }, m2.startOf = function(t2, e2) {
          var n2 = this, r2 = !!b.u(e2) || e2, f2 = b.p(t2), l2 = function(t3, e3) {
            var i2 = b.w(n2.$u ? Date.UTC(n2.$y, e3, t3) : new Date(n2.$y, e3, t3), n2);
            return r2 ? i2 : i2.endOf(a);
          }, $2 = function(t3, e3) {
            return b.w(n2.toDate()[t3].apply(n2.toDate("s"), (r2 ? [0, 0, 0, 0] : [23, 59, 59, 999]).slice(e3)), n2);
          }, y2 = this.$W, M3 = this.$M, m3 = this.$D, v2 = "set" + (this.$u ? "UTC" : "");
          switch (f2) {
            case h:
              return r2 ? l2(1, 0) : l2(31, 11);
            case c:
              return r2 ? l2(1, M3) : l2(0, M3 + 1);
            case o:
              var g2 = this.$locale().weekStart || 0, D2 = (y2 < g2 ? y2 + 7 : y2) - g2;
              return l2(r2 ? m3 - D2 : m3 + (6 - D2), M3);
            case a:
            case d:
              return $2(v2 + "Hours", 0);
            case u:
              return $2(v2 + "Minutes", 1);
            case s:
              return $2(v2 + "Seconds", 2);
            case i:
              return $2(v2 + "Milliseconds", 3);
            default:
              return this.clone();
          }
        }, m2.endOf = function(t2) {
          return this.startOf(t2, false);
        }, m2.$set = function(t2, e2) {
          var n2, o2 = b.p(t2), f2 = "set" + (this.$u ? "UTC" : ""), l2 = (n2 = {}, n2[a] = f2 + "Date", n2[d] = f2 + "Date", n2[c] = f2 + "Month", n2[h] = f2 + "FullYear", n2[u] = f2 + "Hours", n2[s] = f2 + "Minutes", n2[i] = f2 + "Seconds", n2[r] = f2 + "Milliseconds", n2)[o2], $2 = o2 === a ? this.$D + (e2 - this.$W) : e2;
          if (o2 === c || o2 === h) {
            var y2 = this.clone().set(d, 1);
            y2.$d[l2]($2), y2.init(), this.$d = y2.set(d, Math.min(this.$D, y2.daysInMonth())).$d;
          } else
            l2 && this.$d[l2]($2);
          return this.init(), this;
        }, m2.set = function(t2, e2) {
          return this.clone().$set(t2, e2);
        }, m2.get = function(t2) {
          return this[b.p(t2)]();
        }, m2.add = function(r2, f2) {
          var d2, l2 = this;
          r2 = Number(r2);
          var $2 = b.p(f2), y2 = function(t2) {
            var e2 = O(l2);
            return b.w(e2.date(e2.date() + Math.round(t2 * r2)), l2);
          };
          if ($2 === c)
            return this.set(c, this.$M + r2);
          if ($2 === h)
            return this.set(h, this.$y + r2);
          if ($2 === a)
            return y2(1);
          if ($2 === o)
            return y2(7);
          var M3 = (d2 = {}, d2[s] = e, d2[u] = n, d2[i] = t, d2)[$2] || 1, m3 = this.$d.getTime() + r2 * M3;
          return b.w(m3, this);
        }, m2.subtract = function(t2, e2) {
          return this.add(-1 * t2, e2);
        }, m2.format = function(t2) {
          var e2 = this, n2 = this.$locale();
          if (!this.isValid())
            return n2.invalidDate || l;
          var r2 = t2 || "YYYY-MM-DDTHH:mm:ssZ", i2 = b.z(this), s2 = this.$H, u2 = this.$m, a2 = this.$M, o2 = n2.weekdays, c2 = n2.months, f2 = n2.meridiem, h2 = function(t3, n3, i3, s3) {
            return t3 && (t3[n3] || t3(e2, r2)) || i3[n3].slice(0, s3);
          }, d2 = function(t3) {
            return b.s(s2 % 12 || 12, t3, "0");
          }, $2 = f2 || function(t3, e3, n3) {
            var r3 = t3 < 12 ? "AM" : "PM";
            return n3 ? r3.toLowerCase() : r3;
          };
          return r2.replace(y, function(t3, r3) {
            return r3 || function(t4) {
              switch (t4) {
                case "YY":
                  return String(e2.$y).slice(-2);
                case "YYYY":
                  return b.s(e2.$y, 4, "0");
                case "M":
                  return a2 + 1;
                case "MM":
                  return b.s(a2 + 1, 2, "0");
                case "MMM":
                  return h2(n2.monthsShort, a2, c2, 3);
                case "MMMM":
                  return h2(c2, a2);
                case "D":
                  return e2.$D;
                case "DD":
                  return b.s(e2.$D, 2, "0");
                case "d":
                  return String(e2.$W);
                case "dd":
                  return h2(n2.weekdaysMin, e2.$W, o2, 2);
                case "ddd":
                  return h2(n2.weekdaysShort, e2.$W, o2, 3);
                case "dddd":
                  return o2[e2.$W];
                case "H":
                  return String(s2);
                case "HH":
                  return b.s(s2, 2, "0");
                case "h":
                  return d2(1);
                case "hh":
                  return d2(2);
                case "a":
                  return $2(s2, u2, true);
                case "A":
                  return $2(s2, u2, false);
                case "m":
                  return String(u2);
                case "mm":
                  return b.s(u2, 2, "0");
                case "s":
                  return String(e2.$s);
                case "ss":
                  return b.s(e2.$s, 2, "0");
                case "SSS":
                  return b.s(e2.$ms, 3, "0");
                case "Z":
                  return i2;
              }
              return null;
            }(t3) || i2.replace(":", "");
          });
        }, m2.utcOffset = function() {
          return 15 * -Math.round(this.$d.getTimezoneOffset() / 15);
        }, m2.diff = function(r2, d2, l2) {
          var $2, y2 = this, M3 = b.p(d2), m3 = O(r2), v2 = (m3.utcOffset() - this.utcOffset()) * e, g2 = this - m3, D2 = function() {
            return b.m(y2, m3);
          };
          switch (M3) {
            case h:
              $2 = D2() / 12;
              break;
            case c:
              $2 = D2();
              break;
            case f:
              $2 = D2() / 3;
              break;
            case o:
              $2 = (g2 - v2) / 6048e5;
              break;
            case a:
              $2 = (g2 - v2) / 864e5;
              break;
            case u:
              $2 = g2 / n;
              break;
            case s:
              $2 = g2 / e;
              break;
            case i:
              $2 = g2 / t;
              break;
            default:
              $2 = g2;
          }
          return l2 ? $2 : b.a($2);
        }, m2.daysInMonth = function() {
          return this.endOf(c).$D;
        }, m2.$locale = function() {
          return D[this.$L];
        }, m2.locale = function(t2, e2) {
          if (!t2)
            return this.$L;
          var n2 = this.clone(), r2 = w(t2, e2, true);
          return r2 && (n2.$L = r2), n2;
        }, m2.clone = function() {
          return b.w(this.$d, this);
        }, m2.toDate = function() {
          return new Date(this.valueOf());
        }, m2.toJSON = function() {
          return this.isValid() ? this.toISOString() : null;
        }, m2.toISOString = function() {
          return this.$d.toISOString();
        }, m2.toString = function() {
          return this.$d.toUTCString();
        }, M2;
      }(), k = _.prototype;
      return O.prototype = k, [["$ms", r], ["$s", i], ["$m", s], ["$H", u], ["$W", a], ["$M", c], ["$y", h], ["$D", d]].forEach(function(t2) {
        k[t2[1]] = function(e2) {
          return this.$g(e2, t2[0], t2[1]);
        };
      }), O.extend = function(t2, e2) {
        return t2.$i || (t2(e2, _, O), t2.$i = true), O;
      }, O.locale = w, O.isDayjs = S, O.unix = function(t2) {
        return O(1e3 * t2);
      }, O.en = D[g], O.Ls = D, O.p = {}, O;
    });
  }
});

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRoot.js
var React15 = __toESM(require_react());

// node_modules/@vkontakte/vkjs/lib/es6/dom.js
var canUseDOM = function() {
  return !!(typeof window !== "undefined" && window.document && window.document.createElement);
}();
var canUseEventListeners = function() {
  return canUseDOM && !!window.addEventListener;
}();

// node_modules/@vkontakte/vkjs/lib/es6/animate.js
var animationEvent = function() {
  var obj = {
    supported: false,
    name: "animationend"
  };
  if (canUseDOM) {
    if (typeof AnimationEvent !== "undefined") {
      obj.supported = true;
    } else if (typeof WebKitAnimationEvent !== "undefined") {
      obj.supported = true;
      obj.name = "webkitAnimationEnd";
    }
  }
  return obj;
}();
var transitionEvent = function() {
  var obj = {
    supported: false,
    name: "transitionend"
  };
  if (canUseDOM) {
    if (typeof TransitionEvent !== "undefined") {
      obj.supported = true;
    } else if (typeof WebKitTransitionEvent !== "undefined") {
      obj.supported = true;
      obj.name = "webkitTransitionEnd";
    }
  }
  return obj;
}();

// node_modules/@swc/helpers/esm/_array_like_to_array.js
function _array_like_to_array(arr, len) {
  if (len == null || len > arr.length)
    len = arr.length;
  for (var i = 0, arr2 = new Array(len); i < len; i++)
    arr2[i] = arr[i];
  return arr2;
}

// node_modules/@swc/helpers/esm/_array_without_holes.js
function _array_without_holes(arr) {
  if (Array.isArray(arr))
    return _array_like_to_array(arr);
}

// node_modules/@swc/helpers/esm/_iterable_to_array.js
function _iterable_to_array(iter) {
  if (typeof Symbol !== "undefined" && iter[Symbol.iterator] != null || iter["@@iterator"] != null) {
    return Array.from(iter);
  }
}

// node_modules/@swc/helpers/esm/_non_iterable_spread.js
function _non_iterable_spread() {
  throw new TypeError("Invalid attempt to spread non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@swc/helpers/esm/_unsupported_iterable_to_array.js
function _unsupported_iterable_to_array(o, minLen) {
  if (!o)
    return;
  if (typeof o === "string")
    return _array_like_to_array(o, minLen);
  var n = Object.prototype.toString.call(o).slice(8, -1);
  if (n === "Object" && o.constructor)
    n = o.constructor.name;
  if (n === "Map" || n === "Set")
    return Array.from(n);
  if (n === "Arguments" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n))
    return _array_like_to_array(o, minLen);
}

// node_modules/@swc/helpers/esm/_to_consumable_array.js
function _to_consumable_array(arr) {
  return _array_without_holes(arr) || _iterable_to_array(arr) || _unsupported_iterable_to_array(arr) || _non_iterable_spread();
}

// node_modules/@swc/helpers/esm/_type_of.js
function _type_of(obj) {
  "@swc/helpers - typeof";
  return obj && typeof Symbol !== "undefined" && obj.constructor === Symbol ? "symbol" : typeof obj;
}

// node_modules/@vkontakte/vkjs/lib/es6/classNames.js
function classNames() {
  for (var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++) {
    args[_key] = arguments[_key];
  }
  var result = [];
  args.forEach(function(item) {
    if (!item) {
      return;
    }
    switch (typeof item === "undefined" ? "undefined" : _type_of(item)) {
      case "string":
        result.push(item);
        break;
      case "object":
        Object.keys(item).forEach(function(key) {
          if (item[key]) {
            result.push(key);
          }
        });
        break;
      default:
        result.push("".concat(item));
    }
  });
  return result.join(" ");
}

// node_modules/@vkontakte/vkjs/lib/es6/functions.js
var noop = function() {
};
function debounce(fn, delay) {
  var context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : typeof window !== "undefined" ? window : void 0;
  var timeoutId;
  var args;
  var later = function() {
    return fn.apply(context, args);
  };
  var debouncedFn = function() {
    for (var _len = arguments.length, a = new Array(_len), _key = 0; _key < _len; _key++) {
      a[_key] = arguments[_key];
    }
    args = a;
    clearTimeout(timeoutId);
    timeoutId = setTimeout(later, delay);
  };
  debouncedFn.cancel = function() {
    clearTimeout(timeoutId);
  };
  return debouncedFn;
}

// node_modules/@vkontakte/vkjs/lib/es6/detections.js
var isPassiveEventsSupported = function() {
  var isSupported = false;
  if (canUseEventListeners) {
    try {
      var options = Object.defineProperty({}, "passive", {
        get: function get() {
          isSupported = true;
        }
      });
      window.addEventListener("test", noop, options);
      window.removeEventListener("test", noop, options);
    } catch (e) {
    }
  }
  return isSupported;
}();
function detectSmoothScrollSupport() {
  if (!canUseDOM) {
    return false;
  }
  var isSupported = false;
  try {
    var div = document.createElement("div");
    div.scrollTo({
      top: 0,
      get behavior() {
        isSupported = true;
        return "smooth";
      }
    });
  } catch (e) {
  }
  return isSupported;
}
var isSmoothScrollSupported = detectSmoothScrollSupport();

// node_modules/@vkontakte/vkjs/lib/es6/type_checkers.js
function isObjectLike(object) {
  return typeof object === "object" && object !== null;
}
function isFunction(object) {
  return typeof object === "function";
}

// node_modules/@vkontakte/vkjs/lib/es6/equal.js
function isEqual(value, other) {
  if (value === other) {
    return true;
  }
  if (value == null || other == null || !isObjectLike(value) && !isObjectLike(other)) {
    return value !== value && other !== other;
  }
  if (isObjectLike(value) && isObjectLike(other)) {
    if (Object.keys(value).length !== Object.keys(other).length) {
      return false;
    }
    for (var prop in value) {
      if (value.hasOwnProperty(prop) && other.hasOwnProperty(prop)) {
        if (!isEqual(value[prop], other[prop])) {
          return false;
        }
      } else {
        return false;
      }
    }
    return true;
  }
  return false;
}

// node_modules/@vkontakte/vkjs/lib/es6/numbers.js
function leadingZero(number) {
  if (number >= 10) {
    return String(number);
  } else {
    return "0" + String(number);
  }
}

// node_modules/@vkontakte/vkjs/lib/es6/date.js
var SECONDS_IN_THE_DAY = 86400;
var MILLISECONDS_IN_THE_DAY = SECONDS_IN_THE_DAY * 1e3;

// node_modules/@swc/helpers/esm/_instanceof.js
function _instanceof(left, right) {
  if (right != null && typeof Symbol !== "undefined" && right[Symbol.hasInstance]) {
    return !!right[Symbol.hasInstance](left);
  } else
    return left instanceof right;
}

// node_modules/@vkontakte/vkjs/lib/es6/regexp.js
function escapeRegExp(string) {
  if (string) {
    return string.replace(/([.*+?^${}()|[\]\/\\])/g, "\\$1");
  }
  return "";
}

// node_modules/@vkontakte/vkjs/lib/es6/lib/replacer.js
var Replacer = function() {
  "use strict";
  function Replacer2(map) {
    _class_call_check(this, Replacer2);
    _define_property(this, "regexp", void 0);
    _define_property(this, "map", void 0);
    this.map = map;
  }
  _create_class(Replacer2, [
    {
      key: "build",
      value: function build() {
        if (this.regexp) {
          return;
        }
        var groups = Object.keys(this.map).map(escapeRegExp).sort(function(a, b) {
          return b.length - a.length;
        });
        var pattern = "(?:".concat(groups.join("|"), ")");
        this.regexp = new RegExp(pattern, "g");
      }
    },
    {
      key: "replace",
      value: function replace(string) {
        var _this = this;
        if (!string) {
          return "";
        }
        this.build();
        return string.replace(this.regexp, function(substring) {
          return _this.map[substring];
        });
      }
    }
  ]);
  return Replacer2;
}();

// node_modules/@vkontakte/vkjs/lib/es6/lib/codepoints.js
var fromCodePoint = function() {
  return String.fromCodePoint || function(astralCodePoint) {
    return String.fromCharCode(Math.floor((astralCodePoint - 65536) / 1024) + 55296, (astralCodePoint - 65536) % 1024 + 56320);
  };
}();
var codePointAtNative = function() {
  return String.prototype.codePointAt;
}();

// node_modules/@vkontakte/vkjs/lib/es6/html/escape.js
var escapeReplacer = new Replacer({
  "&": "&amp;",
  "<": "&lt;",
  ">": "&gt;",
  "'": "&#39;",
  '"': "&quot;"
});
var unescapeReplacer = new Replacer({
  "&amp;": "&",
  "&#38;": "&",
  "&lt;": "<",
  "&#60;": "<",
  "&gt;": ">",
  "&#62;": ">",
  "&apos;": "'",
  "&#39;": "'",
  "&quot;": '"',
  "&#34;": '"'
});
var outOfBoundsChar = String.fromCharCode(65533);

// node_modules/@vkontakte/vkjs/lib/es6/react_utils.js
function hasReactNode(value) {
  return value !== void 0 && value !== false && value !== null && value !== "";
}
function isPrimitiveReactNode(node) {
  return typeof node === "string" || typeof node === "number";
}

// node_modules/@vkontakte/vkjs/lib/es6/storage.js
var CustomStorage = function() {
  "use strict";
  function CustomStorage2() {
    var _this = this;
    _class_call_check(this, CustomStorage2);
    _define_property(this, "data", {});
    _define_property(this, "getItem", function(key) {
      return _this.data.hasOwnProperty(key) ? _this.data[key] : null;
    });
    _define_property(this, "keys", function() {
      return Object.keys(_this.data);
    });
  }
  _create_class(CustomStorage2, [
    {
      key: "setItem",
      value: function setItem(key, val) {
        this.data[key] = String(val);
      }
    },
    {
      key: "removeItem",
      value: function removeItem(id) {
        delete this.data[id];
      }
    },
    {
      key: "clear",
      value: function clear() {
        this.data = {};
      }
    },
    {
      key: "length",
      get: function get() {
        return Object.keys(this.data).length;
      }
    },
    {
      key: "key",
      value: function key(index2) {
        return Object.keys(this.data)[index2];
      }
    }
  ]);
  return CustomStorage2;
}();

// node_modules/@vkontakte/vkjs/lib/es6/IOSDetections.js
function detectIOS(ua) {
  if (!ua) {
    ua = canUseDOM ? navigator.userAgent : "";
  }
  ua = ua.toLowerCase();
  var isIPadOS2 = checkIPadOS(ua);
  var isIPad2 = isIPadOS2 || ua.includes("ipad");
  var isIPhone2 = !isIPad2 && ua.search(/iphone|ipod/) !== -1;
  var isIOS2 = isIPhone2 || isIPad2;
  var iosVersion = isIOS2 && ua.match(/os ([\d_]+) like mac os x/i);
  var iosMajor2 = 0;
  var iosMinor2 = 0;
  if (isIPadOS2) {
    iosMajor2 = 13;
    iosMinor2 = 0;
  } else if (iosVersion) {
    iosVersion = iosVersion[1].split("_");
    iosMajor2 = +iosVersion[0];
    iosMinor2 = +iosVersion[1];
  }
  iosVersion = null;
  var isScrollBasedViewport2 = iosMajor2 < 13 && !(iosMajor2 === 11 && iosMinor2 < 3);
  var isWKWebView2 = isIOS2 && checkWKWebView(ua);
  var isIPhoneX2 = false;
  if (canUseDOM) {
    isIPhoneX2 = isIOS2 && screen.width === 375 && screen.height === 812 && window.devicePixelRatio === 3;
  }
  var isIOSChrome2 = ua.search(/crios/i) !== -1;
  return {
    isIPad: isIPad2,
    isIPhone: isIPhone2,
    isIOS: isIOS2,
    isIPadOS: isIPadOS2,
    iosMajor: iosMajor2,
    iosMinor: iosMinor2,
    isWKWebView: isWKWebView2,
    isScrollBasedViewport: isScrollBasedViewport2,
    isIPhoneX: isIPhoneX2,
    isIOSChrome: isIOSChrome2
  };
}
var detect = detectIOS();
var isIPad = function() {
  return detect.isIPad;
}();
var isIPhone = function() {
  return detect.isIPhone;
}();
var isIOS = function() {
  return detect.isIOS;
}();
var isIPadOS = function() {
  return detect.isIPadOS;
}();
var iosMajor = function() {
  return detect.iosMajor;
}();
var iosMinor = function() {
  return detect.iosMinor;
}();
var isWKWebView = function() {
  return detect.isWKWebView;
}();
var isScrollBasedViewport = function() {
  return detect.isScrollBasedViewport;
}();
var isIPhoneX = function() {
  return detect.isIPhoneX;
}();
var isIOSChrome = function() {
  return detect.isIOSChrome;
}();
function checkWKWebView(ua) {
  if (!canUseDOM) {
    return false;
  }
  var webkit = window.webkit;
  if (webkit && webkit.messageHandlers) {
    return true;
  }
  var lte9 = /constructor/i.test(String(window.HTMLElement));
  var idb = !!window.indexedDB;
  if (ua.includes("safari") && ua.includes("version") && !navigator.standalone) {
  } else if (!idb && lte9 || !(window.statusbar && window.statusbar.visible)) {
  } else if (!lte9 || idb) {
    return true;
  }
  return false;
}
function checkIPadOS(ua) {
  if (!canUseDOM) {
    return false;
  }
  var isNotIOS = !/ipPad|iPhone|iPod/i.test(ua);
  var isMacOS = /Mac OS/i.test(ua);
  return isNotIOS && isMacOS && "ontouchend" in document;
}

// node_modules/@vkontakte/vkjs/lib/es6/InputUtils.js
var detect2 = function() {
  var obj = {
    hasMouse: false,
    hasTouchEvents: false,
    hasHover: false,
    hasTouch: false
  };
  if (!canUseDOM) {
    return obj;
  }
  if (isIOS && !isIPadOS) {
    obj.hasMouse = false;
    obj.hasHover = false;
    obj.hasTouchEvents = true;
    obj.hasTouch = true;
  } else {
    obj.hasTouchEvents = "ontouchstart" in document;
    obj.hasTouch = obj.hasTouchEvents || "maxTouchPoints" in navigator && navigator.maxTouchPoints > 0;
    if (obj.hasTouch) {
      var notMobile = !/android|mobile|tablet/i.test(navigator.userAgent);
      obj.hasMouse = typeof window.matchMedia === "function" && window.matchMedia("(pointer)").matches ? matchMedia("(pointer: fine)").matches : notMobile;
      obj.hasHover = obj.hasMouse && (typeof window.matchMedia === "function" && window.matchMedia("(hover)").matches ? matchMedia("(hover: hover)").matches : notMobile);
    } else {
      obj.hasMouse = true;
      obj.hasHover = true;
    }
  }
  return obj;
}();
var hasMouse = function() {
  return detect2.hasMouse;
}();
var hasHover = function() {
  return detect2.hasHover;
}();
var hasTouchEvents = function() {
  return detect2.hasTouchEvents;
}();
var hasTouch = function() {
  return detect2.hasTouch;
}();

// node_modules/@vkontakte/vkjs/lib/es6/text/transliteration.js
var transliterationDictVKRusToEng = {
  "А": "A",
  "Б": "B",
  "В": "V",
  "Г": "G",
  "¥": "G",
  "Д": "D",
  "Е": "E",
  "Є": "Ye",
  "Ё": "Yo",
  "Ж": "Zh",
  "З": "Z",
  "И": "I",
  "Ї": "Yi",
  "²": "I",
  "Й": "J",
  "К": "K",
  "Л": "L",
  "М": "M",
  "Н": "N",
  "О": "O",
  "П": "P",
  "Р": "R",
  "С": "S",
  "Т": "T",
  "У": "U",
  "Ў": "W",
  "Ф": "F",
  "Х": "Kh",
  "Ц": "Ts",
  "Ч": "Ch",
  "Ш": "Sh",
  "Щ": "Sch",
  "Ы": "Y",
  "Ый": "Y",
  "Э": "E",
  "Ю": "Yu",
  "Я": "Ya",
  "а": "a",
  "б": "b",
  "в": "v",
  "г": "g",
  "´": "g",
  "д": "d",
  "е": "e",
  "є": "ye",
  "ё": "yo",
  "ж": "zh",
  "з": "z",
  "ия": "ia",
  "ий": "y",
  "и": "i",
  "й": "y",
  "ї": "yi",
  "³": "i",
  "кс": "x",
  "к": "k",
  "л": "l",
  "м": "m",
  "н": "n",
  "о": "o",
  "п": "p",
  "р": "r",
  "с": "s",
  "т": "t",
  "у": "u",
  "ў": "w",
  "ф": "f",
  "х": "kh",
  "ц": "ts",
  "ч": "ch",
  "ш": "sh",
  "щ": "sch",
  "ъ": "",
  "ый": "y",
  "ы": "y",
  "ь": "",
  "ье": "ye",
  "ьо": "io",
  "э": "e",
  "ю": "yu",
  "я": "ya"
};
var transliterationDictVKEngToRus = {
  "a": "а",
  "b": "б",
  "v": "в",
  "g": "г",
  "d": "д",
  "e": "е",
  "z": "з",
  "i": "и",
  "j": "й",
  "k": "к",
  "l": "л",
  "m": "м",
  "n": "н",
  "o": "о",
  "p": "п",
  "r": "р",
  "s": "с",
  "t": "т",
  "u": "у",
  "f": "ф",
  "h": "х",
  "c": "ц",
  "y": "ы",
  "A": "А",
  "B": "Б",
  "V": "В",
  "G": "Г",
  "D": "Д",
  "E": "Е",
  "Z": "З",
  "I": "И",
  "J": "Й",
  "K": "К",
  "L": "Л",
  "M": "М",
  "N": "Н",
  "O": "О",
  "P": "П",
  "R": "Р",
  "S": "С",
  "T": "Т",
  "U": "У",
  "F": "Ф",
  "H": "Х",
  "C": "Ц",
  "Y": "Ы",
  "w": "в",
  "q": "к",
  "x": "кс",
  "W": "В",
  "Q": "К",
  "X": "КС",
  "yo": "ё",
  "zh": "ж",
  "kh": "х",
  "ts": "ц",
  "ch": "ч",
  "sch": "щ",
  "shch": "щ",
  "sh": "ш",
  "eh": "э",
  "yu": "ю",
  "ya": "я",
  "YO": "Ё",
  "ZH": "Ж",
  "KH": "Х",
  "TS": "Ц",
  "CH": "Ч",
  "SCH": "Щ",
  "SHCH": "Щ",
  "SH": "Ш",
  "EH": "Э",
  "YU": "Ю",
  "YA": "Я",
  "'": "ь"
};
var transliterationDictGostLetterCombinationsRu = {
  "А": "A",
  "Б": "B",
  "В": "V",
  "Г": "G",
  "Д": "D",
  "Е": "E",
  "Ё": "Yo",
  "Ж": "Zh",
  "З": "Z",
  "И": "I",
  "Й": "J",
  "К": "K",
  "Л": "L",
  "М": "M",
  "Н": "N",
  "О": "O",
  "П": "P",
  "Р": "R",
  "С": "S",
  "Т": "T",
  "У": "U",
  "Ф": "F",
  "Х": "X",
  "Ц": "Cz",
  "Ч": "Ch",
  "Ш": "Sh",
  "Щ": "Shh",
  "Ъ": "``",
  "Ы": "Y`",
  "Ь": "`",
  "Э": "E`",
  "Ю": "Yu",
  "Я": "Ya",
  "а": "a",
  "б": "b",
  "в": "v",
  "г": "g",
  "д": "d",
  "е": "e",
  "ё": "yo",
  "ж": "zh",
  "з": "z",
  "и": "i",
  "й": "j",
  "к": "k",
  "л": "l",
  "м": "m",
  "н": "n",
  "о": "o",
  "п": "p",
  "р": "r",
  "с": "s",
  "т": "t",
  "у": "u",
  "ф": "f",
  "х": "x",
  "ц": "cz",
  "ч": "ch",
  "ш": "sh",
  "щ": "shh",
  "ъ": "``",
  "ы": "y`",
  "ь": "`",
  "э": "e`",
  "ю": "yu",
  "я": "ya",
  "’": "'",
  // апостроф
  "Ѣ": "ye",
  // ять
  "Ѳ": "fh",
  //	фита
  "Ѵ": "yh"
};
var Transliterator = function() {
  "use strict";
  function Transliterator2(dict) {
    _class_call_check(this, Transliterator2);
    _define_property(this, "replacer", void 0);
    this.replacer = new Replacer(dict);
  }
  _create_class(Transliterator2, [
    {
      /**
      * Производит транслитерацию текста
      */
      key: "transliteration",
      value: function transliteration(text) {
        return this.replacer.replace(text);
      }
    }
  ]);
  return Transliterator2;
}();
var transliteratorVKRusToEng = new Transliterator(transliterationDictVKRusToEng);
var transliteratorVKEngToRus = new Transliterator(transliterationDictVKEngToRus);
var transliteratorGostLetterCombinationsRu = new Transliterator(transliterationDictGostLetterCombinationsRu);

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivity.js
var React2 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/AdaptivityProvider/AdaptivityContext.js
var React = __toESM(require_react());
var AdaptivityContext = React.createContext({});

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivity.js
var useAdaptivity = () => {
  return React2.useContext(AdaptivityContext);
};

// node_modules/@vkontakte/vkui/dist/hooks/useKeyboardInputTracker.js
var React7 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/accessibility.js
var React4 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/children.js
var React3 = __toESM(require_react());
var import_react = __toESM(require_react());
var childToString = (child) => {
  if (typeof child === "undefined" || child === null || typeof child === "boolean") {
    return "";
  }
  if (JSON.stringify(child) === "{}") {
    return "";
  }
  return child.toString();
};
var getTextFromChildren = (children) => {
  if (!(children instanceof Array) && !(0, import_react.isValidElement)(children)) {
    return childToString(children);
  }
  return import_react.Children.toArray(children).reduce((text, child) => {
    let newText = "";
    const isValidElementResult = (0, import_react.isValidElement)(child);
    const hasChildren = isValidElementResult && "children" in child.props;
    if (isValidElementResult && hasChildren) {
      newText = getTextFromChildren(child.props.children);
    } else if (isValidElementResult && !hasChildren) {
      newText = "";
    } else {
      newText = childToString(child);
    }
    return text.concat(newText);
  }, "");
};

// node_modules/@vkontakte/vkui/dist/lib/accessibility.js
var FOCUSABLE_ELEMENTS_LIST = [
  "a[href]",
  "area[href]",
  'input:not([disabled]):not([hidden]):not([type="hidden"]):not([aria-hidden])',
  "select:not([disabled]):not([hidden]):not([aria-hidden])",
  "textarea:not([disabled])",
  "button:not([disabled])",
  "iframe",
  "audio",
  "video",
  "[contenteditable]",
  '[tabindex]:not([tabindex="-1"])'
];
var Keys = {
  ENTER: "Enter",
  SPACE: "Space",
  TAB: "Tab",
  ESCAPE: "Escape",
  HOME: "Home",
  END: "End",
  DELETE: "Delete",
  BACKSPACE: "Backspace",
  ARROW_LEFT: "ArrowLeft",
  ARROW_RIGHT: "ArrowRight",
  ARROW_UP: "ArrowUp",
  ARROW_DOWN: "ArrowDown",
  PAGE_UP: "PageUp",
  PAGE_DOWN: "PageDown"
};
var EVENT_KEY_TO_COMMON_KEY_MAP = /* @__PURE__ */ new Map([
  [
    "Enter",
    Keys.ENTER
  ],
  [
    "Space",
    Keys.SPACE
  ],
  [
    "Spacebar",
    Keys.SPACE
  ],
  [
    " ",
    Keys.SPACE
  ],
  [
    "Tab",
    Keys.TAB
  ],
  [
    "Escape",
    Keys.ESCAPE
  ],
  [
    "Home",
    Keys.HOME
  ],
  [
    "End",
    Keys.END
  ],
  [
    "ArrowLeft",
    Keys.ARROW_LEFT
  ],
  [
    "ArrowRight",
    Keys.ARROW_RIGHT
  ],
  [
    "ArrowUp",
    Keys.ARROW_UP
  ],
  [
    "ArrowDown",
    Keys.ARROW_DOWN
  ],
  [
    "PageUp",
    Keys.PAGE_UP
  ],
  [
    "PageDown",
    Keys.PAGE_DOWN
  ]
]);
function pressedKey(event) {
  const foundKey = EVENT_KEY_TO_COMMON_KEY_MAP.get(event.key);
  return foundKey ? foundKey : null;
}
var FOCUS_ALLOW_LIST_KEYS = /* @__PURE__ */ new Set([
  Keys.TAB,
  Keys.ARROW_LEFT,
  Keys.ARROW_RIGHT,
  Keys.ARROW_UP,
  Keys.ARROW_DOWN,
  Keys.BACKSPACE,
  Keys.DELETE
]);
function isKeyboardFocusingStarted(event) {
  return FOCUS_ALLOW_LIST_KEYS.has(event.key);
}
function shouldTriggerClickOnEnterOrSpace(e) {
  const el = e.target;
  const { tagName } = el;
  const role = el.getAttribute("role");
  const isValidKeyboardEventTarget = el.isContentEditable !== true && tagName !== "INPUT" && tagName !== "TEXTAREA" && (role === "button" || role === "link" || role === "menuitem");
  const isNativeAnchorEl = tagName === "A" && el.hasAttribute("href");
  const keyPressed = pressedKey(e);
  return isValidKeyboardEventTarget && // trigger buttons on Space
  (keyPressed === Keys.SPACE && role === "button" || // trigger non-native links and buttons on Enter
  keyPressed === Keys.ENTER && !isNativeAnchorEl);
}
var injectAriaExpandedPropByRole = (props, state, role) => {
  switch (role) {
    case "menu":
    case "application":
    case "tab":
    case "menuitem":
    case "treeitem":
    case "gridcell":
      props["aria-expanded"] = state;
      return props;
    default:
      return props;
  }
};
function hasAccessibleName({ "aria-label": ariaLabel, "aria-labelledby": ariaLabelledBy, title, children }) {
  if (ariaLabel || ariaLabelledBy || title) {
    return true;
  }
  const accessibleLabel = getTextFromChildren(children);
  if (accessibleLabel.trim() !== "") {
    return true;
  }
  return false;
}
var getHorizontalFocusGoTo = (keys) => {
  switch (keys) {
    case Keys.ARROW_UP:
    case Keys.ARROW_LEFT:
      return "prev";
    case Keys.ARROW_DOWN:
    case Keys.ARROW_RIGHT:
      return "next";
  }
};

// node_modules/@vkontakte/vkui/dist/lib/dom.js
var React5 = __toESM(require_react());

// node_modules/@swc/helpers/esm/_async_to_generator.js
function asyncGeneratorStep(gen, resolve, reject, _next, _throw, key, arg) {
  try {
    var info = gen[key](arg);
    var value = info.value;
  } catch (error) {
    reject(error);
    return;
  }
  if (info.done)
    resolve(value);
  else
    Promise.resolve(value).then(_next, _throw);
}
function _async_to_generator(fn) {
  return function() {
    var self2 = this, args = arguments;
    return new Promise(function(resolve, reject) {
      var gen = fn.apply(self2, args);
      function _next(value) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "next", value);
      }
      function _throw(err) {
        asyncGeneratorStep(gen, resolve, reject, _next, _throw, "throw", err);
      }
      _next(void 0);
    });
  };
}

// node_modules/tslib/tslib.es6.mjs
function __generator(thisArg, body) {
  var _ = { label: 0, sent: function() {
    if (t[0] & 1)
      throw t[1];
    return t[1];
  }, trys: [], ops: [] }, f, y, t, g;
  return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() {
    return this;
  }), g;
  function verb(n) {
    return function(v) {
      return step([n, v]);
    };
  }
  function step(op) {
    if (f)
      throw new TypeError("Generator is already executing.");
    while (g && (g = 0, op[0] && (_ = 0)), _)
      try {
        if (f = 1, y && (t = op[0] & 2 ? y["return"] : op[0] ? y["throw"] || ((t = y["return"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done)
          return t;
        if (y = 0, t)
          op = [op[0] & 2, t.value];
        switch (op[0]) {
          case 0:
          case 1:
            t = op;
            break;
          case 4:
            _.label++;
            return { value: op[1], done: false };
          case 5:
            _.label++;
            y = op[1];
            op = [0];
            continue;
          case 7:
            op = _.ops.pop();
            _.trys.pop();
            continue;
          default:
            if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) {
              _ = 0;
              continue;
            }
            if (op[0] === 3 && (!t || op[1] > t[0] && op[1] < t[3])) {
              _.label = op[1];
              break;
            }
            if (op[0] === 6 && _.label < t[1]) {
              _.label = t[1];
              t = op;
              break;
            }
            if (t && _.label < t[2]) {
              _.label = t[2];
              _.ops.push(op);
              break;
            }
            if (t[2])
              _.ops.pop();
            _.trys.pop();
            continue;
        }
        op = body.call(thisArg, _);
      } catch (e) {
        op = [6, e];
        y = 0;
      } finally {
        f = t = 0;
      }
    if (op[0] & 5)
      throw op[1];
    return { value: op[0] ? op[1] : void 0, done: true };
  }
}

// node_modules/@vkontakte/vkui-floating-ui/utils/dist/floating-ui.utils.mjs
var sides = [
  "top",
  "right",
  "bottom",
  "left"
];
var alignments = [
  "start",
  "end"
];
var placements = sides.reduce(function(acc, side) {
  return acc.concat(side, side + "-" + alignments[0], side + "-" + alignments[1]);
}, []);
var min = Math.min;
var max = Math.max;
var round = Math.round;
var floor = Math.floor;
var createCoords = function(v) {
  return {
    x: v,
    y: v
  };
};
var oppositeSideMap = {
  left: "right",
  right: "left",
  bottom: "top",
  top: "bottom"
};
var oppositeAlignmentMap = {
  start: "end",
  end: "start"
};
function clamp(start, value, end) {
  return max(start, min(value, end));
}
function evaluate(value, param) {
  return typeof value === "function" ? value(param) : value;
}
function getSide(placement) {
  return placement.split("-")[0];
}
function getAlignment(placement) {
  return placement.split("-")[1];
}
function getOppositeAxis(axis) {
  return axis === "x" ? "y" : "x";
}
function getAxisLength(axis) {
  return axis === "y" ? "height" : "width";
}
function getSideAxis(placement) {
  return [
    "top",
    "bottom"
  ].includes(getSide(placement)) ? "y" : "x";
}
function getAlignmentAxis(placement) {
  return getOppositeAxis(getSideAxis(placement));
}
function getAlignmentSides(placement, rects, rtl) {
  if (rtl === void 0) {
    rtl = false;
  }
  var alignment = getAlignment(placement);
  var alignmentAxis = getAlignmentAxis(placement);
  var length = getAxisLength(alignmentAxis);
  var mainAlignmentSide = alignmentAxis === "x" ? alignment === (rtl ? "end" : "start") ? "right" : "left" : alignment === "start" ? "bottom" : "top";
  if (rects.reference[length] > rects.floating[length]) {
    mainAlignmentSide = getOppositePlacement(mainAlignmentSide);
  }
  return [
    mainAlignmentSide,
    getOppositePlacement(mainAlignmentSide)
  ];
}
function getExpandedPlacements(placement) {
  var oppositePlacement = getOppositePlacement(placement);
  return [
    getOppositeAlignmentPlacement(placement),
    oppositePlacement,
    getOppositeAlignmentPlacement(oppositePlacement)
  ];
}
function getOppositeAlignmentPlacement(placement) {
  return placement.replace(/start|end/g, function(alignment) {
    return oppositeAlignmentMap[alignment];
  });
}
function getSideList(side, isStart, rtl) {
  var lr = [
    "left",
    "right"
  ];
  var rl = [
    "right",
    "left"
  ];
  var tb = [
    "top",
    "bottom"
  ];
  var bt = [
    "bottom",
    "top"
  ];
  switch (side) {
    case "top":
    case "bottom":
      if (rtl)
        return isStart ? rl : lr;
      return isStart ? lr : rl;
    case "left":
    case "right":
      return isStart ? tb : bt;
    default:
      return [];
  }
}
function getOppositeAxisPlacements(placement, flipAlignment, direction, rtl) {
  var alignment = getAlignment(placement);
  var list = getSideList(getSide(placement), direction === "start", rtl);
  if (alignment) {
    list = list.map(function(side) {
      return side + "-" + alignment;
    });
    if (flipAlignment) {
      list = list.concat(list.map(getOppositeAlignmentPlacement));
    }
  }
  return list;
}
function getOppositePlacement(placement) {
  return placement.replace(/left|right|bottom|top/g, function(side) {
    return oppositeSideMap[side];
  });
}
function expandPaddingObject(padding) {
  return _object_spread({
    top: 0,
    right: 0,
    bottom: 0,
    left: 0
  }, padding);
}
function getPaddingObject(padding) {
  return typeof padding !== "number" ? expandPaddingObject(padding) : {
    top: padding,
    right: padding,
    bottom: padding,
    left: padding
  };
}
function rectToClientRect(rect) {
  return _object_spread_props(_object_spread({}, rect), {
    top: rect.y,
    left: rect.x,
    right: rect.x + rect.width,
    bottom: rect.y + rect.height
  });
}

// node_modules/@vkontakte/vkui-floating-ui/core/dist/floating-ui.core.mjs
function computeCoordsFromPlacement(_ref, placement, rtl) {
  var reference = _ref.reference, floating = _ref.floating;
  var sideAxis = getSideAxis(placement);
  var alignmentAxis = getAlignmentAxis(placement);
  var alignLength = getAxisLength(alignmentAxis);
  var side = getSide(placement);
  var isVertical = sideAxis === "y";
  var commonX = reference.x + reference.width / 2 - floating.width / 2;
  var commonY = reference.y + reference.height / 2 - floating.height / 2;
  var commonAlign = reference[alignLength] / 2 - floating[alignLength] / 2;
  var coords;
  switch (side) {
    case "top":
      coords = {
        x: commonX,
        y: reference.y - floating.height
      };
      break;
    case "bottom":
      coords = {
        x: commonX,
        y: reference.y + reference.height
      };
      break;
    case "right":
      coords = {
        x: reference.x + reference.width,
        y: commonY
      };
      break;
    case "left":
      coords = {
        x: reference.x - floating.width,
        y: commonY
      };
      break;
    default:
      coords = {
        x: reference.x,
        y: reference.y
      };
  }
  switch (getAlignment(placement)) {
    case "start":
      coords[alignmentAxis] -= commonAlign * (rtl && isVertical ? -1 : 1);
      break;
    case "end":
      coords[alignmentAxis] += commonAlign * (rtl && isVertical ? -1 : 1);
      break;
  }
  return coords;
}
var computePosition = function() {
  var _ref = _async_to_generator(function(reference, floating, config) {
    var _config_placement, placement, _config_strategy, strategy, _config_middleware, middleware, platform3, validMiddleware, rtl, rects, _computeCoordsFromPlacement, x, y, statefulPlacement, middlewareData, resetCount, i, _validMiddleware_i, name, fn, _ref2, nextX, nextY, data, reset, _tmp, ref;
    return __generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          _config_placement = config.placement, placement = _config_placement === void 0 ? "bottom" : _config_placement, _config_strategy = config.strategy, strategy = _config_strategy === void 0 ? "absolute" : _config_strategy, _config_middleware = config.middleware, middleware = _config_middleware === void 0 ? [] : _config_middleware, platform3 = config.platform;
          validMiddleware = middleware.filter(Boolean);
          return [
            4,
            platform3.isRTL == null ? void 0 : platform3.isRTL(floating)
          ];
        case 1:
          rtl = _state.sent();
          return [
            4,
            platform3.getElementRects({
              reference,
              floating,
              strategy
            })
          ];
        case 2:
          rects = _state.sent();
          _computeCoordsFromPlacement = computeCoordsFromPlacement(rects, placement, rtl), x = _computeCoordsFromPlacement.x, y = _computeCoordsFromPlacement.y;
          statefulPlacement = placement;
          middlewareData = {};
          resetCount = 0;
          i = 0;
          _state.label = 3;
        case 3:
          if (!(i < validMiddleware.length))
            return [
              3,
              11
            ];
          _validMiddleware_i = validMiddleware[i], name = _validMiddleware_i.name, fn = _validMiddleware_i.fn;
          return [
            4,
            fn({
              x,
              y,
              initialPlacement: placement,
              placement: statefulPlacement,
              strategy,
              middlewareData,
              rects,
              platform: platform3,
              elements: {
                reference,
                floating
              }
            })
          ];
        case 4:
          _ref2 = _state.sent(), nextX = _ref2.x, nextY = _ref2.y, data = _ref2.data, reset = _ref2.reset;
          x = nextX != null ? nextX : x;
          y = nextY != null ? nextY : y;
          middlewareData = _object_spread_props(_object_spread({}, middlewareData), _define_property({}, name, _object_spread({}, middlewareData[name], data)));
          if (!(reset && resetCount <= 50))
            return [
              3,
              10
            ];
          resetCount++;
          if (!(typeof reset === "object"))
            return [
              3,
              9
            ];
          if (reset.placement) {
            statefulPlacement = reset.placement;
          }
          if (!reset.rects)
            return [
              3,
              8
            ];
          if (!(reset.rects === true))
            return [
              3,
              6
            ];
          return [
            4,
            platform3.getElementRects({
              reference,
              floating,
              strategy
            })
          ];
        case 5:
          _tmp = _state.sent();
          return [
            3,
            7
          ];
        case 6:
          _tmp = reset.rects;
          _state.label = 7;
        case 7:
          rects = _tmp;
          _state.label = 8;
        case 8:
          ref = computeCoordsFromPlacement(rects, statefulPlacement, rtl), x = ref.x, y = ref.y, ref;
          _state.label = 9;
        case 9:
          i = -1;
          _state.label = 10;
        case 10:
          i++;
          return [
            3,
            3
          ];
        case 11:
          return [
            2,
            {
              x,
              y,
              placement: statefulPlacement,
              strategy,
              middlewareData
            }
          ];
      }
    });
  });
  return function computePosition3(reference, floating, config) {
    return _ref.apply(this, arguments);
  };
}();
function detectOverflow(state, options) {
  return _detectOverflow.apply(this, arguments);
}
function _detectOverflow() {
  _detectOverflow = /**
  * Resolves with an object of overflow side offsets that determine how much the
  * element is overflowing a given clipping boundary on each side.
  * - positive = overflowing the boundary by that number of pixels
  * - negative = how many pixels left before it will overflow
  * - 0 = lies flush with the boundary
  * @see https://floating-ui.com/docs/detectOverflow
  */
  _async_to_generator(function(state, options) {
    var _await$platform$isEle, x, y, platform3, rects, elements, strategy, _evaluate, _evaluate_boundary, boundary, _evaluate_rootBoundary, rootBoundary, _evaluate_elementContext, elementContext, _evaluate_altBoundary, altBoundary, _evaluate_padding, padding, paddingObject, altContext, element, clippingClientRect, _, _tmp, _tmp1, _tmp2, rect, offsetParent, offsetScale, _tmp3, elementClientRect, _tmp4;
    return __generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          if (options === void 0) {
            options = {};
          }
          x = state.x, y = state.y, platform3 = state.platform, rects = state.rects, elements = state.elements, strategy = state.strategy;
          _evaluate = evaluate(options, state), _evaluate_boundary = _evaluate.boundary, boundary = _evaluate_boundary === void 0 ? "clippingAncestors" : _evaluate_boundary, _evaluate_rootBoundary = _evaluate.rootBoundary, rootBoundary = _evaluate_rootBoundary === void 0 ? "viewport" : _evaluate_rootBoundary, _evaluate_elementContext = _evaluate.elementContext, elementContext = _evaluate_elementContext === void 0 ? "floating" : _evaluate_elementContext, _evaluate_altBoundary = _evaluate.altBoundary, altBoundary = _evaluate_altBoundary === void 0 ? false : _evaluate_altBoundary, _evaluate_padding = _evaluate.padding, padding = _evaluate_padding === void 0 ? 0 : _evaluate_padding;
          paddingObject = getPaddingObject(padding);
          altContext = elementContext === "floating" ? "reference" : "floating";
          element = elements[altBoundary ? altContext : elementContext];
          _ = platform3.getClippingRect;
          _tmp = {};
          return [
            4,
            platform3.isElement == null ? void 0 : platform3.isElement(element)
          ];
        case 1:
          if (!((_await$platform$isEle = _state.sent()) != null ? _await$platform$isEle : true))
            return [
              3,
              2
            ];
          _tmp1 = element;
          return [
            3,
            5
          ];
        case 2:
          _tmp2 = element.contextElement;
          if (_tmp2)
            return [
              3,
              4
            ];
          return [
            4,
            platform3.getDocumentElement == null ? void 0 : platform3.getDocumentElement(elements.floating)
          ];
        case 3:
          _tmp2 = _state.sent();
          _state.label = 4;
        case 4:
          _tmp1 = _tmp2;
          _state.label = 5;
        case 5:
          return [
            4,
            _.apply(platform3, [
              (_tmp.element = _tmp1, _tmp.boundary = boundary, _tmp.rootBoundary = rootBoundary, _tmp.strategy = strategy, _tmp)
            ])
          ];
        case 6:
          clippingClientRect = rectToClientRect.apply(void 0, [
            _state.sent()
          ]);
          rect = elementContext === "floating" ? _object_spread_props(_object_spread({}, rects.floating), {
            x,
            y
          }) : rects.reference;
          return [
            4,
            platform3.getOffsetParent == null ? void 0 : platform3.getOffsetParent(elements.floating)
          ];
        case 7:
          offsetParent = _state.sent();
          return [
            4,
            platform3.isElement == null ? void 0 : platform3.isElement(offsetParent)
          ];
        case 8:
          if (!_state.sent())
            return [
              3,
              10
            ];
          return [
            4,
            platform3.getScale == null ? void 0 : platform3.getScale(offsetParent)
          ];
        case 9:
          _tmp3 = _state.sent() || {
            x: 1,
            y: 1
          };
          return [
            3,
            11
          ];
        case 10:
          _tmp3 = {
            x: 1,
            y: 1
          };
          _state.label = 11;
        case 11:
          offsetScale = _tmp3;
          if (!platform3.convertOffsetParentRelativeRectToViewportRelativeRect)
            return [
              3,
              13
            ];
          return [
            4,
            platform3.convertOffsetParentRelativeRectToViewportRelativeRect({
              elements,
              rect,
              offsetParent,
              strategy
            })
          ];
        case 12:
          _tmp4 = _state.sent();
          return [
            3,
            14
          ];
        case 13:
          _tmp4 = rect;
          _state.label = 14;
        case 14:
          elementClientRect = rectToClientRect.apply(void 0, [
            _tmp4
          ]);
          return [
            2,
            {
              top: (clippingClientRect.top - elementClientRect.top + paddingObject.top) / offsetScale.y,
              bottom: (elementClientRect.bottom - clippingClientRect.bottom + paddingObject.bottom) / offsetScale.y,
              left: (clippingClientRect.left - elementClientRect.left + paddingObject.left) / offsetScale.x,
              right: (elementClientRect.right - clippingClientRect.right + paddingObject.right) / offsetScale.x
            }
          ];
      }
    });
  });
  return _detectOverflow.apply(this, arguments);
}
var arrow = function(options) {
  return {
    name: "arrow",
    options,
    fn: function fn(state) {
      return _async_to_generator(function() {
        var x, y, placement, rects, platform3, elements, middlewareData, _ref, element, _ref_padding, padding, paddingObject, coords, axis, length, arrowDimensions, isYAxis, minProp, maxProp, clientProp, endDiff, startDiff, arrowOffsetParent, clientSize, _tmp, centerToReference, largestPossiblePadding, minPadding, maxPadding, min$1, max2, center, offset3, shouldAddOffset, alignmentOffset, _obj, _obj1;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              x = state.x, y = state.y, placement = state.placement, rects = state.rects, platform3 = state.platform, elements = state.elements, middlewareData = state.middlewareData;
              _ref = evaluate(options, state) || {}, element = _ref.element, _ref_padding = _ref.padding, padding = _ref_padding === void 0 ? 0 : _ref_padding;
              if (element == null) {
                return [
                  2,
                  {}
                ];
              }
              paddingObject = getPaddingObject(padding);
              coords = {
                x,
                y
              };
              axis = getAlignmentAxis(placement);
              length = getAxisLength(axis);
              return [
                4,
                platform3.getDimensions(element)
              ];
            case 1:
              arrowDimensions = _state.sent();
              isYAxis = axis === "y";
              minProp = isYAxis ? "top" : "left";
              maxProp = isYAxis ? "bottom" : "right";
              clientProp = isYAxis ? "clientHeight" : "clientWidth";
              endDiff = rects.reference[length] + rects.reference[axis] - coords[axis] - rects.floating[length];
              startDiff = coords[axis] - rects.reference[axis];
              return [
                4,
                platform3.getOffsetParent == null ? void 0 : platform3.getOffsetParent(element)
              ];
            case 2:
              arrowOffsetParent = _state.sent();
              clientSize = arrowOffsetParent ? arrowOffsetParent[clientProp] : 0;
              _tmp = !clientSize;
              if (_tmp)
                return [
                  3,
                  4
                ];
              return [
                4,
                platform3.isElement == null ? void 0 : platform3.isElement(arrowOffsetParent)
              ];
            case 3:
              _tmp = !_state.sent();
              _state.label = 4;
            case 4:
              if (_tmp) {
                clientSize = elements.floating[clientProp] || rects.floating[length];
              }
              centerToReference = endDiff / 2 - startDiff / 2;
              largestPossiblePadding = clientSize / 2 - arrowDimensions[length] / 2 - 1;
              minPadding = min(paddingObject[minProp], largestPossiblePadding);
              maxPadding = min(paddingObject[maxProp], largestPossiblePadding);
              min$1 = minPadding;
              max2 = clientSize - arrowDimensions[length] - maxPadding;
              center = clientSize / 2 - arrowDimensions[length] / 2 + centerToReference;
              offset3 = clamp(min$1, center, max2);
              shouldAddOffset = !middlewareData.arrow && getAlignment(placement) != null && center !== offset3 && rects.reference[length] / 2 - (center < min$1 ? minPadding : maxPadding) - arrowDimensions[length] / 2 < 0;
              alignmentOffset = shouldAddOffset ? center < min$1 ? center - min$1 : center - max2 : 0;
              return [
                2,
                (_obj1 = {}, _define_property(_obj1, axis, coords[axis] + alignmentOffset), _define_property(_obj1, "data", _object_spread((_obj = {}, _define_property(_obj, axis, offset3), _define_property(_obj, "centerOffset", center - offset3 - alignmentOffset), _obj), shouldAddOffset && {
                  alignmentOffset
                })), _define_property(_obj1, "reset", shouldAddOffset), _obj1)
              ];
          }
        });
      })();
    }
  };
};
function getPlacementList(alignment, autoAlignment, allowedPlacements) {
  var allowedPlacementsSortedByAlignment = alignment ? _to_consumable_array(allowedPlacements.filter(function(placement) {
    return getAlignment(placement) === alignment;
  })).concat(_to_consumable_array(allowedPlacements.filter(function(placement) {
    return getAlignment(placement) !== alignment;
  }))) : allowedPlacements.filter(function(placement) {
    return getSide(placement) === placement;
  });
  return allowedPlacementsSortedByAlignment.filter(function(placement) {
    if (alignment) {
      return getAlignment(placement) === alignment || (autoAlignment ? getOppositeAlignmentPlacement(placement) !== placement : false);
    }
    return true;
  });
}
var autoPlacement = function autoPlacement2(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "autoPlacement",
    options,
    fn: function fn(state) {
      return _async_to_generator(function() {
        var _middlewareData$autoP, _middlewareData$autoP2, _placementsThatFitOnE, rects, middlewareData, placement, platform3, elements, _evaluate, _evaluate_crossAxis, crossAxis, alignment, _evaluate_allowedPlacements, allowedPlacements, _evaluate_autoAlignment, autoAlignment, detectOverflowOptions, placements$1, overflow, currentIndex, currentPlacement, alignmentSides, _tmp, currentOverflows, allOverflows, nextPlacement, placementsSortedByMostSpace, placementsThatFitOnEachSide, resetPlacement;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              rects = state.rects, middlewareData = state.middlewareData, placement = state.placement, platform3 = state.platform, elements = state.elements;
              _evaluate = evaluate(options, state), _evaluate_crossAxis = _evaluate.crossAxis, crossAxis = _evaluate_crossAxis === void 0 ? false : _evaluate_crossAxis, alignment = _evaluate.alignment, _evaluate_allowedPlacements = _evaluate.allowedPlacements, allowedPlacements = _evaluate_allowedPlacements === void 0 ? placements : _evaluate_allowedPlacements, _evaluate_autoAlignment = _evaluate.autoAlignment, autoAlignment = _evaluate_autoAlignment === void 0 ? true : _evaluate_autoAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [
                "crossAxis",
                "alignment",
                "allowedPlacements",
                "autoAlignment"
              ]);
              placements$1 = alignment !== void 0 || allowedPlacements === placements ? getPlacementList(alignment || null, autoAlignment, allowedPlacements) : allowedPlacements;
              return [
                4,
                detectOverflow(state, detectOverflowOptions)
              ];
            case 1:
              overflow = _state.sent();
              currentIndex = ((_middlewareData$autoP = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP.index) || 0;
              currentPlacement = placements$1[currentIndex];
              if (currentPlacement == null) {
                return [
                  2,
                  {}
                ];
              }
              _tmp = [
                currentPlacement,
                rects
              ];
              return [
                4,
                platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating)
              ];
            case 2:
              alignmentSides = getAlignmentSides.apply(void 0, _tmp.concat([
                _state.sent()
              ]));
              if (placement !== currentPlacement) {
                return [
                  2,
                  {
                    reset: {
                      placement: placements$1[0]
                    }
                  }
                ];
              }
              currentOverflows = [
                overflow[getSide(currentPlacement)],
                overflow[alignmentSides[0]],
                overflow[alignmentSides[1]]
              ];
              allOverflows = _to_consumable_array(((_middlewareData$autoP2 = middlewareData.autoPlacement) == null ? void 0 : _middlewareData$autoP2.overflows) || []).concat([
                {
                  placement: currentPlacement,
                  overflows: currentOverflows
                }
              ]);
              nextPlacement = placements$1[currentIndex + 1];
              if (nextPlacement) {
                return [
                  2,
                  {
                    data: {
                      index: currentIndex + 1,
                      overflows: allOverflows
                    },
                    reset: {
                      placement: nextPlacement
                    }
                  }
                ];
              }
              placementsSortedByMostSpace = allOverflows.map(function(d) {
                var alignment2 = getAlignment(d.placement);
                return [
                  d.placement,
                  alignment2 && crossAxis ? (
                    // Check along the mainAxis and main crossAxis side.
                    d.overflows.slice(0, 2).reduce(function(acc, v) {
                      return acc + v;
                    }, 0)
                  ) : (
                    // Check only the mainAxis.
                    d.overflows[0]
                  ),
                  d.overflows
                ];
              }).sort(function(a, b) {
                return a[1] - b[1];
              });
              placementsThatFitOnEachSide = placementsSortedByMostSpace.filter(function(d) {
                return d[2].slice(
                  0,
                  // Aligned placements should not check their opposite crossAxis
                  // side.
                  getAlignment(d[0]) ? 2 : 3
                ).every(function(v) {
                  return v <= 0;
                });
              });
              resetPlacement = ((_placementsThatFitOnE = placementsThatFitOnEachSide[0]) == null ? void 0 : _placementsThatFitOnE[0]) || placementsSortedByMostSpace[0][0];
              if (resetPlacement !== placement) {
                return [
                  2,
                  {
                    data: {
                      index: currentIndex + 1,
                      overflows: allOverflows
                    },
                    reset: {
                      placement: resetPlacement
                    }
                  }
                ];
              }
              return [
                2,
                {}
              ];
          }
        });
      })();
    }
  };
};
var flip = function flip2(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "flip",
    options,
    fn: function fn(state) {
      return _async_to_generator(function() {
        var _middlewareData$arrow, _middlewareData$flip, placement, middlewareData, rects, initialPlacement, platform3, elements, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, specifiedFallbackPlacements, _evaluate_fallbackStrategy, fallbackStrategy, _evaluate_fallbackAxisSideDirection, fallbackAxisSideDirection, _evaluate_flipAlignment, flipAlignment, detectOverflowOptions, side, isBasePlacement, rtl, fallbackPlacements, _fallbackPlacements, placements2, overflow, overflows, overflowsData, sides2, _middlewareData$flip2, _overflowsData$filter, nextIndex, nextPlacement, resetPlacement, _overflowsData$map$so, placement1;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              placement = state.placement, middlewareData = state.middlewareData, rects = state.rects, initialPlacement = state.initialPlacement, platform3 = state.platform, elements = state.elements;
              _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? true : tmp1, specifiedFallbackPlacements = _evaluate.fallbackPlacements, _evaluate_fallbackStrategy = _evaluate.fallbackStrategy, fallbackStrategy = _evaluate_fallbackStrategy === void 0 ? "bestFit" : _evaluate_fallbackStrategy, _evaluate_fallbackAxisSideDirection = _evaluate.fallbackAxisSideDirection, fallbackAxisSideDirection = _evaluate_fallbackAxisSideDirection === void 0 ? "none" : _evaluate_fallbackAxisSideDirection, _evaluate_flipAlignment = _evaluate.flipAlignment, flipAlignment = _evaluate_flipAlignment === void 0 ? true : _evaluate_flipAlignment, detectOverflowOptions = _object_without_properties(_evaluate, [
                "mainAxis",
                "crossAxis",
                "fallbackPlacements",
                "fallbackStrategy",
                "fallbackAxisSideDirection",
                "flipAlignment"
              ]);
              if ((_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
                return [
                  2,
                  {}
                ];
              }
              side = getSide(placement);
              isBasePlacement = getSide(initialPlacement) === initialPlacement;
              return [
                4,
                platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating)
              ];
            case 1:
              rtl = _state.sent();
              fallbackPlacements = specifiedFallbackPlacements || (isBasePlacement || !flipAlignment ? [
                getOppositePlacement(initialPlacement)
              ] : getExpandedPlacements(initialPlacement));
              if (!specifiedFallbackPlacements && fallbackAxisSideDirection !== "none") {
                ;
                (_fallbackPlacements = fallbackPlacements).push.apply(_fallbackPlacements, _to_consumable_array(getOppositeAxisPlacements(initialPlacement, flipAlignment, fallbackAxisSideDirection, rtl)));
              }
              placements2 = [
                initialPlacement
              ].concat(_to_consumable_array(fallbackPlacements));
              return [
                4,
                detectOverflow(state, detectOverflowOptions)
              ];
            case 2:
              overflow = _state.sent();
              overflows = [];
              overflowsData = ((_middlewareData$flip = middlewareData.flip) == null ? void 0 : _middlewareData$flip.overflows) || [];
              if (checkMainAxis) {
                overflows.push(overflow[side]);
              }
              if (checkCrossAxis) {
                sides2 = getAlignmentSides(placement, rects, rtl);
                overflows.push(overflow[sides2[0]], overflow[sides2[1]]);
              }
              overflowsData = _to_consumable_array(overflowsData).concat([
                {
                  placement,
                  overflows
                }
              ]);
              if (!overflows.every(function(side2) {
                return side2 <= 0;
              })) {
                ;
                nextIndex = (((_middlewareData$flip2 = middlewareData.flip) == null ? void 0 : _middlewareData$flip2.index) || 0) + 1;
                nextPlacement = placements2[nextIndex];
                if (nextPlacement) {
                  return [
                    2,
                    {
                      data: {
                        index: nextIndex,
                        overflows: overflowsData
                      },
                      reset: {
                        placement: nextPlacement
                      }
                    }
                  ];
                }
                resetPlacement = (_overflowsData$filter = overflowsData.filter(function(d) {
                  return d.overflows[0] <= 0;
                }).sort(function(a, b) {
                  return a.overflows[1] - b.overflows[1];
                })[0]) == null ? void 0 : _overflowsData$filter.placement;
                if (!resetPlacement) {
                  switch (fallbackStrategy) {
                    case "bestFit": {
                      ;
                      placement1 = (_overflowsData$map$so = overflowsData.map(function(d) {
                        return [
                          d.placement,
                          d.overflows.filter(function(overflow2) {
                            return overflow2 > 0;
                          }).reduce(function(acc, overflow2) {
                            return acc + overflow2;
                          }, 0)
                        ];
                      }).sort(function(a, b) {
                        return a[1] - b[1];
                      })[0]) == null ? void 0 : _overflowsData$map$so[0];
                      if (placement1) {
                        resetPlacement = placement1;
                      }
                      break;
                    }
                    case "initialPlacement":
                      resetPlacement = initialPlacement;
                      break;
                  }
                }
                if (placement !== resetPlacement) {
                  return [
                    2,
                    {
                      reset: {
                        placement: resetPlacement
                      }
                    }
                  ];
                }
              }
              return [
                2,
                {}
              ];
          }
        });
      })();
    }
  };
};
function getSideOffsets(overflow, rect) {
  return {
    top: overflow.top - rect.height,
    right: overflow.right - rect.width,
    bottom: overflow.bottom - rect.height,
    left: overflow.left - rect.width
  };
}
function isAnySideFullyClipped(overflow) {
  return sides.some(function(side) {
    return overflow[side] >= 0;
  });
}
var hide = function hide2(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "hide",
    options,
    fn: function fn(state) {
      return _async_to_generator(function() {
        var rects, _evaluate, _evaluate_strategy, strategy, detectOverflowOptions, overflow, offsets, overflow1, offsets1;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              rects = state.rects;
              _evaluate = evaluate(options, state), _evaluate_strategy = _evaluate.strategy, strategy = _evaluate_strategy === void 0 ? "referenceHidden" : _evaluate_strategy, detectOverflowOptions = _object_without_properties(_evaluate, [
                "strategy"
              ]);
              switch (strategy) {
                case "referenceHidden":
                  return [
                    3,
                    1
                  ];
                case "escaped":
                  return [
                    3,
                    3
                  ];
              }
              return [
                3,
                5
              ];
            case 1:
              return [
                4,
                detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {
                  elementContext: "reference"
                }))
              ];
            case 2:
              overflow = _state.sent();
              offsets = getSideOffsets(overflow, rects.reference);
              return [
                2,
                {
                  data: {
                    referenceHiddenOffsets: offsets,
                    referenceHidden: isAnySideFullyClipped(offsets)
                  }
                }
              ];
            case 3:
              return [
                4,
                detectOverflow(state, _object_spread_props(_object_spread({}, detectOverflowOptions), {
                  altBoundary: true
                }))
              ];
            case 4:
              overflow1 = _state.sent();
              offsets1 = getSideOffsets(overflow1, rects.floating);
              return [
                2,
                {
                  data: {
                    escapedOffsets: offsets1,
                    escaped: isAnySideFullyClipped(offsets1)
                  }
                }
              ];
            case 5:
              {
                return [
                  2,
                  {}
                ];
              }
              _state.label = 6;
            case 6:
              return [
                2
              ];
          }
        });
      })();
    }
  };
};
function convertValueToCoords(state, options) {
  return _convertValueToCoords.apply(this, arguments);
}
function _convertValueToCoords() {
  _convertValueToCoords = // For type backwards-compatibility, the `OffsetOptions` type was also
  // Derivable.
  _async_to_generator(function(state, options) {
    var placement, platform3, elements, rtl, side, alignment, isVertical, mainAxisMulti, crossAxisMulti, rawValue, _ref, mainAxis, crossAxis, alignmentAxis;
    return __generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          placement = state.placement, platform3 = state.platform, elements = state.elements;
          return [
            4,
            platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating)
          ];
        case 1:
          rtl = _state.sent();
          side = getSide(placement);
          alignment = getAlignment(placement);
          isVertical = getSideAxis(placement) === "y";
          mainAxisMulti = [
            "left",
            "top"
          ].includes(side) ? -1 : 1;
          crossAxisMulti = rtl && isVertical ? -1 : 1;
          rawValue = evaluate(options, state);
          _ref = typeof rawValue === "number" ? {
            mainAxis: rawValue,
            crossAxis: 0,
            alignmentAxis: null
          } : _object_spread({
            mainAxis: 0,
            crossAxis: 0,
            alignmentAxis: null
          }, rawValue), mainAxis = _ref.mainAxis, crossAxis = _ref.crossAxis, alignmentAxis = _ref.alignmentAxis;
          if (alignment && typeof alignmentAxis === "number") {
            crossAxis = alignment === "end" ? alignmentAxis * -1 : alignmentAxis;
          }
          return [
            2,
            isVertical ? {
              x: crossAxis * crossAxisMulti,
              y: mainAxis * mainAxisMulti
            } : {
              x: mainAxis * mainAxisMulti,
              y: crossAxis * crossAxisMulti
            }
          ];
      }
    });
  });
  return _convertValueToCoords.apply(this, arguments);
}
var offset = function offset2(options) {
  if (options === void 0) {
    options = 0;
  }
  return {
    name: "offset",
    options,
    fn: function fn(state) {
      return _async_to_generator(function() {
        var _middlewareData$offse, _middlewareData$arrow, x, y, placement, middlewareData, diffCoords;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              x = state.x, y = state.y, placement = state.placement, middlewareData = state.middlewareData;
              return [
                4,
                convertValueToCoords(state, options)
              ];
            case 1:
              diffCoords = _state.sent();
              if (placement === ((_middlewareData$offse = middlewareData.offset) == null ? void 0 : _middlewareData$offse.placement) && (_middlewareData$arrow = middlewareData.arrow) != null && _middlewareData$arrow.alignmentOffset) {
                return [
                  2,
                  {}
                ];
              }
              return [
                2,
                {
                  x: x + diffCoords.x,
                  y: y + diffCoords.y,
                  data: _object_spread_props(_object_spread({}, diffCoords), {
                    placement
                  })
                }
              ];
          }
        });
      })();
    }
  };
};
var shift = function shift2(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "shift",
    options,
    fn: function fn(state) {
      return _async_to_generator(function() {
        var x, y, placement, _evaluate, tmp, checkMainAxis, tmp1, checkCrossAxis, _evaluate_limiter, limiter, detectOverflowOptions, coords, overflow, crossAxis, mainAxis, mainAxisCoord, crossAxisCoord, minSide, maxSide, min2, max2, minSide1, maxSide1, min1, max1, _obj, limitedCoords;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              x = state.x, y = state.y, placement = state.placement;
              _evaluate = evaluate(options, state), tmp = _evaluate.mainAxis, checkMainAxis = tmp === void 0 ? true : tmp, tmp1 = _evaluate.crossAxis, checkCrossAxis = tmp1 === void 0 ? false : tmp1, _evaluate_limiter = _evaluate.limiter, limiter = _evaluate_limiter === void 0 ? {
                fn: function(_ref) {
                  var x2 = _ref.x, y2 = _ref.y;
                  return {
                    x: x2,
                    y: y2
                  };
                }
              } : _evaluate_limiter, detectOverflowOptions = _object_without_properties(_evaluate, [
                "mainAxis",
                "crossAxis",
                "limiter"
              ]);
              coords = {
                x,
                y
              };
              return [
                4,
                detectOverflow(state, detectOverflowOptions)
              ];
            case 1:
              overflow = _state.sent();
              crossAxis = getSideAxis(getSide(placement));
              mainAxis = getOppositeAxis(crossAxis);
              mainAxisCoord = coords[mainAxis];
              crossAxisCoord = coords[crossAxis];
              if (checkMainAxis) {
                minSide = mainAxis === "y" ? "top" : "left";
                maxSide = mainAxis === "y" ? "bottom" : "right";
                min2 = mainAxisCoord + overflow[minSide];
                max2 = mainAxisCoord - overflow[maxSide];
                mainAxisCoord = clamp(min2, mainAxisCoord, max2);
              }
              if (checkCrossAxis) {
                minSide1 = crossAxis === "y" ? "top" : "left";
                maxSide1 = crossAxis === "y" ? "bottom" : "right";
                min1 = crossAxisCoord + overflow[minSide1];
                max1 = crossAxisCoord - overflow[maxSide1];
                crossAxisCoord = clamp(min1, crossAxisCoord, max1);
              }
              limitedCoords = limiter.fn(_object_spread_props(_object_spread({}, state), (_obj = {}, _define_property(_obj, mainAxis, mainAxisCoord), _define_property(_obj, crossAxis, crossAxisCoord), _obj)));
              return [
                2,
                _object_spread_props(_object_spread({}, limitedCoords), {
                  data: {
                    x: limitedCoords.x - x,
                    y: limitedCoords.y - y
                  }
                })
              ];
          }
        });
      })();
    }
  };
};
var size = function size2(options) {
  if (options === void 0) {
    options = {};
  }
  return {
    name: "size",
    options,
    fn: function fn(state) {
      return _async_to_generator(function() {
        var placement, rects, platform3, elements, _evaluate, _evaluate_apply, apply, detectOverflowOptions, overflow, side, alignment, isYAxis, _rects_floating, width, height, heightSide, widthSide, overflowAvailableHeight, overflowAvailableWidth, noShift, availableHeight, availableWidth, maximumClippingWidth, maximumClippingHeight, xMin, xMax, yMin, yMax, nextDimensions;
        return __generator(this, function(_state) {
          switch (_state.label) {
            case 0:
              placement = state.placement, rects = state.rects, platform3 = state.platform, elements = state.elements;
              _evaluate = evaluate(options, state), _evaluate_apply = _evaluate.apply, apply = _evaluate_apply === void 0 ? function() {
              } : _evaluate_apply, detectOverflowOptions = _object_without_properties(_evaluate, [
                "apply"
              ]);
              return [
                4,
                detectOverflow(state, detectOverflowOptions)
              ];
            case 1:
              overflow = _state.sent();
              side = getSide(placement);
              alignment = getAlignment(placement);
              isYAxis = getSideAxis(placement) === "y";
              _rects_floating = rects.floating, width = _rects_floating.width, height = _rects_floating.height;
              if (!(side === "top" || side === "bottom"))
                return [
                  3,
                  3
                ];
              heightSide = side;
              return [
                4,
                platform3.isRTL == null ? void 0 : platform3.isRTL(elements.floating)
              ];
            case 2:
              widthSide = alignment === (_state.sent() ? "start" : "end") ? "left" : "right";
              return [
                3,
                4
              ];
            case 3:
              widthSide = side;
              heightSide = alignment === "end" ? "top" : "bottom";
              _state.label = 4;
            case 4:
              overflowAvailableHeight = height - overflow[heightSide];
              overflowAvailableWidth = width - overflow[widthSide];
              noShift = !state.middlewareData.shift;
              availableHeight = overflowAvailableHeight;
              availableWidth = overflowAvailableWidth;
              if (isYAxis) {
                maximumClippingWidth = width - overflow.left - overflow.right;
                availableWidth = alignment || noShift ? min(overflowAvailableWidth, maximumClippingWidth) : maximumClippingWidth;
              } else {
                maximumClippingHeight = height - overflow.top - overflow.bottom;
                availableHeight = alignment || noShift ? min(overflowAvailableHeight, maximumClippingHeight) : maximumClippingHeight;
              }
              if (noShift && !alignment) {
                xMin = max(overflow.left, 0);
                xMax = max(overflow.right, 0);
                yMin = max(overflow.top, 0);
                yMax = max(overflow.bottom, 0);
                if (isYAxis) {
                  availableWidth = width - 2 * (xMin !== 0 || xMax !== 0 ? xMin + xMax : max(overflow.left, overflow.right));
                } else {
                  availableHeight = height - 2 * (yMin !== 0 || yMax !== 0 ? yMin + yMax : max(overflow.top, overflow.bottom));
                }
              }
              return [
                4,
                apply(_object_spread_props(_object_spread({}, state), {
                  availableWidth,
                  availableHeight
                }))
              ];
            case 5:
              _state.sent();
              return [
                4,
                platform3.getDimensions(elements.floating)
              ];
            case 6:
              nextDimensions = _state.sent();
              if (width !== nextDimensions.width || height !== nextDimensions.height) {
                return [
                  2,
                  {
                    reset: {
                      rects: true
                    }
                  }
                ];
              }
              return [
                2,
                {}
              ];
          }
        });
      })();
    }
  };
};

// node_modules/@vkontakte/vkui-floating-ui/utils/dom/floating-ui.utils.dom.esm.js
function getNodeName(node) {
  if (isNode(node)) {
    return (node.nodeName || "").toLowerCase();
  }
  return "#document";
}
function getWindow(node) {
  var _node$ownerDocument;
  return (node == null || (_node$ownerDocument = node.ownerDocument) == null ? void 0 : _node$ownerDocument.defaultView) || window;
}
function getDocumentElement(node) {
  var _ref;
  return (_ref = (isNode(node) ? node.ownerDocument : node.document) || window.document) == null ? void 0 : _ref.documentElement;
}
function isNode(value) {
  return _instanceof(value, Node) || _instanceof(value, getWindow(value).Node);
}
function isElement(value) {
  return _instanceof(value, Element) || _instanceof(value, getWindow(value).Element);
}
function isHTMLElement(value) {
  return _instanceof(value, HTMLElement) || _instanceof(value, getWindow(value).HTMLElement);
}
function isShadowRoot(value) {
  if (typeof ShadowRoot === "undefined") {
    return false;
  }
  return _instanceof(value, ShadowRoot) || _instanceof(value, getWindow(value).ShadowRoot);
}
function isOverflowElement(element) {
  var _getComputedStyle = getComputedStyle2(element), overflow = _getComputedStyle.overflow, overflowX = _getComputedStyle.overflowX, overflowY = _getComputedStyle.overflowY, display = _getComputedStyle.display;
  return /auto|scroll|overlay|hidden|clip/.test(overflow + overflowY + overflowX) && ![
    "inline",
    "contents"
  ].includes(display);
}
function isTableElement(element) {
  return [
    "table",
    "td",
    "th"
  ].includes(getNodeName(element));
}
function isContainingBlock(element) {
  var webkit = isWebKit();
  var css = getComputedStyle2(element);
  return css.transform !== "none" || css.perspective !== "none" || (css.containerType ? css.containerType !== "normal" : false) || !webkit && (css.backdropFilter ? css.backdropFilter !== "none" : false) || !webkit && (css.filter ? css.filter !== "none" : false) || [
    "transform",
    "perspective",
    "filter"
  ].some(function(value) {
    return (css.willChange || "").includes(value);
  }) || [
    "paint",
    "layout",
    "strict",
    "content"
  ].some(function(value) {
    return (css.contain || "").includes(value);
  });
}
function getContainingBlock(element) {
  var currentNode = getParentNode(element);
  while (isHTMLElement(currentNode) && !isLastTraversableNode(currentNode)) {
    if (isContainingBlock(currentNode)) {
      return currentNode;
    } else {
      currentNode = getParentNode(currentNode);
    }
  }
  return null;
}
function isWebKit() {
  if (typeof CSS === "undefined" || !CSS.supports)
    return false;
  return CSS.supports("-webkit-backdrop-filter", "none");
}
function isLastTraversableNode(node) {
  return [
    "html",
    "body",
    "#document"
  ].includes(getNodeName(node));
}
function getComputedStyle2(element) {
  return getWindow(element).getComputedStyle(element);
}
function getNodeScroll(element) {
  if (isElement(element)) {
    return {
      scrollLeft: element.scrollLeft,
      scrollTop: element.scrollTop
    };
  }
  return {
    scrollLeft: element.pageXOffset,
    scrollTop: element.pageYOffset
  };
}
function getParentNode(node) {
  if (getNodeName(node) === "html") {
    return node;
  }
  var result = (
    // Step into the shadow DOM of the parent of a slotted node.
    node.assignedSlot || // DOM Element detected.
    node.parentNode || // ShadowRoot detected.
    isShadowRoot(node) && node.host || // Fallback.
    getDocumentElement(node)
  );
  return isShadowRoot(result) ? result.host : result;
}
function getNearestOverflowAncestor(node) {
  var parentNode = getParentNode(node);
  if (isLastTraversableNode(parentNode)) {
    return node.ownerDocument ? node.ownerDocument.body : node.body;
  }
  if (isHTMLElement(parentNode) && isOverflowElement(parentNode)) {
    return parentNode;
  }
  return getNearestOverflowAncestor(parentNode);
}
function getOverflowAncestors(node, list, traverseIframes) {
  var _node$ownerDocument2;
  if (list === void 0) {
    list = [];
  }
  if (traverseIframes === void 0) {
    traverseIframes = true;
  }
  var scrollableAncestor = getNearestOverflowAncestor(node);
  var isBody2 = scrollableAncestor === ((_node$ownerDocument2 = node.ownerDocument) == null ? void 0 : _node$ownerDocument2.body);
  var win = getWindow(scrollableAncestor);
  if (isBody2) {
    return list.concat(win, win.visualViewport || [], isOverflowElement(scrollableAncestor) ? scrollableAncestor : [], win.frameElement && traverseIframes ? getOverflowAncestors(win.frameElement) : []);
  }
  return list.concat(scrollableAncestor, getOverflowAncestors(scrollableAncestor, [], traverseIframes));
}

// node_modules/@vkontakte/vkui/dist/lib/dom.js
var getDOM = () => ({
  window: canUseDOM ? window : void 0,
  document: canUseDOM ? document : void 0
});
var DOMContext = React5.createContext(getDOM());
var useDOM = () => {
  return React5.useContext(DOMContext);
};
var isWindow = (node) => {
  return node !== null && node !== void 0 && "navigator" in node;
};
var isBody = (node) => {
  return node !== null && node !== void 0 && "tagName" in node && node.tagName === "BODY";
};
var isDocumentElement = (node) => {
  return node !== null && node !== void 0 && "tagName" in node && node.tagName === "HTML";
};
function withDOM(Component3) {
  const WithDOM = (props) => {
    const dom = useDOM();
    return React5.createElement(Component3, _object_spread({}, props, dom));
  };
  return WithDOM;
}
function blurActiveElement(document1) {
  if (document1 && document1.activeElement) {
    document1.activeElement.blur();
  }
}
var TRANSFORM_DEFAULT_VALUES = [
  "none",
  "initial",
  "inherit",
  "unset"
];
var WILL_CHANGE_DEFAULT_VALUES = [
  "auto",
  "initial",
  "inherit",
  "unset"
];
function getTransformedParentCoords(element) {
  let parentNode = element.parentNode;
  while (parentNode !== null) {
    if (isHTMLElement(parentNode)) {
      const { transform, willChange } = getComputedStyle(parentNode);
      if (!TRANSFORM_DEFAULT_VALUES.includes(transform) || !WILL_CHANGE_DEFAULT_VALUES.includes(willChange)) {
        const { x, y } = parentNode.getBoundingClientRect();
        return {
          x,
          y
        };
      }
    }
    parentNode = parentNode.parentNode;
  }
  return {
    x: 0,
    y: 0
  };
}
var getBoundingClientRect = (node, isFixedStrategy = false) => {
  const element = isWindow(node) ? node.document.documentElement : node;
  const clientRect = element.getBoundingClientRect();
  if (isDocumentElement(element)) {
    clientRect.height = element.clientHeight;
  }
  let offsetX = 0;
  let offsetY = 0;
  if (isFixedStrategy) {
    const { x, y } = getTransformedParentCoords(element);
    offsetX = x;
    offsetY = y;
  }
  return rectToClientRect({
    x: clientRect.left - offsetX,
    y: clientRect.top - offsetY,
    width: clientRect.width,
    height: clientRect.height
  });
};
var getNearestOverflowAncestor2 = (childEl) => {
  const foundAncestor = getNearestOverflowAncestor(childEl);
  return isBody(foundAncestor) ? getWindow(foundAncestor) : isHTMLElement(childEl) ? foundAncestor : null;
};
var getScrollHeight = (node) => {
  return isWindow(node) ? node.document.documentElement.scrollHeight : node.scrollHeight;
};
var getScrollRect = (node) => {
  const window1 = isElement(node) ? getWindow(node) : node;
  const scrollElRect = getBoundingClientRect(node);
  const edgeTop = window1.scrollY + scrollElRect.top;
  const edgeBottom = edgeTop + scrollElRect.height;
  const y = [
    edgeTop,
    edgeBottom
  ];
  return {
    relative: scrollElRect,
    edges: {
      y
    }
  };
};
var getDocumentBody = (node) => getWindow(node).document.body;
var getActiveElementByAnotherElement = (el) => el ? el.ownerDocument.activeElement : null;
var contains = (parent, child) => {
  return parent && child ? parent.contains(child) : false;
};

// node_modules/@vkontakte/vkui/dist/lib/useIsomorphicLayoutEffect.js
var React6 = __toESM(require_react());
var useIsomorphicLayoutEffect = canUseDOM ? React6.useLayoutEffect : React6.useEffect;

// node_modules/@vkontakte/vkui/dist/hooks/useKeyboardInputTracker.js
var ENABLE_KEYBOARD_INPUT_EVENT_NAME = "enableKeyboardInput";
var DISABLE_KEYBOARD_INPUT_EVENT_NAME = "disableKeyboardInput";
var EVENT_OPTIONS = {
  passive: true,
  capture: true
};
function useKeyboardInputTracker() {
  const { document: document2 } = useDOM();
  const keyboardFocusingStartedRef = React7.useRef(false);
  useIsomorphicLayoutEffect(() => {
    if (!document2) {
      return;
    }
    const handleKeydown = (event) => {
      if (isKeyboardFocusingStarted(event)) {
        keyboardFocusingStartedRef.current = true;
      }
    };
    const handleCustomEnableKeyboardEvent = () => {
      keyboardFocusingStartedRef.current = true;
    };
    const handleCustomDisableKeyboardEvent = () => {
      keyboardFocusingStartedRef.current = false;
    };
    document2.addEventListener("keydown", handleKeydown, EVENT_OPTIONS);
    document2.addEventListener(ENABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomEnableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener(DISABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener("mousedown", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    document2.addEventListener("touchstart", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    return () => {
      document2.removeEventListener("keydown", handleKeydown, EVENT_OPTIONS);
      document2.removeEventListener(ENABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomEnableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener(DISABLE_KEYBOARD_INPUT_EVENT_NAME, handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener("mousedown", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
      document2.removeEventListener("touchstart", handleCustomDisableKeyboardEvent, EVENT_OPTIONS);
    };
  }, [
    document2
  ]);
  return keyboardFocusingStartedRef;
}

// node_modules/@vkontakte/vkui/dist/hooks/useObjectMemo.js
var React8 = __toESM(require_react());
function useObjectMemo(object) {
  const cache = React8.useRef(object);
  if (!isEqual(cache.current, object)) {
    cache.current = object;
  }
  return cache.current;
}

// node_modules/@vkontakte/vkui/dist/lib/tokens/constants.js
var DEFAULT_TOKENS_CLASS_NAMES = {
  android: {
    light: "vkui--vkBase--light",
    dark: "vkui--vkBase--dark"
  },
  ios: {
    light: "vkui--vkIOS--light",
    dark: "vkui--vkIOS--dark"
  },
  vkcom: {
    light: "vkui--vkCom--light",
    dark: "vkui--vkCom--dark"
  }
};

// node_modules/@vkontakte/vkui/dist/lib/tokens/useTokenClassName.js
var React10 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderContext.js
var React9 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/browser.js
var memoized = {};
function computeBrowserInfo(userAgent = "") {
  if (memoized[userAgent]) {
    return memoized[userAgent];
  }
  const browserInfo = {
    userAgent,
    system: "",
    systemVersion: null
  };
  const { isIOS: isIOS2, iosMajor: iosMajor2, iosMinor: iosMinor2 } = detectIOS(userAgent);
  if (isIOS2) {
    browserInfo.system = "ios";
    browserInfo.systemVersion = {
      major: iosMajor2,
      minor: iosMinor2
    };
  }
  memoized[userAgent] = browserInfo;
  return browserInfo;
}
function mediaQueryNull(query) {
  return {
    matches: false,
    media: query,
    onchange: noop,
    addListener: noop,
    removeListener: noop,
    addEventListener: noop,
    removeEventListener: noop,
    dispatchEvent() {
      return false;
    }
  };
}

// node_modules/@vkontakte/vkui/dist/lib/platform.js
var Platform = {
  ANDROID: "android",
  IOS: "ios",
  VKCOM: "vkcom"
};
function platform(browserInfo) {
  if (!browserInfo) {
    browserInfo = computeBrowserInfo();
  }
  return browserInfo.system === "ios" ? "ios" : "android";
}

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderContext.js
var ConfigProviderContext = React9.createContext({
  hasCustomPanelHeaderAfter: false,
  customPanelHeaderAfterMinWidth: 90,
  isWebView: false,
  transitionMotionEnabled: true,
  platform: platform(),
  appearance: void 0,
  tokensClassNames: DEFAULT_TOKENS_CLASS_NAMES,
  locale: "ru"
});
var useConfigProvider = () => React9.useContext(ConfigProviderContext);

// node_modules/@vkontakte/vkui/dist/lib/appearance/index.js
var DEFAULT_APPEARANCE = "light";
var Appearance = {
  DARK: "dark",
  LIGHT: "light"
};

// node_modules/@vkontakte/vkui/dist/lib/tokens/useTokenClassName.js
var isTokensClassNamesForPlatforms = (tokensClassNames) => Platform.ANDROID in tokensClassNames || Platform.IOS in tokensClassNames || Platform.VKCOM in tokensClassNames;
var getTokenClassNameByAppearance = (appearance, tokensClassNames) => tokensClassNames ? tokensClassNames[appearance] : void 0;
var getAppearanceTokenClassNameByPlatform = (platform3, tokensClassNames) => tokensClassNames ? tokensClassNames[platform3] : void 0;
var useTokensClassName = () => {
  const { platform: platform3, appearance = DEFAULT_APPEARANCE, tokensClassNames } = React10.useContext(ConfigProviderContext);
  const appearanceSchemeClassName = isTokensClassNamesForPlatforms(tokensClassNames) ? getAppearanceTokenClassNameByPlatform(platform3, tokensClassNames) : tokensClassNames;
  const tokensClassName = getTokenClassNameByAppearance(appearance, appearanceSchemeClassName);
  return tokensClassName ? tokensClassName : DEFAULT_TOKENS_CLASS_NAMES[platform3][appearance];
};

// node_modules/@vkontakte/vkui/dist/lib/tokens/TokensClassProvider.js
var React11 = __toESM(require_react());
var InjectTokenClassNameToChild = ({ children }) => {
  const tokensClassName = useTokensClassName();
  return React11.cloneElement(children, {
    className: classNames(tokensClassName, children.props.className)
  });
};
var TokensClassProvider = ({ children }) => {
  return React11.Children.map(children, (child) => {
    if (React11.isValidElement(child)) {
      return React11.createElement(InjectTokenClassNameToChild, null, child);
    }
    return child;
  });
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootContext.js
var React12 = __toESM(require_react());
var DEFAULT_APP_ROOT_CONTEXT_VALUE = {
  appRoot: React12.createRef(),
  mode: "full",
  portalRoot: React12.createRef(),
  embedded: false,
  keyboardInput: false,
  disablePortal: false
};
var AppRootContext = React12.createContext(DEFAULT_APP_ROOT_CONTEXT_VALUE);

// node_modules/@vkontakte/vkui/dist/components/AppRoot/ScrollContext.js
var React13 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/math.js
var clamp2 = (value, min2, max2) => Math.max(min2, Math.min(value, max2));
function getDecimalPrecision(num) {
  if (Math.abs(num) < 1) {
    const parts = num.toExponential().split("e-");
    const matissaDecimalPart = parts[0].split(".")[1];
    return (matissaDecimalPart ? matissaDecimalPart.length : 0) + parseInt(parts[1], 10);
  }
  const decimalPart = num.toString().split(".")[1];
  return decimalPart ? decimalPart.length : 0;
}
function roundValueToStep(value, step, min2) {
  const nearest = Math.round((value - min2) / step) * step + min2;
  return Number(nearest.toFixed(getDecimalPrecision(step)));
}
function decimatedClamp(val, min2, max2, step) {
  if (step == null || step <= 0) {
    return clamp2(val, min2, max2);
  }
  const roundedValue = roundValueToStep(val, step, min2);
  return clamp2(roundedValue, min2, max2);
}
function rescale(value, from, to, options = {}) {
  const scaled = (value - from[0]) / (from[1] - from[0]) * (to[1] - to[0]) + to[0];
  return decimatedClamp(scaled, to[0], to[1], options.step);
}

// node_modules/@vkontakte/vkui/dist/components/AppRoot/ScrollContext.js
var clearDisableScrollStyle = (node) => {
  Object.assign(node.style, {
    position: "",
    top: "",
    left: "",
    right: "",
    overflowY: "",
    overflowX: ""
  });
};
var getPageYOffsetWithoutKeyboardHeight = (window2) => {
  const diffOfClientHeightAndViewportHeight = window2.document.documentElement.clientHeight - window2.innerHeight;
  return window2.pageYOffset - diffOfClientHeightAndViewportHeight;
};
var ScrollContext = React13.createContext({
  getScroll: () => ({
    x: 0,
    y: 0
  }),
  scrollTo: noop,
  isScrollLock: false,
  enableScrollLock: noop,
  disableScrollLock: noop
});
var useScroll = () => React13.useContext(ScrollContext);
var GlobalScrollController = ({ children }) => {
  const { window: window2, document: document2 } = useDOM();
  const [isScrollLock, setScrollLock] = React13.useState(false);
  const beforeScrollLockFnSetRef = React13.useRef(/* @__PURE__ */ new Set());
  const getScroll = React13.useCallback(() => ({
    x: window2.pageXOffset,
    y: getPageYOffsetWithoutKeyboardHeight(window2)
  }), [
    window2
  ]);
  const scrollTo = React13.useCallback((x = 0, y = 0) => {
    window2.scrollTo(x ? clamp2(x, 0, document2.body.scrollWidth - window2.innerWidth) : 0, y ? clamp2(y, 0, document2.body.scrollHeight - window2.innerHeight) : 0);
  }, [
    document2,
    window2
  ]);
  const enableScrollLock = React13.useCallback(() => {
    beforeScrollLockFnSetRef.current.forEach((fn) => {
      fn();
    });
    const scrollY = window2.pageYOffset;
    const scrollX = window2.pageXOffset;
    const overflowY = window2.innerWidth > document2.documentElement.clientWidth ? "scroll" : "";
    const overflowX = window2.innerHeight > document2.documentElement.clientHeight ? "scroll" : "";
    Object.assign(document2.body.style, {
      position: "fixed",
      top: `-${scrollY}px`,
      left: `-${scrollX}px`,
      right: "0",
      overflowY,
      overflowX
    });
    setScrollLock(true);
  }, [
    document2,
    window2
  ]);
  const disableScrollLock = React13.useCallback(() => {
    const scrollY = document2.body.style.top;
    const scrollX = document2.body.style.left;
    clearDisableScrollStyle(document2.body);
    window2.scrollTo(-parseInt(scrollX || "0"), -parseInt(scrollY || "0"));
    setScrollLock(false);
  }, [
    document2,
    window2
  ]);
  const scrollController = React13.useMemo(() => ({
    getScroll,
    scrollTo,
    isScrollLock,
    disableScrollLock,
    enableScrollLock,
    beforeScrollLockFnSetRef
  }), [
    getScroll,
    scrollTo,
    isScrollLock,
    disableScrollLock,
    enableScrollLock
  ]);
  return React13.createElement(ScrollContext.Provider, {
    value: scrollController
  }, children);
};
var ElementScrollController = ({ elRef, children }) => {
  const [isScrollLock, setScrollLock] = React13.useState(false);
  const beforeScrollLockFnSetRef = React13.useRef(/* @__PURE__ */ new Set());
  const getScroll = React13.useCallback(() => {
    var _elRef_current, _elRef_current1;
    var _elRef_current_scrollLeft, _elRef_current_scrollTop;
    return {
      x: (_elRef_current_scrollLeft = (_elRef_current = elRef.current) === null || _elRef_current === void 0 ? void 0 : _elRef_current.scrollLeft) !== null && _elRef_current_scrollLeft !== void 0 ? _elRef_current_scrollLeft : 0,
      y: (_elRef_current_scrollTop = (_elRef_current1 = elRef.current) === null || _elRef_current1 === void 0 ? void 0 : _elRef_current1.scrollTop) !== null && _elRef_current_scrollTop !== void 0 ? _elRef_current_scrollTop : 0
    };
  }, [
    elRef
  ]);
  const scrollTo = React13.useCallback((x = 0, y = 0) => {
    const el = elRef.current;
    el === null || el === void 0 ? void 0 : el.scrollTo(x ? clamp2(x, 0, el.scrollWidth - el.clientWidth) : 0, y ? clamp2(y, 0, el.scrollHeight - el.clientHeight) : 0);
  }, [
    elRef
  ]);
  const enableScrollLock = React13.useCallback(() => {
    const el = elRef.current;
    if (!el) {
      return;
    }
    beforeScrollLockFnSetRef.current.forEach((fn) => {
      fn();
    });
    const scrollY = el.scrollTop;
    const scrollX = el.scrollLeft;
    const overflowY = el.scrollWidth > el.clientWidth ? "scroll" : "";
    const overflowX = el.scrollHeight > el.clientHeight ? "scroll" : "";
    Object.assign(el.style, {
      position: "absolute",
      top: `-${scrollY}px`,
      left: `-${scrollX}px`,
      right: "0",
      overflowY,
      overflowX
    });
    setScrollLock(true);
  }, [
    elRef
  ]);
  const disableScrollLock = React13.useCallback(() => {
    const el = elRef.current;
    if (!el) {
      return;
    }
    const scrollY = el.style.top;
    const scrollX = el.style.left;
    clearDisableScrollStyle(el);
    el.scrollTo(-parseInt(scrollX || "0"), -parseInt(scrollY || "0"));
    setScrollLock(false);
  }, [
    elRef
  ]);
  const scrollController = React13.useMemo(() => ({
    getScroll,
    scrollTo,
    isScrollLock,
    disableScrollLock,
    enableScrollLock,
    beforeScrollLockFnSetRef
  }), [
    getScroll,
    scrollTo,
    isScrollLock,
    disableScrollLock,
    enableScrollLock
  ]);
  return React13.createElement(ScrollContext.Provider, {
    value: scrollController
  }, children);
};
var useScrollLock = (enabled = true) => {
  const { enableScrollLock, disableScrollLock, isScrollLock } = useScroll();
  useIsomorphicLayoutEffect(() => {
    if (enabled && !isScrollLock) {
      enableScrollLock();
      return disableScrollLock;
    }
    return noop;
  }, [
    enableScrollLock,
    disableScrollLock,
    enabled
  ]);
};

// node_modules/@vkontakte/vkui/dist/lib/isRefObject.js
var React14 = __toESM(require_react());
var isRefObject = (refObject) => {
  return typeof refObject === "object" && refObject !== null && refObject.hasOwnProperty("current");
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/helpers.js
function getClassNamesByMode({ mode, layout, tokensClassName, sizeX, sizeY }) {
  const baseClassNames = [
    "vkui__root"
  ];
  const stylesClassNames = [
    tokensClassName
  ];
  if (mode === "full" || mode === "embedded") {
    if (layout) {
      const vkuiLayoutClassNames = {
        card: "vkui--layout-card",
        plain: "vkui--layout-plain"
      };
      stylesClassNames.push(vkuiLayoutClassNames[layout]);
    }
    if (sizeX !== "compact") {
      const vkuiSizeXClassNames = {
        none: "vkui--sizeX-none",
        regular: "vkui--sizeX-regular"
      };
      stylesClassNames.push(vkuiSizeXClassNames[sizeX]);
    }
    if (sizeY !== "regular") {
      const vkuiSizeYClassNames = {
        none: "vkui--sizeY-none",
        compact: "vkui--sizeY-compact"
      };
      stylesClassNames.push(vkuiSizeYClassNames[sizeY]);
    }
    if (mode === "embedded") {
      baseClassNames.push("vkui__root--embedded");
    }
  }
  return [
    baseClassNames,
    stylesClassNames
  ];
}
var getParentElement = (el) => el ? el.parentElement : null;
var extractPortalRootByProp = (portalRootProp) => isRefObject(portalRootProp) ? portalRootProp.current : portalRootProp;
var CUSTOM_PROPERTY_INSET_PREFIX = `--vkui_internal--safe_area_inset_`;
var setSafeAreaInsets = (safeAreaInsets, rootContainer, portalContainer) => {
  if (!safeAreaInsets) {
    return () => void 0;
  }
  for (const key in safeAreaInsets) {
    if (safeAreaInsets.hasOwnProperty(key) && typeof safeAreaInsets[key] === "number") {
      const propertyKey = `${CUSTOM_PROPERTY_INSET_PREFIX}${key}`;
      const propertyValue = safeAreaInsets[key];
      rootContainer.style.setProperty(propertyKey, `${propertyValue}px`);
      if (portalContainer) {
        portalContainer.style.setProperty(propertyKey, `${propertyValue}px`);
      }
    }
  }
  return function unset() {
    for (const key in safeAreaInsets) {
      if (safeAreaInsets.hasOwnProperty(key)) {
        const propertyKey = `${CUSTOM_PROPERTY_INSET_PREFIX}${key}`;
        rootContainer.style.removeProperty(propertyKey);
        if (portalContainer) {
          portalContainer.style.removeProperty(propertyKey);
        }
      }
    }
  };
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRoot.js
var AppRoot = (_param) => {
  var { children, mode = "full", scroll = "global", portalRoot: portalRootProp = null, disablePortal = false, disableParentTransformForPositionFixedElements, className, safeAreaInsets: safeAreaInsetsProp, layout } = _param, props = _object_without_properties(_param, [
    "children",
    "mode",
    "scroll",
    "portalRoot",
    "disablePortal",
    "disableParentTransformForPositionFixedElements",
    "className",
    "safeAreaInsets",
    "layout"
  ]);
  const { hasPointer, sizeX = "none", sizeY = "none" } = useAdaptivity();
  const tokensClassName = useTokensClassName();
  const safeAreaInsets = useObjectMemo(safeAreaInsetsProp);
  const isKeyboardInputActiveRef = useKeyboardInputTracker();
  const appRootRef = React15.useRef(null);
  const portalRootRef = React15.useRef(null);
  useIsomorphicLayoutEffect(function setupPortalRoot() {
    const portalByProp = portalRootProp ? extractPortalRootByProp(portalRootProp) : null;
    if (portalByProp) {
      portalRootRef.current = portalByProp;
      return function cleanup() {
        portalRootRef.current = null;
      };
    }
    const documentBody = getDocumentBody(appRootRef.current);
    const portal = documentBody.ownerDocument.createElement("div");
    documentBody.appendChild(portal);
    portalRootRef.current = portal;
    return function cleanup() {
      documentBody.removeChild(portal);
      portalRootRef.current = null;
    };
  }, [
    portalRootProp
  ]);
  useIsomorphicLayoutEffect(function setupContainers() {
    if (!appRootRef.current || !portalRootRef.current) {
      return;
    }
    const parentElement = getParentElement(appRootRef.current);
    const documentBody = getDocumentBody(appRootRef.current);
    const documentElement = documentBody.ownerDocument.documentElement;
    const [baseClassNames, stylesClassNames] = getClassNamesByMode({
      mode,
      layout,
      tokensClassName,
      sizeX,
      sizeY
    });
    switch (mode) {
      case "full": {
        if (parentElement) {
          parentElement.classList.add(...baseClassNames);
        }
        documentElement.classList.add(...stylesClassNames, "vkui");
        const unsetSafeAreaInsets = setSafeAreaInsets(safeAreaInsets, documentElement);
        return function cleanup() {
          if (parentElement) {
            parentElement.classList.remove(...baseClassNames);
          }
          documentElement.classList.remove(...stylesClassNames, "vkui");
          unsetSafeAreaInsets();
        };
      }
      case "embedded": {
        if (parentElement) {
          parentElement.classList.add(...baseClassNames, ...stylesClassNames);
          if (!disableParentTransformForPositionFixedElements) {
            parentElement.style.setProperty("transform", "translate3d(0, 0, 0)");
          }
          const unsetSafeAreaInsets = setSafeAreaInsets(safeAreaInsets, parentElement, portalRootRef.current);
          return function cleanup() {
            parentElement.classList.remove(...baseClassNames, ...stylesClassNames);
            if (!disableParentTransformForPositionFixedElements) {
              parentElement.style.removeProperty("transform");
            }
            unsetSafeAreaInsets();
          };
        }
        return;
      }
      case "partial": {
        return;
      }
    }
  }, [
    mode,
    layout,
    disableParentTransformForPositionFixedElements,
    tokensClassName,
    sizeX,
    sizeY,
    safeAreaInsets
  ]);
  const ScrollController = React15.useMemo(() => scroll === "contain" ? ElementScrollController : GlobalScrollController, [
    scroll
  ]);
  const content = React15.createElement(AppRootContext.Provider, {
    value: {
      appRoot: appRootRef,
      portalRoot: portalRootRef,
      embedded: mode === "embedded",
      mode,
      disablePortal,
      layout,
      get keyboardInput() {
        return isKeyboardInputActiveRef.current;
      }
    }
  }, React15.createElement(ScrollController, {
    elRef: appRootRef
  }, children));
  return mode === "partial" ? content : React15.createElement("div", _object_spread({
    ref: appRootRef,
    className: classNames("vkuiAppRoot", hasPointer === void 0 ? "vkuiAppRoot--pointer-none" : !hasPointer && "vkuiAppRoot--pointer-has-not", className)
  }, props), content);
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Title/Title.js
var React18 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Typography/Typography.js
var React17 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/RootComponent/RootComponent.js
var React16 = __toESM(require_react());
var RootComponent = (_param) => {
  var { Component: Component3 = "div", baseClassName, className, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "baseClassName",
    "className",
    "getRootRef"
  ]);
  return React16.createElement(Component3, _object_spread({
    ref: getRootRef,
    className: classNames(baseClassName, className)
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Typography.js
var stylesWeight = {
  "1": "vkuiTypography--weight-1",
  "2": "vkuiTypography--weight-2",
  "3": "vkuiTypography--weight-3"
};
var Typography = (_param) => {
  var { weight, Component: Component3 = "span", normalize } = _param, restProps = _object_without_properties(_param, [
    "weight",
    "Component",
    "normalize"
  ]);
  return React17.createElement(RootComponent, _object_spread({
    Component: Component3,
    baseClassName: classNames("vkuiTypography", normalize && "vkuiTypography--normalize", weight && stylesWeight[weight])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Title/Title.js
var stylesLevel = {
  "1": "vkuiTitle--level-1",
  "2": "vkuiTitle--level-2",
  "3": "vkuiTitle--level-3"
};
var Title = (_param) => {
  var { className, level = "1", Component: Component3 = "span", normalize = true } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "Component",
    "normalize"
  ]);
  return React18.createElement(Typography, _object_spread({
    Component: Component3,
    normalize,
    className: classNames(className, stylesLevel[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Headline/Headline.js
var React19 = __toESM(require_react());
var stylesLevel2 = {
  "1": "vkuiHeadline--level-1",
  "2": "vkuiHeadline--level-2"
};
var sizeYClassNames = {
  none: "vkuiHeadline--sizeY-none",
  ["compact"]: "vkuiHeadline--sizeY-compact"
};
var Headline = (_param) => {
  var { className, weight = "3", level = "1", Component: Component3 = "span", normalize = true } = _param, restProps = _object_without_properties(_param, [
    "className",
    "weight",
    "level",
    "Component",
    "normalize"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return React19.createElement(Typography, _object_spread({
    Component: Component3,
    normalize,
    weight,
    className: classNames(className, sizeY !== "regular" && sizeYClassNames[sizeY], stylesLevel2[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Text/Text.js
var React20 = __toESM(require_react());
var sizeYClassNames2 = {
  none: "vkuiText--sizeY-none",
  ["compact"]: "vkuiText--sizeY-compact"
};
var Text = (_param) => {
  var { className, Component: Component3 = "span", normalize = true } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return React20.createElement(Typography, _object_spread({
    Component: Component3,
    normalize,
    className: classNames(className, "vkuiText", sizeY !== "regular" && sizeYClassNames2[sizeY])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Paragraph/Paragraph.js
var React21 = __toESM(require_react());
var Paragraph = (_param) => {
  var { className, Component: Component3 = "span", normalize = false } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize"
  ]);
  return React21.createElement(Typography, _object_spread({
    Component: Component3,
    normalize,
    className: classNames(className, "vkuiParagraph")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Subhead/Subhead.js
var React22 = __toESM(require_react());
var sizeYClassNames3 = {
  none: "vkuiSubhead--sizeY-none",
  ["compact"]: "vkuiSubhead--sizeY-compact"
};
var Subhead = (_param) => {
  var { className, Component: Component3 = "span", normalize = true } = _param, restProps = _object_without_properties(_param, [
    "className",
    "Component",
    "normalize"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return React22.createElement(Typography, _object_spread({
    Component: Component3,
    normalize,
    className: classNames(className, "vkuiSubhead", sizeY !== "regular" && sizeYClassNames3[sizeY])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Footnote/Footnote.js
var React23 = __toESM(require_react());
var Footnote = (_param) => {
  var { className, caps, Component: Component3 = "span", normalize = true } = _param, restProps = _object_without_properties(_param, [
    "className",
    "caps",
    "Component",
    "normalize"
  ]);
  return React23.createElement(Typography, _object_spread({
    Component: Component3,
    normalize,
    className: classNames(className, "vkuiFootnote", caps && "vkuiFootnote--caps")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Typography/Caption/Caption.js
var React24 = __toESM(require_react());
var stylesLevel3 = {
  "1": "vkuiCaption--level-1",
  "2": "vkuiCaption--level-2",
  "3": "vkuiCaption--level-3"
};
var Caption = (_param) => {
  var { className, level = "1", caps, Component: Component3 = "span", normalize = true } = _param, restProps = _object_without_properties(_param, [
    "className",
    "level",
    "caps",
    "Component",
    "normalize"
  ]);
  return React24.createElement(Typography, _object_spread({
    Component: Component3,
    normalize,
    className: classNames(className, caps && "vkuiCaption--caps", stylesLevel3[level])
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/Tappable.js
var React31 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/adaptivity/constants.js
var import_breakpoints = __toESM(require_breakpoints());
var ViewWidth = {
  SMALL_MOBILE: 1,
  MOBILE: 2,
  SMALL_TABLET: 3,
  TABLET: 4,
  DESKTOP: 5
};
var ViewHeight = {
  EXTRA_SMALL: 1,
  SMALL: 2,
  MEDIUM: 3
};
var SizeType = {
  COMPACT: "compact",
  REGULAR: "regular"
};
var VIEW_WIDTH_TO_CSS_BREAKPOINT_MAP = {
  [ViewWidth.SMALL_MOBILE]: "smallMobileMinus",
  [ViewWidth.MOBILE]: "mobile",
  [ViewWidth.SMALL_TABLET]: "smallTablet",
  [ViewWidth.TABLET]: "tablet",
  [ViewWidth.DESKTOP]: "desktopPlus"
};

// node_modules/@vkontakte/vkui/dist/lib/adaptivity/functions.js
function getViewWidthByViewportWidth(viewportWidth) {
  if (viewportWidth >= import_breakpoints.BREAKPOINTS.DESKTOP) {
    return ViewWidth.DESKTOP;
  }
  if (viewportWidth >= import_breakpoints.BREAKPOINTS.TABLET) {
    return ViewWidth.TABLET;
  }
  if (viewportWidth >= import_breakpoints.BREAKPOINTS.SMALL_TABLET) {
    return ViewWidth.SMALL_TABLET;
  }
  if (viewportWidth >= import_breakpoints.BREAKPOINTS.MOBILE) {
    return ViewWidth.MOBILE;
  }
  return ViewWidth.SMALL_MOBILE;
}
function getViewWidthByMediaQueries(mediaQueries) {
  if (mediaQueries.desktopPlus.matches) {
    return ViewWidth.DESKTOP;
  }
  if (mediaQueries.tablet.matches) {
    return ViewWidth.TABLET;
  }
  if (mediaQueries.smallTablet.matches) {
    return ViewWidth.SMALL_TABLET;
  }
  if (mediaQueries.mobile.matches) {
    return ViewWidth.MOBILE;
  }
  return ViewWidth.SMALL_MOBILE;
}
function getViewHeightByViewportHeight(viewportHeight) {
  if (viewportHeight >= import_breakpoints.BREAKPOINTS.MEDIUM_HEIGHT) {
    return ViewHeight.MEDIUM;
  }
  if (viewportHeight >= import_breakpoints.BREAKPOINTS.MOBILE_LANDSCAPE_HEIGHT) {
    return ViewHeight.SMALL;
  }
  return ViewHeight.EXTRA_SMALL;
}
function getViewHeightByMediaQueries(mediaQueries) {
  if (mediaQueries.mediumHeight.matches) {
    return ViewHeight.MEDIUM;
  }
  if (mediaQueries.mobileLandscapeHeight.matches) {
    return ViewHeight.SMALL;
  }
  return ViewHeight.EXTRA_SMALL;
}
function getSizeX(viewWidth) {
  return viewWidth <= ViewWidth.MOBILE ? "compact" : "regular";
}
function isCompactByViewWidth(viewWidth, hasPointer) {
  return viewWidth !== void 0 && viewWidth >= ViewWidth.SMALL_TABLET && hasPointer;
}
function isCompactByViewHeight(viewHeight) {
  return viewHeight !== void 0 && viewHeight <= ViewHeight.EXTRA_SMALL;
}
function getSizeY(viewWidth, viewHeight, hasPointer) {
  if (isCompactByViewWidth(viewWidth, hasPointer) || isCompactByViewHeight(viewHeight)) {
    return "compact";
  }
  return "regular";
}
function tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3) {
  const IS_VKCOM_CRUTCH = platform3 === "vkcom";
  if ((viewWidth === void 0 || hasPointer === void 0) && (viewWidth === void 0 || viewHeight === void 0) || hasPointer === void 0 && viewHeight === void 0) {
    return IS_VKCOM_CRUTCH ? true : null;
  }
  const widthIsLikeDesktop = viewWidth >= ViewWidth.SMALL_TABLET;
  const otherParametersIsLikeDesktop = hasPointer || (viewHeight !== void 0 ? viewHeight >= ViewHeight.MEDIUM : false);
  return widthIsLikeDesktop && otherParametersIsLikeDesktop || IS_VKCOM_CRUTCH;
}
function viewWidthToClassName(breakpointClassNames2, viewWidth = "none") {
  if (viewWidth === "none") {
    return breakpointClassNames2.hasOwnProperty("none") ? breakpointClassNames2["none"] : null;
  }
  const breakpoints = [];
  const breakpointName = VIEW_WIDTH_TO_CSS_BREAKPOINT_MAP[viewWidth];
  if (breakpointClassNames2.hasOwnProperty(breakpointName)) {
    breakpoints.push(breakpointClassNames2[breakpointName]);
  }
  if (viewWidth >= ViewWidth.MOBILE) {
    if (breakpointClassNames2.hasOwnProperty("mobilePlus")) {
      breakpoints.push(breakpointClassNames2["mobilePlus"]);
    }
  }
  if (viewWidth >= ViewWidth.SMALL_TABLET) {
    if (breakpointClassNames2.hasOwnProperty("smallTabletPlus")) {
      breakpoints.push(breakpointClassNames2["smallTabletPlus"]);
    }
  } else {
    if (breakpointClassNames2.hasOwnProperty("smallTabletMinus")) {
      breakpoints.push(breakpointClassNames2["smallTabletMinus"]);
    }
  }
  if (viewWidth >= ViewWidth.TABLET) {
    if (breakpointClassNames2.hasOwnProperty("tabletPlus")) {
      breakpoints.push(breakpointClassNames2["tabletPlus"]);
    }
  } else {
    if (breakpointClassNames2.hasOwnProperty("tabletMinus")) {
      breakpoints.push(breakpointClassNames2["tabletMinus"]);
    }
  }
  return breakpoints.length > 0 ? breakpoints.join(" ") : null;
}

// node_modules/@vkontakte/vkui/dist/lib/callMultiple.js
var callMultiple = (...fns) => (...args) => fns.filter((f) => typeof f === "function").forEach((f) => f(...args));

// node_modules/@vkontakte/vkui/dist/lib/mergeCalls.js
function mergeCalls(...props) {
  const objectToArrays = props.reduce((record, obj) => {
    Object.entries(obj).forEach(([key, value]) => {
      if (!record.hasOwnProperty(key)) {
        record[key] = [];
      }
      record[key].push(value);
    });
    return record;
  }, {});
  return Object.entries(objectToArrays).reduce((record, [key, array]) => {
    record[key] = callMultiple(...array);
    return record;
  }, {});
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/Clickable.js
var React28 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useFocusVisible.js
var import_react2 = __toESM(require_react());
function useFocusVisible(withKeyboardInputCheck = true) {
  const [isFocused, setIsFocused] = (0, import_react2.useState)(false);
  const { keyboardInput } = (0, import_react2.useContext)(AppRootContext);
  const onFocus = (0, import_react2.useCallback)((event) => {
    event.stopPropagation();
    setIsFocused(true);
  }, [
    setIsFocused
  ]);
  const onBlur = (0, import_react2.useCallback)((event) => {
    event.stopPropagation();
    setIsFocused(false);
  }, [
    setIsFocused
  ]);
  const focusVisible = withKeyboardInputCheck ? keyboardInput && isFocused : isFocused;
  return {
    focusVisible,
    onFocus,
    onBlur
  };
}

// node_modules/@vkontakte/vkui/dist/hooks/useFocusVisibleClassName.js
var focusVisiblePresetModeClassNames = {
  inside: "vkui-focus-visible--mode-inside",
  outside: "vkui-focus-visible--mode-outside"
};
var isPresetMode = (mode) => mode === "inside" || mode === "outside";
function useFocusVisibleClassName({ focusVisible = false, mode = "inside" }) {
  const modeClassName = isPresetMode(mode) ? focusVisiblePresetModeClassNames[mode] : mode;
  const focusVisibleClassNames = classNames("vkui-focus-visible", focusVisible && "vkui-focus-visible--focused", focusVisible && modeClassName);
  return focusVisibleClassNames;
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/useKeyboard.js
var React25 = __toESM(require_react());
function useKeyboard() {
  function onKeyDown(e) {
    var _e_target_click, _e_target;
    if (!shouldTriggerClickOnEnterOrSpace(e)) {
      return;
    }
    e.preventDefault();
    (_e_target_click = (_e_target = e.target).click) === null || _e_target_click === void 0 ? void 0 : _e_target_click.call(_e_target);
  }
  return {
    onKeyDown
  };
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/useState.js
var React27 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Clickable/useStateWithDelay.js
var React26 = __toESM(require_react());
function useStateWithDelay(initialState, defaultDelay = 0) {
  const [value, setValue] = React26.useState(initialState);
  const timeout = React26.useRef();
  const setValueWithDelay = React26.useCallback((newValue, delay = defaultDelay) => {
    clearTimeout(timeout.current);
    if (delay === 0) {
      setValue(newValue);
      return;
    }
    timeout.current = setTimeout(() => setValue(newValue), delay);
  }, [
    defaultDelay
  ]);
  return [
    value,
    setValueWithDelay
  ];
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/useState.js
var DEFAULT_ACTIVE_EFFECT_DELAY = 600;
var ACTIVE_DELAY = 70;
function useHover({ hovered, hoverClassName, hasHover: hasHover2 = true }) {
  const [hoveredState, setHover] = React27.useState(false);
  const hover = hasHover2 && (hovered || hoveredState) ? hoverClassName : void 0;
  const onPointerEnter = (e) => {
    if (e.pointerType === "touch") {
      return;
    }
    setHover(true);
  };
  const onPointerLeave = () => {
    setHover(false);
  };
  return {
    hover,
    onPointerEnter: hasHover2 ? onPointerEnter : noop,
    onPointerLeave: hasHover2 ? onPointerLeave : noop
  };
}
function useActive({ activated, activeClassName, activeEffectDelay, hasActive = true }) {
  const [activatedState, setActivated] = useStateWithDelay(false);
  const pointersUp = React27.useMemo(() => /* @__PURE__ */ new Set(), []);
  const active = hasActive && (activated || activatedState) ? activeClassName : void 0;
  const onPointerDown = () => setActivated(true, ACTIVE_DELAY);
  const onPointerCancel = (e) => {
    if (pointersUp.has(e.pointerId)) {
      pointersUp.delete(e.pointerId);
      return;
    }
    setActivated(false);
  };
  const onPointerUp = (e) => {
    pointersUp.add(e.pointerId);
    setActivated(true);
    setActivated(false, activeEffectDelay);
  };
  return {
    active,
    onPointerLeave: hasActive ? onPointerCancel : noop,
    onPointerDown: hasActive ? onPointerDown : noop,
    onPointerCancel: hasActive ? onPointerCancel : noop,
    onPointerUp: hasActive ? onPointerUp : noop
  };
}
var ClickableLockStateContext = React27.createContext(void 0);
function useLockState() {
  const setLockBubbling = React27.useContext(ClickableLockStateContext) || noop;
  const [lockState, setLockState] = React27.useState(false);
  const setLockBubblingImmediate = callMultiple(setLockState, setLockBubbling);
  return [
    lockState,
    setLockBubbling,
    setLockBubblingImmediate
  ];
}
function useState5(_param) {
  var { hasHover: hasHover2, hasActive } = _param, restProps = _object_without_properties(_param, [
    "hasHover",
    "hasActive"
  ]);
  const [lockState, setLockBubbling, setLockBubblingImmediate] = useLockState();
  const props = _object_spread({
    hasHover: hasHover2 && !lockState,
    hasActive: hasActive && !lockState
  }, restProps);
  const _useHover = useHover(_object_spread({}, props)), { hover } = _useHover, hoverEvent = _object_without_properties(_useHover, [
    "hover"
  ]);
  const _useActive = useActive(props), { active } = _useActive, activeEvent = _object_without_properties(_useActive, [
    "active"
  ]);
  const stateClassName = classNames(hover, active);
  const handlers = mergeCalls(hoverEvent, activeEvent);
  React27.useEffect(() => {
    setLockBubbling(!!stateClassName);
  }, [
    setLockBubbling,
    stateClassName
  ]);
  return _object_spread({
    stateClassName,
    setLockBubblingImmediate
  }, handlers);
}

// node_modules/@vkontakte/vkui/dist/components/Clickable/Clickable.js
var NonClickable = (_param) => {
  var { href, onClick, onClickCapture, activeClassName, hoverClassName, hasActive, hasHover: hasHover2, hovered, activated, activeEffectDelay } = _param, restProps = _object_without_properties(_param, [
    "href",
    "onClick",
    "onClickCapture",
    "activeClassName",
    "hoverClassName",
    "hasActive",
    "hasHover",
    "hovered",
    "activated",
    "activeEffectDelay"
  ]);
  return React28.createElement(RootComponent, restProps);
};
var RealClickable = (_param) => {
  var { baseClassName, children, focusVisibleMode = "inside", activeClassName, hoverClassName, activeEffectDelay = DEFAULT_ACTIVE_EFFECT_DELAY, hasHover: hasHover2 = true, hasActive = true, hovered, activated, onPointerEnter, onPointerLeave, onPointerDown, onPointerCancel, onPointerUp, onBlur, onFocus, onKeyDown } = _param, restProps = _object_without_properties(_param, [
    "baseClassName",
    "children",
    "focusVisibleMode",
    "activeClassName",
    "hoverClassName",
    "activeEffectDelay",
    "hasHover",
    "hasActive",
    "hovered",
    "activated",
    "onPointerEnter",
    "onPointerLeave",
    "onPointerDown",
    "onPointerCancel",
    "onPointerUp",
    "onBlur",
    "onFocus",
    "onKeyDown"
  ]);
  const _useFocusVisible = useFocusVisible(), { focusVisible } = _useFocusVisible, focusEvents = _object_without_properties(_useFocusVisible, [
    "focusVisible"
  ]);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: focusVisibleMode
  });
  const _useState = useState5({
    activeClassName,
    hoverClassName,
    activeEffectDelay,
    hasHover: hasHover2,
    hasActive,
    hovered,
    activated
  }), { stateClassName, setLockBubblingImmediate } = _useState, stateEvents = _object_without_properties(_useState, [
    "stateClassName",
    "setLockBubblingImmediate"
  ]);
  const keyboardHandlers = useKeyboard();
  const handlers = mergeCalls(focusEvents, stateEvents, keyboardHandlers, {
    onPointerEnter,
    onPointerLeave,
    onPointerDown,
    onPointerCancel,
    onPointerUp,
    onBlur,
    onFocus,
    onKeyDown
  });
  return React28.createElement(RootComponent, _object_spread({
    baseClassName: classNames(baseClassName, "vkuiClickable__realClickable", focusVisibleClassNames, stateClassName)
  }, handlers, restProps), React28.createElement(ClickableLockStateContext.Provider, {
    value: setLockBubblingImmediate
  }, children));
};
function checkClickable(props) {
  return (props.href !== void 0 || props.onClick !== void 0 || props.onClickCapture !== void 0 || props.Component === "label") && !props.disabled;
}
function component({ Component: Component3, onClick, onClickCapture, href, disabled }) {
  if (Component3 !== void 0) {
    return {
      Component: Component3
    };
  } else if (href !== void 0) {
    return {
      "Component": "a",
      "aria-disabled": disabled
    };
  } else if (onClick !== void 0 || onClickCapture !== void 0) {
    return {
      "Component": "div",
      "role": "button",
      "tabIndex": disabled ? void 0 : 0,
      "aria-disabled": disabled
    };
  }
  return {};
}
var Clickable = (_param) => {
  var { focusVisibleMode = "inside", baseClassName: baseClassNameProp } = _param, restProps = _object_without_properties(_param, [
    "focusVisibleMode",
    "baseClassName"
  ]);
  const commonProps = component(restProps);
  const isClickable = checkClickable(restProps);
  const baseClassName = classNames(baseClassNameProp, "vkuiClickable__host");
  if (isClickable) {
    return React28.createElement(RealClickable, _object_spread({
      baseClassName,
      focusVisibleMode
    }, commonProps, restProps));
  }
  return React28.createElement(NonClickable, _object_spread({
    baseClassName
  }, commonProps, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/Ripple.js
var React30 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/usePlatform.js
function usePlatform() {
  const { platform: platform3 } = useConfigProvider();
  return platform3;
}

// node_modules/@vkontakte/vkui/dist/hooks/useTimeout.js
var React29 = __toESM(require_react());
function useTimeout(cb, duration) {
  const options = React29.useRef({
    cb,
    duration
  });
  useIsomorphicLayoutEffect(() => {
    options.current.cb = cb;
    options.current.duration = duration;
  }, [
    cb,
    duration
  ]);
  const timeout = React29.useRef();
  const clear = React29.useCallback(() => {
    if (canUseDOM && (timeout === null || timeout === void 0 ? void 0 : timeout.current)) {
      clearTimeout(timeout.current);
    }
  }, []);
  const set = React29.useCallback((duration2 = options.current.duration) => {
    clear();
    if (canUseDOM) {
      timeout.current = setTimeout(() => {
        const { cb: cb2 } = options.current;
        typeof cb2 === "function" && cb2();
      }, duration2);
    }
  }, [
    clear
  ]);
  useIsomorphicLayoutEffect(() => clear, []);
  return {
    set,
    clear
  };
}

// node_modules/@vkontakte/vkui/dist/lib/offset.js
function getOffsetRect2(elem) {
  const box = elem === null || elem === void 0 ? void 0 : elem.getBoundingClientRect();
  return {
    top: box === null || box === void 0 ? void 0 : box.top,
    left: box === null || box === void 0 ? void 0 : box.left,
    width: elem === null || elem === void 0 ? void 0 : elem.offsetWidth,
    height: elem === null || elem === void 0 ? void 0 : elem.offsetHeight
  };
}

// node_modules/@vkontakte/vkui/dist/components/Tappable/Ripple.js
var useMaybeNeedRipple = (activeMode, hasPointer) => {
  const platform3 = usePlatform();
  return platform3 === "android" && !hasPointer && activeMode === "background";
};
var DELAY = 70;
var WAVE_LIVE = 225;
var useRipple = (needRipple, hasPointerContext) => {
  const [clicks, setClicks] = React30.useState([]);
  const pointerDelayTimers = React30.useMemo(() => /* @__PURE__ */ new Map(), []);
  const clearClicks = useTimeout(() => setClicks([]), WAVE_LIVE);
  function addClick(x, y, pointerId) {
    const dateNow = Date.now();
    const filteredClicks = clicks.filter((click) => click.id + WAVE_LIVE > dateNow);
    setClicks([
      ...filteredClicks,
      {
        x,
        y,
        id: dateNow,
        pointerId
      }
    ]);
    clearClicks.set();
    pointerDelayTimers.delete(pointerId);
  }
  const onPointerDown = (e) => {
    const { top, left } = getOffsetRect2(e.currentTarget);
    const x = e.clientX - (left !== null && left !== void 0 ? left : 0);
    const y = e.clientY - (top !== null && top !== void 0 ? top : 0);
    pointerDelayTimers.set(e.pointerId, setTimeout(() => addClick(x, y, e.pointerId), DELAY));
  };
  const onPointerCancel = (e) => {
    const timer = pointerDelayTimers.get(e.pointerId);
    clearTimeout(timer);
    pointerDelayTimers.delete(e.pointerId);
  };
  const reallyNeedRipple = (!hasMouse || hasPointerContext === false) && needRipple;
  return {
    clicks,
    onPointerDown: reallyNeedRipple ? onPointerDown : noop,
    onPointerCancel: reallyNeedRipple ? onPointerCancel : noop
  };
};
var Ripple = ({ needRipple = true, clicks }) => {
  return React30.createElement("span", {
    "aria-hidden": true,
    className: classNames("vkuiTappable__stateLayer", needRipple && "vkuiTappable__ripple")
  }, clicks.map((wave) => React30.createElement("span", {
    key: wave.id,
    className: "vkuiTappable__wave",
    style: {
      top: wave.y,
      left: wave.x
    }
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Tappable/state.js
var DEFAULT_STATE_MODE = "background";
var stylesHovered = {
  background: "vkuiTappable--hovered-background",
  opacity: "vkuiTappable--hovered-opacity",
  none: ""
};
function hoverClass(hoverMode = DEFAULT_STATE_MODE) {
  const presetClass = stylesHovered[hoverMode];
  return presetClass !== void 0 ? presetClass : hoverMode;
}
var stylesActivated = {
  background: "vkuiTappable--activated-background",
  opacity: "vkuiTappable--activated-opacity",
  none: ""
};
function activeClass(activeMode = DEFAULT_STATE_MODE) {
  const presetClass = stylesActivated[activeMode];
  return presetClass !== void 0 ? presetClass : activeMode;
}

// node_modules/@vkontakte/vkui/dist/components/Tappable/Tappable.js
var sizeXClassNames = {
  none: "vkuiTappable--sizeX-none",
  compact: "vkuiTappable--sizeX-compact"
};
function hasPointerClassName(hasPointer) {
  switch (hasPointer) {
    case void 0:
      return "vkuiTappable--hasPointer-none";
    case false:
      return "vkuiTappable--hasPointer-false";
  }
  return void 0;
}
var Tappable = (_param) => {
  var { baseClassName, borderRadiusMode = "auto", children, hoverMode = DEFAULT_STATE_MODE, activeMode = DEFAULT_STATE_MODE, onPointerDown, onPointerCancel } = _param, restProps = _object_without_properties(_param, [
    "baseClassName",
    "borderRadiusMode",
    "children",
    "hoverMode",
    "activeMode",
    "onPointerDown",
    "onPointerCancel"
  ]);
  const isClickable = checkClickable(restProps);
  const { sizeX = "none", hasPointer } = useAdaptivity();
  const needRipple = useMaybeNeedRipple(activeMode, hasPointer);
  const _useRipple = useRipple(needRipple, hasPointer), { clicks } = _useRipple, rippleEvents = _object_without_properties(_useRipple, [
    "clicks"
  ]);
  const handlers = mergeCalls(rippleEvents, {
    onPointerDown,
    onPointerCancel
  });
  const typeProps = restProps.Component === "button" ? {
    type: "button"
  } : {};
  return React31.createElement(Clickable, _object_spread({
    baseClassName: classNames(baseClassName, "vkuiTappable", sizeX !== SizeType.REGULAR && sizeXClassNames[sizeX], borderRadiusMode === "inherit" && "vkuiTappable--borderRadiusInherit", hasPointerClassName(hasPointer)),
    hoverClassName: hoverClass(hoverMode),
    activeClassName: activeClass(activeMode)
  }, typeProps, handlers, restProps), children, isClickable && (hoverMode === "background" || activeMode === "background") && React31.createElement(Ripple, {
    needRipple,
    clicks
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FixedLayout/FixedLayout.js
var React37 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useExternRef.js
var React33 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/utils.js
var React32 = __toESM(require_react());
function debounce2(fn, delay) {
  let timeout;
  return (...args) => {
    clearTimeout(timeout);
    timeout = setTimeout(() => fn(...args), delay);
  };
}
function setRef(element1, ref) {
  if (ref) {
    if (typeof ref === "function") {
      ref(element1);
    } else {
      ref.current = element1;
    }
  }
}
function multiRef(...refs) {
  let current = null;
  return {
    get current() {
      return current;
    },
    set current(element) {
      current = element;
      refs.forEach((ref) => ref && setRef(element, ref));
    }
  };
}
var stopPropagation = (event) => event.stopPropagation();
var excludeKeysWithUndefined = (obj) => {
  const filteredObj = {};
  for (const key in obj) {
    if (obj.hasOwnProperty(key) && obj[key] !== void 0) {
      filteredObj[key] = obj[key];
    }
  }
  return filteredObj;
};
var isDOMTypeElement = (element1) => typeof element1.type === "string";
function isValidNotReactFragmentElement(children) {
  return React32.isValidElement(children) && // @ts-expect-error: TS2339 $$typeof всегда symbol, в отличии от type, благодаря этому пропускаем лишние проверки на тип.
  children.$$typeof !== Symbol.for("react.fragment");
}
function isForwardRefElement(children) {
  if (!React32.isValidElement(children)) {
    return false;
  }
  const typeOfOfType = children.type && children.type.$$typeof;
  return typeOfOfType === Symbol.for("react.forward_ref");
}

// node_modules/@vkontakte/vkui/dist/hooks/useExternRef.js
function useExternRef(...externRefs) {
  const stableRef = React33.useRef(null);
  return React33.useMemo(
    () => ({
      get current() {
        return stableRef.current;
      },
      set current(el) {
        stableRef.current = el;
        externRefs.forEach((ref) => {
          if (ref) {
            setRef(el, ref);
          }
        });
      }
    }),
    // eslint-disable-next-line react-hooks/exhaustive-deps
    externRefs
  );
}

// node_modules/@vkontakte/vkui/dist/hooks/useEventListener.js
var React34 = __toESM(require_react());
function useEventListener(event, _cb, _options) {
  const cbRef = React34.useRef(_cb);
  useIsomorphicLayoutEffect(() => {
    cbRef.current = _cb;
  }, [
    _cb
  ]);
  const cb = React34.useCallback((e) => cbRef.current && cbRef.current(e), []);
  const detach = React34.useRef(noop);
  const remove = React34.useCallback(() => {
    detach.current();
    detach.current = noop;
  }, []);
  const add = React34.useCallback((el) => {
    if (!canUseDOM) {
      return;
    }
    remove();
    if (!el) {
      return;
    }
    const options = _object_spread({}, _options);
    el.addEventListener(event, cb, options);
    detach.current = () => el.removeEventListener(event, cb, options);
  }, [
    _options,
    cb,
    event,
    remove
  ]);
  React34.useEffect(() => remove, [
    remove
  ]);
  return React34.useMemo(() => ({
    add,
    remove
  }), [
    add,
    remove
  ]);
}

// node_modules/@vkontakte/vkui/dist/hooks/useGlobalEventListener.js
function useGlobalEventListener(element, event, cb, options) {
  const listener = useEventListener(event, cb, options);
  useIsomorphicLayoutEffect(() => {
    if (cb && element) {
      listener.add(element);
    } else {
      listener.remove();
    }
  }, [
    Boolean(cb),
    Boolean(element)
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/OnboardingTooltip/OnboardingTooltipContainer.js
var React35 = __toESM(require_react());
var onboardingTooltipContainerAttr = "data-onboarding-tooltip-container";
var OnboardingTooltipContainer = React35.forwardRef((_param, ref) => {
  var { fixed = false } = _param, props = _object_without_properties(_param, [
    "fixed"
  ]);
  props[onboardingTooltipContainerAttr] = fixed ? "fixed" : "true";
  return React35.createElement("div", _object_spread_props(_object_spread({}, props), {
    ref
  }));
});
OnboardingTooltipContainer.displayName = "OnboardingTooltipContainer";

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitColContext.js
var React36 = __toESM(require_react());
var SplitColContext = React36.createContext({
  colRef: null,
  animate: true
});
var useSplitCol = () => React36.useContext(SplitColContext);

// node_modules/@vkontakte/vkui/dist/components/FixedLayout/FixedLayout.js
var stylesVertical = {
  top: "vkuiFixedLayout--vertical-top",
  bottom: classNames("vkuiFixedLayout--vertical-bottom", "vkuiInternalFixedLayout--vertical-bottom")
};
var FixedLayout = (_param) => {
  var { children, style, vertical, getRootRef, filled, className, useParentWidth } = _param, restProps = _object_without_properties(_param, [
    "children",
    "style",
    "vertical",
    "getRootRef",
    "filled",
    "className",
    "useParentWidth"
  ]);
  const platform3 = usePlatform();
  const ref = useExternRef(getRootRef);
  const [width, setWidth] = React37.useState(void 0);
  const { window: window2 } = useDOM();
  const { colRef } = React37.useContext(SplitColContext);
  const doResize = () => {
    if (useParentWidth && ref.current) {
      var _ref_current_parentElement;
      const parentWidth = (_ref_current_parentElement = ref.current.parentElement) === null || _ref_current_parentElement === void 0 ? void 0 : _ref_current_parentElement.getBoundingClientRect().width;
      setWidth(parentWidth ? `${parentWidth}px` : void 0);
    } else if (colRef === null || colRef === void 0 ? void 0 : colRef.current) {
      const computedStyle = getComputedStyle(colRef.current);
      setWidth(`${colRef.current.clientWidth - parseFloat(computedStyle.paddingLeft) - parseFloat(computedStyle.paddingRight)}px`);
    } else {
      setWidth(void 0);
    }
  };
  React37.useEffect(doResize, [
    colRef,
    platform3,
    ref,
    useParentWidth
  ]);
  useGlobalEventListener(window2, "resize", doResize);
  return React37.createElement(OnboardingTooltipContainer, _object_spread_props(_object_spread({}, restProps), {
    fixed: true,
    ref,
    className: classNames("vkuiFixedLayout", platform3 === "ios" && "vkuiInternalFixedLayout--ios", filled && "vkuiFixedLayout--filled", vertical && stylesVertical[vertical], className),
    style: _object_spread_props(_object_spread({}, style), {
      width
    })
  }), children);
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBase.js
var React43 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/comparing.js
function isNotUndefined(value) {
  return value !== void 0;
}
function fnArgsOr(fn, args, defaultValue) {
  const definedArgs = args.filter(isNotUndefined);
  if (definedArgs.length) {
    return fn(...definedArgs);
  }
  return defaultValue;
}
function minOr(args, defaultValue) {
  return fnArgsOr(Math.min, args, defaultValue);
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseBadge/ImageBaseBadge.js
var React39 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ImageBase/context.js
var React38 = __toESM(require_react());
var ImageBaseContext = React38.createContext({
  size: 0
});

// node_modules/@vkontakte/vkui/dist/lib/warnOnce.js
function warnOnce(zone) {
  const didWarn = /* @__PURE__ */ new Set();
  return (message, type = "warn") => {
    if (!didWarn.has(message)) {
      didWarn.add(message);
      const formattedMessage = `%c[VKUI/${zone}] ${message}`;
      const styles = type === "log" ? "color: steelblue; font-style: italic" : void 0;
      console[type](formattedMessage, styles);
    }
  };
}
function getA11yRuleUrl(ruleName) {
  const AXE_CORE_MINOR_VERSION = "4.5";
  return `https://dequeuniversity.com/rules/axe/${AXE_CORE_MINOR_VERSION}/${ruleName}`;
}
var COMMON_WARNINGS = {
  a11y: {
    "button-name": `a11y: Кнопка должна содержать текст, доступный для скринридеров. Чтобы исправить эту ошибку, передайте компоненту текст или свойство aria-label.
${getA11yRuleUrl("button-name")}`,
    "link-name": `a11y: Ссылка должна содержать текст, доступный для скринридеров. Чтобы исправить эту ошибку, передайте компоненту текст или свойство aria-label.
${getA11yRuleUrl("link-name")}`,
    "image-alt": `a11y: Изображение должно содержать альтернативный текст, который его описывает. Чтобы исправить эту ошибку, передайте компоненту свойство alt.
${getA11yRuleUrl("image-alt")}`
  }
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/helpers.js
function getFallbackIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 20) {
    return 12;
  } else if (imageSize > 20 && imageSize <= 28) {
    return 16;
  } else if (imageSize > 28 && imageSize <= 32) {
    return 20;
  } else if (imageSize > 32 && imageSize <= 44) {
    return 24;
  } else if (imageSize > 44 && imageSize <= 64) {
    return 28;
  }
  return getFallbackIconSizeByImageBaseSize.MAX_SIZE;
}
getFallbackIconSizeByImageBaseSize.MAX_SIZE = 36;
function getBadgeIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 36) {
    return 12;
  } else if (imageSize > 36 && imageSize <= 48) {
    return 16;
  } else if (imageSize > 48 && imageSize <= 64) {
    return 20;
  }
  return getBadgeIconSizeByImageBaseSize.MAX_SIZE;
}
getBadgeIconSizeByImageBaseSize.MAX_SIZE = 24;
function getOverlayIconSizeByImageBaseSize(imageSize) {
  if (imageSize <= 20) {
    return 12;
  } else if (imageSize > 20 && imageSize <= 24) {
    return 16;
  } else if (imageSize > 24 && imageSize <= 28) {
    return 18;
  } else if (imageSize > 28 && imageSize <= 40) {
    return 20;
  } else if (imageSize > 40 && imageSize <= 48) {
    return 24;
  } else if (imageSize > 48 && imageSize <= 88) {
    return 28;
  }
  return getOverlayIconSizeByImageBaseSize.MAX_SIZE;
}
getOverlayIconSizeByImageBaseSize.MAX_SIZE = 32;

// node_modules/@vkontakte/vkui/dist/components/ImageBase/types.js
var imageBaseSizes = [
  16,
  20,
  24,
  28,
  32,
  36,
  40,
  44,
  48,
  56,
  64,
  72,
  80,
  88,
  96
];

// node_modules/@vkontakte/vkui/dist/components/ImageBase/validators.js
function parseIconSizeByDisplayName(displayName) {
  if (typeof displayName !== "string") {
    return null;
  }
  const match = /Icon(\d+)/.exec(displayName);
  return match ? Number(match[1]) : null;
}
function parseIconSizeByWidthProp(width) {
  if (typeof width !== "string" && typeof width !== "number") {
    return null;
  }
  const size4 = Number(width);
  return size4 > 0 ? size4 : null;
}
function getElementDisplayName(element) {
  var _element_type_displayName;
  return (_element_type_displayName = element.type.displayName) !== null && _element_type_displayName !== void 0 ? _element_type_displayName : null;
}
function getElementWidthProp(element) {
  var _element_props_width;
  return (_element_props_width = element.props.width) !== null && _element_props_width !== void 0 ? _element_props_width : null;
}
function getIconSizeByElement(element) {
  const sizeByDisplayName = parseIconSizeByDisplayName(getElementDisplayName(element));
  const sizeByWidth = parseIconSizeByWidthProp(getElementWidthProp(element));
  return sizeByWidth ? sizeByWidth : sizeByDisplayName;
}
function validateIconComponentSizeByImageSize(imageSize, iconProp, selectorFn, logger) {
  const iconSize2 = getIconSizeByElement(iconProp.value);
  if (iconSize2 === null) {
    return;
  }
  const result = selectorFn(imageSize);
  if (result === iconSize2 || result === selectorFn.MAX_SIZE && iconSize2 >= result) {
    return;
  }
  const iconName = getElementDisplayName(iconProp.value);
  const propMessage = iconName ? `${iconProp.name}={<${iconName} />}` : iconProp.name;
  logger(`Размер \`${propMessage}\` не соответствует дизайн-системе. Для \`size={${imageSize}}\` размер иконки для \`${iconProp.name}\` должен соответствовать <Icon${result}<name> />. Если такого размера нет, то используйте <${iconName} width={${result}} height={${result}} />`, "log");
}
var warnImageBase = warnOnce("ImageBase");
function validateFallbackIcon(imageSize, iconProp) {
  return validateIconComponentSizeByImageSize(imageSize, iconProp, getFallbackIconSizeByImageBaseSize, warnImageBase);
}
var mapOfExpectedSize = new Set(imageBaseSizes);
var arrayOfSizes = Object.keys(mapOfExpectedSize).map((str) => Number(str));
var maxSize = arrayOfSizes.reduce((maxSize2, size4) => size4 > maxSize2 ? size4 : maxSize2, 0);
function validateSize(imageSize) {
  if (imageSize > maxSize || mapOfExpectedSize.has(imageSize)) {
    return;
  }
  warnImageBase(`\`size={${imageSize}}\` не соответствует дизайн-системе. Пожалуйста, используйте один из следующих вариантов: ${arrayOfSizes.join(" | ")}`, "log");
}
var warnImageBaseBadge = warnOnce("ImageBase.Badge");
function validateBadgeIcon(imageSize, iconProp) {
  if (imageSize < 24 && iconProp) {
    return warnImageBaseBadge("Не используйте бейдж при `size < 24`.", "log");
  }
  validateIconComponentSizeByImageSize(imageSize, iconProp, getBadgeIconSizeByImageBaseSize, warnImageBaseBadge);
}
var warnImageBaseOverlay = warnOnce("ImageBase.Overlay");
function validateOverlayIcon(imageSize, iconProp) {
  validateIconComponentSizeByImageSize(imageSize, iconProp, getOverlayIconSizeByImageBaseSize, warnImageBaseOverlay);
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseBadge/ImageBaseBadge.js
var backgroundStyles = {
  stroke: "vkuiImageBaseBadge--background-stroke",
  shadow: "vkuiImageBaseBadge--background-shadow"
};
var ImageBaseBadge = (_param) => {
  var { background = "shadow" } = _param, restProps = _object_without_properties(_param, [
    "background"
  ]);
  if (true) {
    if (restProps.children) {
      const { size: size4 } = React39.useContext(ImageBaseContext);
      validateBadgeIcon(size4, {
        name: "children",
        value: restProps.children
      });
    }
  }
  return React39.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiImageBaseBadge", backgroundStyles[background])
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/ImageBaseOverlay.js
var React42 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityHasPointer.js
var React41 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useIsClient.js
var React40 = __toESM(require_react());
function useIsClient(initial = false) {
  const [isClient, setIsClient] = React40.useState(initial);
  useIsomorphicLayoutEffect(() => {
    setIsClient(true);
  }, []);
  return isClient;
}

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityHasPointer.js
function useAdaptivityHasPointer(deferDetect = true) {
  const { hasPointer: hasPointerContext } = React41.useContext(AdaptivityContext);
  const needTwoPassRendering = deferDetect || hasPointerContext === void 0;
  const isClient = useIsClient(!needTwoPassRendering);
  if (!isClient || hasPointerContext !== void 0) {
    return hasPointerContext;
  }
  return hasMouse;
}

// node_modules/@vkontakte/vkui/dist/hooks/useAppearance.js
function useAppearance() {
  const { appearance } = useConfigProvider();
  return appearance !== null && appearance !== void 0 ? appearance : DEFAULT_APPEARANCE;
}

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBaseOverlay/ImageBaseOverlay.js
var ImageBaseOverlay = (_param) => {
  var { className, theme: themeProp, visibility: visibilityProp, children, onClick: onClickProp } = _param, restProps = _object_without_properties(_param, [
    "className",
    "theme",
    "visibility",
    "children",
    "onClick"
  ]);
  const appearance = useAppearance();
  const hasPointer = useAdaptivityHasPointer();
  const theme = themeProp !== null && themeProp !== void 0 ? themeProp : appearance;
  const visibility = visibilityProp !== null && visibilityProp !== void 0 ? visibilityProp : hasPointer ? "on-hover" : "always";
  if (true) {
    if (children) {
      const { size: size4 } = React42.useContext(ImageBaseContext);
      validateOverlayIcon(size4, {
        name: "children",
        value: children
      });
    }
  }
  const onClick = (onClickProp !== null && onClickProp !== void 0 ? onClickProp : visibility === "on-hover") ? noop : void 0;
  return React42.createElement(Tappable, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("vkuiImageBaseOverlay", visibility === "always" && "vkuiImageBaseOverlay--visible", theme === "light" && "vkuiImageBaseOverlay--theme-light", theme === "dark" && "vkuiImageBaseOverlay--theme-dark", className),
    hasHover: visibility === "on-hover",
    hoverMode: visibility === "on-hover" ? "vkuiImageBaseOverlay--visible" : void 0,
    focusVisibleMode: classNames(focusVisiblePresetModeClassNames["inside"], "vkuiImageBaseOverlay--visible"),
    hasActive: false,
    onClick
  }), children);
};

// node_modules/@vkontakte/vkui/dist/components/ImageBase/ImageBase.js
var defaultSize = 24;
var ImageBase = (_param) => {
  var { alt, crossOrigin, decoding, loading, referrerPolicy, sizes, src, srcSet, useMap, getRef, size: sizeProp, width: widthImg, height: heightImg, widthSize, heightSize, style, noBorder = false, fallbackIcon: fallbackIconProp, children, onLoad, onError, withTransparentBackground } = _param, restProps = _object_without_properties(_param, [
    "alt",
    "crossOrigin",
    "decoding",
    "loading",
    "referrerPolicy",
    "sizes",
    "src",
    "srcSet",
    "useMap",
    "getRef",
    "size",
    "width",
    "height",
    "widthSize",
    "heightSize",
    "style",
    "noBorder",
    "fallbackIcon",
    "children",
    "onLoad",
    "onError",
    "withTransparentBackground"
  ]);
  const size4 = sizeProp !== null && sizeProp !== void 0 ? sizeProp : minOr([
    widthSize,
    heightSize
  ], defaultSize);
  const width = widthSize !== null && widthSize !== void 0 ? widthSize : size4;
  const height = heightSize !== null && heightSize !== void 0 ? heightSize : size4;
  const [loaded, setLoaded] = React43.useState(false);
  const [failed, setFailed] = React43.useState(false);
  const hasSrc = src || srcSet;
  const needShowFallbackIcon = (failed || !hasSrc) && React43.isValidElement(fallbackIconProp);
  const fallbackIcon = needShowFallbackIcon ? fallbackIconProp : null;
  if (true) {
    validateSize(size4);
    if (fallbackIcon) {
      validateFallbackIcon(size4, {
        name: "fallbackIcon",
        value: fallbackIcon
      });
    }
  }
  const handleImageLoad = (event) => {
    if (loaded) {
      return;
    }
    setLoaded(true);
    setFailed(false);
    onLoad === null || onLoad === void 0 ? void 0 : onLoad(event);
  };
  const handleImageError = (event) => {
    setLoaded(false);
    setFailed(true);
    onError === null || onError === void 0 ? void 0 : onError(event);
  };
  const imgRef = useExternRef(getRef);
  const isOnLoadStatusCheckedRef = React43.useRef(false);
  React43.useEffect(function dispatchLoadEventForAlreadyLoadedResourceIfReactInitializedLater() {
    if (isOnLoadStatusCheckedRef.current) {
      return;
    }
    isOnLoadStatusCheckedRef.current = true;
    if (imgRef.current && imgRef.current.complete && !loaded) {
      const event = new Event("load");
      imgRef.current.dispatchEvent(event);
    }
  }, [
    imgRef,
    loaded
  ]);
  return React43.createElement(ImageBaseContext.Provider, {
    value: {
      size: size4
    }
  }, React43.createElement(Clickable, _object_spread({
    style: _object_spread({
      width,
      height
    }, style),
    baseClassName: classNames("vkuiImageBase", loaded && "vkuiImageBase--loaded", withTransparentBackground && "vkuiImageBase--transparent-background")
  }, restProps), hasSrc && React43.createElement("img", {
    ref: imgRef,
    alt,
    className: "vkuiImageBase__img",
    crossOrigin,
    decoding,
    loading,
    referrerPolicy,
    sizes,
    src,
    srcSet,
    useMap,
    width: widthImg,
    height: heightImg,
    onLoad: handleImageLoad,
    onError: handleImageError
  }), fallbackIcon && React43.createElement("div", {
    className: "vkuiImageBase__fallback"
  }, fallbackIcon), children, !noBorder && React43.createElement("div", {
    "aria-hidden": true,
    className: "vkuiImageBase__border"
  })));
};
ImageBase.Badge = ImageBaseBadge;
ImageBase.Overlay = ImageBaseOverlay;

// node_modules/@vkontakte/vkui/dist/components/Button/Button.js
var React46 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Spinner/Spinner.js
var React45 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/VisuallyHidden/VisuallyHidden.js
var React44 = __toESM(require_react());
var VisuallyHidden = (_param) => {
  var { Component: Component3 = "span" } = _param, restProps = _object_without_properties(_param, [
    "Component"
  ]);
  return React44.createElement(RootComponent, _object_spread_props(_object_spread({
    Component: Component3
  }, restProps), {
    baseClassName: classNames("vkuiVisuallyHidden", Component3 === "input" && "vkuiVisuallyHidden--focusable-input")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Spinner/Spinner.js
var Spinner = React45.memo((_param) => {
  var { size: size4 = "regular", children = "Загружается...", disableAnimation } = _param, restProps = _object_without_properties(_param, [
    "size",
    "children",
    "disableAnimation"
  ]);
  const SpinnerIcon = {
    small: Icon16Spinner,
    regular: Icon24Spinner,
    medium: Icon32Spinner,
    large: Icon44Spinner
  }[size4];
  const center = {
    small: 8,
    regular: 12,
    medium: 16,
    large: 22
  }[size4];
  return React45.createElement(RootComponent, _object_spread_props(_object_spread({
    Component: "span",
    role: "status"
  }, restProps), {
    baseClassName: "vkuiSpinner"
  }), React45.createElement(SpinnerIcon, null, !disableAnimation && // TODO [a11y]: use reduced motion hook?
  //              https://github.com/VKCOM/VKUI/pull/4673
  React45.createElement("animateTransform", {
    attributeName: "transform",
    attributeType: "XML",
    type: "rotate",
    from: `0 ${center} ${center}`,
    to: `360 ${center} ${center}`,
    dur: "0.7s",
    repeatCount: "indefinite"
  })), hasReactNode(children) && React45.createElement(VisuallyHidden, null, children));
});
Spinner.displayName = "Spinner";

// node_modules/@vkontakte/vkui/dist/components/Button/Button.js
var stylesSize = {
  s: "vkuiButton--size-s",
  m: "vkuiButton--size-m",
  l: "vkuiButton--size-l"
};
var stylesMode = {
  primary: "vkuiButton--mode-primary",
  secondary: "vkuiButton--mode-secondary",
  tertiary: "vkuiButton--mode-tertiary",
  outline: "vkuiButton--mode-outline",
  link: "vkuiButton--mode-link"
};
var stylesAppearance = {
  "accent": "vkuiButton--appearance-accent",
  "positive": "vkuiButton--appearance-positive",
  "negative": "vkuiButton--appearance-negative",
  "neutral": "vkuiButton--appearance-neutral",
  "overlay": "vkuiButton--appearance-overlay",
  "accent-invariable": "vkuiButton--appearance-accent-invariable"
};
var stylesAlign = {
  left: "vkuiButton--align-left",
  center: "vkuiButton--align-center",
  right: "vkuiButton--align-right"
};
var sizeYClassNames4 = {
  none: "vkuiButton--sizeY-none",
  ["regular"]: "vkuiButton--sizeY-regular"
};
var Button = (_param) => {
  var { size: size4 = "s", mode = "primary", appearance = "accent", stretched = false, align = "center", children, before, after, getRootRef, loading, onClick = noop, className, disableSpinnerAnimation, rounded } = _param, restProps = _object_without_properties(_param, [
    "size",
    "mode",
    "appearance",
    "stretched",
    "align",
    "children",
    "before",
    "after",
    "getRootRef",
    "loading",
    "onClick",
    "className",
    "disableSpinnerAnimation",
    "rounded"
  ]);
  const hasIcons = Boolean(before || after);
  const hasIconOnly = !children && Boolean(after) !== Boolean(before);
  const { sizeY = "none" } = useAdaptivity();
  const platform3 = usePlatform();
  return React46.createElement(Tappable, _object_spread_props(_object_spread({
    hoverMode: "vkuiButton--hover",
    activeMode: "vkuiButton--active",
    Component: restProps.href ? "a" : "button",
    focusVisibleMode: "outside"
  }, restProps), {
    onClick: loading ? void 0 : onClick,
    className: classNames(className, "vkuiButton", stylesSize[size4], stylesMode[mode], stylesAppearance[appearance], stylesAlign[align], sizeY !== "compact" && sizeYClassNames4[sizeY], platform3 === "ios" && "vkuiButton--ios", stretched && "vkuiButton--stretched", hasIcons && "vkuiButton--with-icon", hasIconOnly && !stretched && "vkuiButton--singleIcon", loading && "vkuiButton--loading", rounded && "vkuiButton--rounded"),
    getRootRef
  }), loading && React46.createElement(Spinner, {
    size: "small",
    className: "vkuiButton__spinner",
    disableAnimation: disableSpinnerAnimation
  }), React46.createElement("span", {
    className: "vkuiButton__in"
  }, hasReactNode(before) && React46.createElement("span", {
    className: "vkuiButton__before",
    role: "presentation",
    "data-testid": false ? "before" : void 0
  }, before), hasReactNode(children) && React46.createElement("span", {
    className: "vkuiButton__content",
    "data-testid": false ? "children" : void 0
  }, children), hasReactNode(after) && React46.createElement("span", {
    className: "vkuiButton__after",
    role: "presentation",
    "data-testid": false ? "after" : void 0
  }, after)));
};

// node_modules/@vkontakte/vkui/dist/components/IconButton/IconButton.js
var React47 = __toESM(require_react());
var sizeYClassNames5 = {
  none: "vkuiIconButton--sizeY-none",
  compact: "vkuiIconButton--sizeY-compact"
};
var warn = warnOnce("IconButton");
var IconButton = (_param) => {
  var { label, children, className } = _param, restProps = _object_without_properties(_param, [
    "label",
    "children",
    "className"
  ]);
  const platform3 = usePlatform();
  const { sizeY = "none" } = useAdaptivity();
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn(COMMON_WARNINGS.a11y[restProps.href ? "link-name" : "button-name"], "error");
    }
  }
  return React47.createElement(Tappable, _object_spread_props(_object_spread({
    activeEffectDelay: 200,
    activeMode: "background",
    Component: restProps.href ? "a" : "button"
  }, restProps), {
    className: classNames("vkuiIconButton", sizeY !== "regular" && sizeYClassNames5[sizeY], platform3 === "ios" && "vkuiIconButton--ios", className)
  }), label && React47.createElement(VisuallyHidden, null, label), children);
};

// node_modules/@vkontakte/vkui/dist/components/Root/Root.js
var React50 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/getNavId.js
function getNavId(props, warn25) {
  const id = props.nav || props.id;
  if (!id && warn25) {
    warn25('Навигационный элемент должен иметь свойство "nav" или "id"', "error");
  }
  return id;
}

// node_modules/@vkontakte/vkui/dist/components/NavTransitionContext/NavTransitionContext.js
var React48 = __toESM(require_react());
var TransitionContext = React48.createContext({
  entering: false
});
var useNavTransition = () => React48.useContext(TransitionContext);
var NavTransitionProvider = ({ children, entering }) => {
  const parentContext = useNavTransition();
  const contextValue = useObjectMemo({
    entering: parentContext.entering || entering
  });
  return React48.createElement(TransitionContext.Provider, {
    value: contextValue
  }, children);
};

// node_modules/@vkontakte/vkui/dist/components/NavTransitionDirectionContext/NavTransitionDirectionContext.js
var React49 = __toESM(require_react());
var TransitionDirectionContext = React49.createContext(void 0);
var NavTransitionDirectionProvider = ({ children, isBack: isBackProp }) => {
  const parentIsBack = React49.useContext(TransitionDirectionContext);
  const isBack = isBackProp !== void 0 ? isBackProp : parentIsBack;
  const [isBackOnMount] = React49.useState(isBack);
  return React49.createElement(TransitionDirectionContext.Provider, {
    value: isBackOnMount
  }, children);
};
var useNavDirection = () => {
  const isBack = React49.useContext(TransitionDirectionContext);
  const transitionDirection = isBack === void 0 ? void 0 : isBack ? "backwards" : "forwards";
  return transitionDirection;
};

// node_modules/@vkontakte/vkui/dist/components/Root/Root.js
var warn2 = warnOnce("Root");
var Root = (_param) => {
  var { children, activeView: _activeView, onTransition, nav } = _param, restProps = _object_without_properties(_param, [
    "children",
    "activeView",
    "onTransition",
    "nav"
  ]);
  const scroll = React50.useContext(ScrollContext);
  const platform3 = usePlatform();
  const { document: document2 } = useDOM();
  const scrolls = React50.useRef({}).current;
  const viewNodes = React50.useRef({}).current;
  const { transitionMotionEnabled = true } = useConfigProvider();
  const { animate: animate3 } = React50.useContext(SplitColContext);
  const disableAnimation = !transitionMotionEnabled || !animate3;
  const views = React50.Children.toArray(children);
  const [{ prevView, activeView, transition, isBack }, _setState] = React50.useState({
    activeView: _activeView,
    transition: false
  });
  const transitionTo = (panel) => {
    if (panel !== activeView) {
      const viewIds = views.map((view) => getNavId(view.props, warn2));
      const isBack2 = viewIds.indexOf(panel) < viewIds.indexOf(activeView);
      scrolls[activeView] = scroll.getScroll().y;
      _setState({
        activeView: panel,
        prevView: activeView,
        transition: !disableAnimation,
        isBack: isBack2
      });
    }
  };
  const finishTransition = React50.useCallback(() => _setState({
    activeView,
    prevView,
    isBack,
    transition: false
  }), [
    activeView,
    isBack,
    prevView
  ]);
  useIsomorphicLayoutEffect(() => {
    document2.activeElement.blur();
  }, [
    activeView
  ]);
  useIsomorphicLayoutEffect(() => transitionTo(_activeView), [
    _activeView
  ]);
  useIsomorphicLayoutEffect(() => {
    if (!transition && prevView) {
      scroll.scrollTo(0, isBack ? scrolls[activeView] : 0);
      onTransition && onTransition({
        isBack: Boolean(isBack),
        from: prevView,
        to: activeView
      });
    }
  }, [
    transition,
    prevView
  ]);
  const fallbackTransition = useTimeout(finishTransition, platform3 === "ios" ? 600 : 300);
  React50.useEffect(() => {
    if (!transition) {
      fallbackTransition.clear();
      return;
    }
    fallbackTransition.set();
  }, [
    fallbackTransition,
    transition
  ]);
  const onAnimationEnd = (e) => {
    if ([
      "vkuiroot-android-animation-hide-back",
      "vkuiroot-android-animation-show-forward",
      "vkuiroot-ios-animation-hide-back",
      "vkuiroot-ios-animation-show-forward"
    ].includes(e.animationName)) {
      finishTransition();
    }
  };
  return React50.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiRoot", platform3 === "ios" && "vkuiRoot--ios", transition && "vkuiRoot--transition")
  }), views.map((view) => {
    const viewId = getNavId(view.props, warn2);
    if (viewId !== activeView && !(transition && viewId === prevView)) {
      return null;
    }
    const isTransitionTarget = transition && viewId === (isBack ? prevView : activeView);
    const compensateScroll = transition && (viewId === prevView || isBack && viewId === activeView);
    var _scrolls_viewId;
    return React50.createElement("div", {
      key: viewId,
      ref: (e) => viewId && (viewNodes[viewId] = e),
      onAnimationEnd: isTransitionTarget ? onAnimationEnd : void 0,
      className: classNames("vkuiRoot__view", transition && viewId === prevView && isBack && "vkuiRoot__view--hide-back", transition && viewId === prevView && !isBack && "vkuiRoot__view--hide-forward", transition && viewId === activeView && isBack && "vkuiRoot__view--show-back", transition && viewId === activeView && !isBack && "vkuiRoot__view--show-forward")
    }, React50.createElement(NavTransitionDirectionProvider, {
      isBack
    }, React50.createElement(NavTransitionProvider, {
      entering: transition && viewId === activeView
    }, React50.createElement("div", {
      className: "vkuiRoot__scrollCompensation",
      style: {
        marginTop: compensateScroll ? viewId && -((_scrolls_viewId = scrolls[viewId]) !== null && _scrolls_viewId !== void 0 ? _scrolls_viewId : 0) : void 0
      }
    }, view))));
  }));
};

// node_modules/@vkontakte/vkui/dist/components/View/View.js
var React62 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/usePrevious.js
var React51 = __toESM(require_react());
function usePrevious(value) {
  const ref = React51.useRef();
  React51.useEffect(() => {
    ref.current = value;
  });
  return ref.current;
}

// node_modules/@vkontakte/vkui/dist/hooks/useWaitTransitionFinish.js
var React52 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/testing.js
var isTesting = Boolean(canUseDOM && window.__isVkuiTesting);

// node_modules/@vkontakte/vkui/dist/lib/supportEvents.js
var animationEvent2 = {
  supported: false
};
var transitionEvent2 = {
  supported: false,
  name: null
};
if (canUseDOM && !isTesting) {
  if (typeof AnimationEvent !== "undefined") {
    animationEvent2.supported = true;
  } else if (typeof WebKitAnimationEvent !== "undefined") {
    animationEvent2.supported = true;
  }
  if (typeof TransitionEvent !== "undefined") {
    transitionEvent2.supported = true;
    transitionEvent2.name = "transitionend";
  } else if (typeof WebKitTransitionEvent !== "undefined") {
    transitionEvent2.supported = true;
    transitionEvent2.name = "webkitTransitionEnd";
  }
}

// node_modules/@vkontakte/vkui/dist/hooks/useWaitTransitionFinish.js
var useWaitTransitionFinish = () => {
  const timeoutRef = React52.useRef(null);
  const { document: document2 } = useDOM();
  const detach = React52.useRef(noop);
  const remove = React52.useCallback(() => {
    detach.current();
    detach.current = noop;
  }, []);
  const waitTransitionFinish = React52.useCallback((element, eventHandler, durationFallback) => {
    if (element) {
      if (!(document2 === null || document2 === void 0 ? void 0 : document2.hidden) && transitionEvent2.supported && transitionEvent2.name) {
        remove();
        element.addEventListener(transitionEvent2.name, eventHandler);
        detach.current = () => {
          if (transitionEvent2.name) {
            element.removeEventListener(transitionEvent2.name, eventHandler);
          }
        };
      } else {
        if (timeoutRef === null || timeoutRef === void 0 ? void 0 : timeoutRef.current) {
          clearTimeout(timeoutRef.current);
        }
        timeoutRef.current = setTimeout(eventHandler, durationFallback);
      }
    }
  }, [
    document2,
    remove,
    timeoutRef
  ]);
  return {
    waitTransitionFinish
  };
};

// node_modules/@vkontakte/vkui/dist/components/NavIdContext/NavIdContext.js
var React53 = __toESM(require_react());
var NavViewIdContext = React53.createContext(void 0);
var NavPanelIdContext = React53.createContext(void 0);

// node_modules/@vkontakte/vkui/dist/components/Touch/Touch.js
var React54 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/touch.js
var coordX = (e) => {
  if (e.clientX != null) {
    return e.clientX;
  }
  return e.changedTouches && e.changedTouches[0].clientX;
};
var coordY = (e) => {
  if (e.clientY != null) {
    return e.clientY;
  }
  return e.changedTouches && e.changedTouches[0].clientY;
};
var touchEnabled = () => canUseDOM && "ontouchstart" in window;
function getSupportedEvents() {
  if (touchEnabled()) {
    return [
      "touchstart",
      "touchmove",
      "touchend",
      "touchcancel"
    ];
  }
  return [
    "mousedown",
    "mousemove",
    "mouseup",
    "mouseleave"
  ];
}
function rubber(offset3, dimension, resistanceRate, isAndroid) {
  if (isAndroid || offset3 < 0) {
    return offset3;
  }
  const offsettedResistance = offset3 * resistanceRate;
  return offsettedResistance * dimension / (offsettedResistance + dimension);
}

// node_modules/@vkontakte/vkui/dist/components/Touch/Touch.js
var Touch = (_param) => {
  var { onStart, onStartX, onStartY, onMove: _onMove, onMoveX, onMoveY, onLeave, onEnter, onEnd: _onEnd, onEndX, onEndY, onClickCapture, usePointerHover, slideThreshold = 5, useCapture = false, Component: Component3 = "div", getRootRef, noSlideClick = false, stopPropagation: stopPropagation3 = false } = _param, restProps = _object_without_properties(_param, [
    "onStart",
    "onStartX",
    "onStartY",
    "onMove",
    "onMoveX",
    "onMoveY",
    "onLeave",
    "onEnter",
    "onEnd",
    "onEndX",
    "onEndY",
    "onClickCapture",
    "usePointerHover",
    "slideThreshold",
    "useCapture",
    "Component",
    "getRootRef",
    "noSlideClick",
    "stopPropagation"
  ]);
  const { document: document2 } = useDOM();
  const events = React54.useMemo(getSupportedEvents, []);
  const didSlide = React54.useRef(false);
  const gesture = React54.useRef(null);
  const handle = (e, handlers) => {
    stopPropagation3 && e.stopPropagation();
    handlers.forEach((cb) => {
      var _gesture_current_startT, _gesture_current;
      var _gesture_current_startT_getTime;
      const duration = Date.now() - ((_gesture_current_startT_getTime = (_gesture_current = gesture.current) === null || _gesture_current === void 0 ? void 0 : (_gesture_current_startT = _gesture_current.startT) === null || _gesture_current_startT === void 0 ? void 0 : _gesture_current_startT.getTime()) !== null && _gesture_current_startT_getTime !== void 0 ? _gesture_current_startT_getTime : 0);
      cb && cb(_object_spread_props(_object_spread({}, gesture.current), {
        duration,
        originalEvent: e
      }));
    });
  };
  const enterHandler = useEventListener(usePointerHover ? "pointerenter" : "mouseenter", onEnter);
  const leaveHandler = useEventListener(usePointerHover ? "pointerleave" : "mouseleave", onLeave);
  const startHandler = useEventListener(events[0], (e) => {
    gesture.current = initGesture(coordX(e), coordY(e));
    handle(e, [
      onStart,
      onStartX,
      onStartY
    ]);
    subscribe(touchEnabled() ? (
      // see: #235, #1968, https://stackoverflow.com/a/45760014
      e.target
    ) : (
      // if pointer goes outside container.
      // Can be fixed by PointerEvents' setPointerCapture later
      document2
    ));
  }, {
    capture: useCapture,
    passive: false
  });
  const containerRef = useExternRef(getRootRef);
  useIsomorphicLayoutEffect(() => {
    const el = containerRef.current;
    if (el) {
      enterHandler.add(el);
      leaveHandler.add(el);
      startHandler.add(el);
    }
  }, [
    Component3
  ]);
  function onMove(e) {
    var _gesture_current;
    const { isPressed, isX, isY, startX = 0, startY = 0 } = (_gesture_current = gesture.current) !== null && _gesture_current !== void 0 ? _gesture_current : {};
    if (isPressed) {
      var _gesture_current1;
      const clientX = coordX(e);
      const clientY = coordY(e);
      const shiftX = clientX - startX;
      const shiftY = clientY - startY;
      const shiftXAbs = Math.abs(shiftX);
      const shiftYAbs = Math.abs(shiftY);
      if (!!e.touches && e.touches.length > 1) {
        return onEnd(e);
      }
      if (!isX && !isY) {
        const willBeX = shiftXAbs >= slideThreshold && shiftXAbs > shiftYAbs;
        const willBeY = shiftYAbs >= slideThreshold && shiftYAbs > shiftXAbs;
        const willBeSlidedX = willBeX && (!!onMoveX || !!_onMove);
        const willBeSlidedY = willBeY && (!!onMoveY || !!_onMove);
        if (gesture.current) {
          Object.assign(gesture.current, {
            isY: willBeY,
            isX: willBeX,
            isSlideX: willBeSlidedX,
            isSlideY: willBeSlidedY,
            isSlide: willBeSlidedX || willBeSlidedY
          });
        }
      }
      if ((_gesture_current1 = gesture.current) === null || _gesture_current1 === void 0 ? void 0 : _gesture_current1.isSlide) {
        Object.assign(gesture.current, {
          clientX,
          clientY,
          shiftX,
          shiftY,
          shiftXAbs,
          shiftYAbs
        });
        handle(e, [
          _onMove,
          gesture.current.isSlideX && onMoveX,
          gesture.current.isSlideY && onMoveY
        ]);
      }
    }
  }
  function onEnd(e) {
    var _gesture_current;
    const { isPressed, isSlide, isSlideX, isSlideY } = (_gesture_current = gesture.current) !== null && _gesture_current !== void 0 ? _gesture_current : {};
    if (isPressed) {
      handle(e, [
        _onEnd,
        isSlideY && onEndY,
        isSlideX && onEndX
      ]);
    }
    const isTouchEnabled = touchEnabled();
    if (isTouchEnabled && isSlide) {
      didSlide.current = false;
    } else {
      didSlide.current = Boolean(isSlide);
    }
    gesture.current = {};
    if (isTouchEnabled) {
      onLeave && onLeave(e);
    }
    unsubscribe();
  }
  const listenerParams = {
    capture: useCapture,
    passive: false
  };
  const listeners = [
    useEventListener(events[1], onMove, listenerParams),
    useEventListener(events[2], onEnd, listenerParams),
    useEventListener(events[3], onEnd, listenerParams)
  ];
  function subscribe(el) {
    if (el) {
      listeners.forEach((l) => l.add(el));
    }
  }
  function unsubscribe() {
    listeners.forEach((l) => l.remove());
  }
  const onDragStart = (e) => {
    const target = e.target;
    if (target.tagName === "A" || target.tagName === "IMG") {
      e.preventDefault();
    }
  };
  const postGestureClick = (e) => {
    if (!didSlide.current) {
      return onClickCapture && onClickCapture(e);
    }
    if (noSlideClick) {
      e.stopPropagation();
      e.preventDefault();
    } else {
      onClickCapture && onClickCapture(e);
    }
    didSlide.current = false;
  };
  return React54.createElement(Component3, _object_spread_props(_object_spread({}, restProps), {
    onDragStart,
    onClickCapture: postGestureClick,
    ref: containerRef
  }));
};
function initGesture(startX, startY) {
  return {
    startX,
    startY,
    startT: /* @__PURE__ */ new Date(),
    duration: 0,
    isPressed: true,
    isY: false,
    isX: false,
    isSlideX: false,
    isSlideY: false,
    isSlide: false,
    clientX: 0,
    clientY: 0,
    shiftX: 0,
    shiftY: 0,
    shiftXAbs: 0,
    shiftYAbs: 0
  };
}

// node_modules/@vkontakte/vkui/dist/lib/floating/functions.js
var React55 = __toESM(require_react());
function checkIsNotAutoPlacement(placement) {
  return !placement.startsWith("auto");
}
function getAutoPlacementAlign(placement) {
  const align = placement.replace(/auto-|auto/, "");
  return align === "start" || align === "end" ? align : null;
}
function convertFloatingDataToReactCSSProperties(strategy, x, y, initialWidth = "max-content", middlewareData) {
  const styles = {
    position: strategy,
    top: y,
    right: "auto",
    bottom: "auto",
    left: x
  };
  if (initialWidth !== null) {
    styles.width = initialWidth;
  }
  if (middlewareData) {
    const hide4 = middlewareData.hide;
    if (hide4 && hide4.referenceHidden) {
      styles["visibility"] = "hidden";
    }
  }
  return styles;
}
var getArrowCoordsByMiddlewareData = (middlewareData) => {
  const coords = {
    x: 0,
    y: 0
  };
  if (middlewareData.arrow) {
    const { x = 0, y = 0 } = middlewareData.arrow;
    coords.x = x;
    coords.y = y;
  }
  return coords;
};

// node_modules/@swc/helpers/esm/_array_with_holes.js
function _array_with_holes(arr) {
  if (Array.isArray(arr))
    return arr;
}

// node_modules/@swc/helpers/esm/_iterable_to_array_limit.js
function _iterable_to_array_limit(arr, i) {
  var _i = arr == null ? null : typeof Symbol !== "undefined" && arr[Symbol.iterator] || arr["@@iterator"];
  if (_i == null)
    return;
  var _arr = [];
  var _n = true;
  var _d = false;
  var _s, _e;
  try {
    for (_i = _i.call(arr); !(_n = (_s = _i.next()).done); _n = true) {
      _arr.push(_s.value);
      if (i && _arr.length === i)
        break;
    }
  } catch (err) {
    _d = true;
    _e = err;
  } finally {
    try {
      if (!_n && _i["return"] != null)
        _i["return"]();
    } finally {
      if (_d)
        throw _e;
    }
  }
  return _arr;
}

// node_modules/@swc/helpers/esm/_non_iterable_rest.js
function _non_iterable_rest() {
  throw new TypeError("Invalid attempt to destructure non-iterable instance.\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.");
}

// node_modules/@swc/helpers/esm/_sliced_to_array.js
function _sliced_to_array(arr, i) {
  return _array_with_holes(arr) || _iterable_to_array_limit(arr, i) || _unsupported_iterable_to_array(arr, i) || _non_iterable_rest();
}

// node_modules/@vkontakte/vkui-floating-ui/dom/dist/floating-ui.dom.mjs
function getCssDimensions(element) {
  var css = getComputedStyle2(element);
  var width = parseFloat(css.width) || 0;
  var height = parseFloat(css.height) || 0;
  var hasOffset = isHTMLElement(element);
  var offsetWidth = hasOffset ? element.offsetWidth : width;
  var offsetHeight = hasOffset ? element.offsetHeight : height;
  var shouldFallback = round(width) !== offsetWidth || round(height) !== offsetHeight;
  if (shouldFallback) {
    width = offsetWidth;
    height = offsetHeight;
  }
  return {
    width,
    height,
    $: shouldFallback
  };
}
function unwrapElement(element) {
  return !isElement(element) ? element.contextElement : element;
}
function getScale(element) {
  var domElement = unwrapElement(element);
  if (!isHTMLElement(domElement)) {
    return createCoords(1);
  }
  var rect = domElement.getBoundingClientRect();
  var _getCssDimensions = getCssDimensions(domElement), width = _getCssDimensions.width, height = _getCssDimensions.height, $ = _getCssDimensions.$;
  var x = ($ ? round(rect.width) : rect.width) / width;
  var y = ($ ? round(rect.height) : rect.height) / height;
  if (!x || !Number.isFinite(x)) {
    x = 1;
  }
  if (!y || !Number.isFinite(y)) {
    y = 1;
  }
  return {
    x,
    y
  };
}
var noOffsets = createCoords(0);
function getVisualOffsets(element) {
  var win = getWindow(element);
  if (!isWebKit() || !win.visualViewport) {
    return noOffsets;
  }
  return {
    x: win.visualViewport.offsetLeft,
    y: win.visualViewport.offsetTop
  };
}
function shouldAddVisualOffsets(element, isFixed, floatingOffsetParent) {
  if (isFixed === void 0) {
    isFixed = false;
  }
  if (!floatingOffsetParent || isFixed && floatingOffsetParent !== getWindow(element)) {
    return false;
  }
  return isFixed;
}
function getBoundingClientRect2(element, includeScale, isFixedStrategy, offsetParent) {
  if (includeScale === void 0) {
    includeScale = false;
  }
  if (isFixedStrategy === void 0) {
    isFixedStrategy = false;
  }
  var clientRect = element.getBoundingClientRect();
  var domElement = unwrapElement(element);
  var scale = createCoords(1);
  if (includeScale) {
    if (offsetParent) {
      if (isElement(offsetParent)) {
        scale = getScale(offsetParent);
      }
    } else {
      scale = getScale(element);
    }
  }
  var visualOffsets = shouldAddVisualOffsets(domElement, isFixedStrategy, offsetParent) ? getVisualOffsets(domElement) : createCoords(0);
  var x = (clientRect.left + visualOffsets.x) / scale.x;
  var y = (clientRect.top + visualOffsets.y) / scale.y;
  var width = clientRect.width / scale.x;
  var height = clientRect.height / scale.y;
  if (domElement) {
    var win = getWindow(domElement);
    var offsetWin = offsetParent && isElement(offsetParent) ? getWindow(offsetParent) : offsetParent;
    var currentIFrame = win.frameElement;
    while (currentIFrame && offsetParent && offsetWin !== win) {
      var iframeScale = getScale(currentIFrame);
      var iframeRect = currentIFrame.getBoundingClientRect();
      var css = getComputedStyle2(currentIFrame);
      var left = iframeRect.left + (currentIFrame.clientLeft + parseFloat(css.paddingLeft)) * iframeScale.x;
      var top = iframeRect.top + (currentIFrame.clientTop + parseFloat(css.paddingTop)) * iframeScale.y;
      x *= iframeScale.x;
      y *= iframeScale.y;
      width *= iframeScale.x;
      height *= iframeScale.y;
      x += left;
      y += top;
      currentIFrame = getWindow(currentIFrame).frameElement;
    }
  }
  return rectToClientRect({
    width,
    height,
    x,
    y
  });
}
var topLayerSelectors = [
  ":popover-open",
  ":modal"
];
function topLayer(floating) {
  var isTopLayer = false;
  var x = 0;
  var y = 0;
  function setIsTopLayer(selector) {
    try {
      isTopLayer = isTopLayer || floating.matches(selector);
    } catch (e) {
    }
  }
  topLayerSelectors.forEach(function(selector) {
    setIsTopLayer(selector);
  });
  if (isTopLayer) {
    var containingBlock = getContainingBlock(floating);
    if (containingBlock) {
      var rect = containingBlock.getBoundingClientRect();
      x = rect.x;
      y = rect.y;
    }
  }
  return [
    isTopLayer,
    x,
    y
  ];
}
function convertOffsetParentRelativeRectToViewportRelativeRect(_ref) {
  var elements = _ref.elements, rect = _ref.rect, offsetParent = _ref.offsetParent, strategy = _ref.strategy;
  var documentElement = getDocumentElement(offsetParent);
  var _$_ref = _sliced_to_array(elements ? topLayer(elements.floating) : [
    false
  ], 1), isTopLayer = _$_ref[0];
  if (offsetParent === documentElement || isTopLayer) {
    return rect;
  }
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var scale = createCoords(1);
  var offsets = createCoords(0);
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && strategy !== "fixed") {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isHTMLElement(offsetParent)) {
      var offsetRect = getBoundingClientRect2(offsetParent);
      scale = getScale(offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    }
  }
  return {
    width: rect.width * scale.x,
    height: rect.height * scale.y,
    x: rect.x * scale.x - scroll.scrollLeft * scale.x + offsets.x,
    y: rect.y * scale.y - scroll.scrollTop * scale.y + offsets.y
  };
}
function getClientRects(element) {
  return Array.from(element.getClientRects());
}
function getWindowScrollBarX(element) {
  return getBoundingClientRect2(getDocumentElement(element)).left + getNodeScroll(element).scrollLeft;
}
function getDocumentRect(element) {
  var html = getDocumentElement(element);
  var scroll = getNodeScroll(element);
  var body = element.ownerDocument.body;
  var width = max(html.scrollWidth, html.clientWidth, body.scrollWidth, body.clientWidth);
  var height = max(html.scrollHeight, html.clientHeight, body.scrollHeight, body.clientHeight);
  var x = -scroll.scrollLeft + getWindowScrollBarX(element);
  var y = -scroll.scrollTop;
  if (getComputedStyle2(body).direction === "rtl") {
    x += max(html.clientWidth, body.clientWidth) - width;
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getViewportRect(element, strategy) {
  var win = getWindow(element);
  var html = getDocumentElement(element);
  var visualViewport = win.visualViewport;
  var width = html.clientWidth;
  var height = html.clientHeight;
  var x = 0;
  var y = 0;
  if (visualViewport) {
    width = visualViewport.width;
    height = visualViewport.height;
    var visualViewportBased = isWebKit();
    if (!visualViewportBased || visualViewportBased && strategy === "fixed") {
      x = visualViewport.offsetLeft;
      y = visualViewport.offsetTop;
    }
  }
  return {
    width,
    height,
    x,
    y
  };
}
function getInnerBoundingClientRect(element, strategy) {
  var clientRect = getBoundingClientRect2(element, true, strategy === "fixed");
  var top = clientRect.top + element.clientTop;
  var left = clientRect.left + element.clientLeft;
  var scale = isHTMLElement(element) ? getScale(element) : createCoords(1);
  var width = element.clientWidth * scale.x;
  var height = element.clientHeight * scale.y;
  var x = left * scale.x;
  var y = top * scale.y;
  return {
    width,
    height,
    x,
    y
  };
}
function getClientRectFromClippingAncestor(element, clippingAncestor, strategy) {
  var rect;
  if (clippingAncestor === "viewport") {
    rect = getViewportRect(element, strategy);
  } else if (clippingAncestor === "document") {
    rect = getDocumentRect(getDocumentElement(element));
  } else if (isElement(clippingAncestor)) {
    rect = getInnerBoundingClientRect(clippingAncestor, strategy);
  } else {
    var visualOffsets = getVisualOffsets(element);
    rect = _object_spread_props(_object_spread({}, clippingAncestor), {
      x: clippingAncestor.x - visualOffsets.x,
      y: clippingAncestor.y - visualOffsets.y
    });
  }
  return rectToClientRect(rect);
}
function hasFixedPositionAncestor(element, stopNode) {
  var parentNode = getParentNode(element);
  if (parentNode === stopNode || !isElement(parentNode) || isLastTraversableNode(parentNode)) {
    return false;
  }
  return getComputedStyle2(parentNode).position === "fixed" || hasFixedPositionAncestor(parentNode, stopNode);
}
function getClippingElementAncestors(element, cache) {
  var cachedResult = cache.get(element);
  if (cachedResult) {
    return cachedResult;
  }
  var result = getOverflowAncestors(element, [], false).filter(function(el) {
    return isElement(el) && getNodeName(el) !== "body";
  });
  var currentContainingBlockComputedStyle = null;
  var elementIsFixed = getComputedStyle2(element).position === "fixed";
  var currentNode = elementIsFixed ? getParentNode(element) : element;
  while (isElement(currentNode) && !isLastTraversableNode(currentNode)) {
    var computedStyle = getComputedStyle2(currentNode);
    var currentNodeIsContaining = isContainingBlock(currentNode);
    if (!currentNodeIsContaining && computedStyle.position === "fixed") {
      currentContainingBlockComputedStyle = null;
    }
    var shouldDropCurrentNode = elementIsFixed ? !currentNodeIsContaining && !currentContainingBlockComputedStyle : !currentNodeIsContaining && computedStyle.position === "static" && !!currentContainingBlockComputedStyle && [
      "absolute",
      "fixed"
    ].includes(currentContainingBlockComputedStyle.position) || isOverflowElement(currentNode) && !currentNodeIsContaining && hasFixedPositionAncestor(element, currentNode);
    if (shouldDropCurrentNode) {
      result = result.filter(function(ancestor) {
        return ancestor !== currentNode;
      });
    } else {
      currentContainingBlockComputedStyle = computedStyle;
    }
    currentNode = getParentNode(currentNode);
  }
  cache.set(element, result);
  return result;
}
function getClippingRect(_ref) {
  var element = _ref.element, boundary = _ref.boundary, rootBoundary = _ref.rootBoundary, strategy = _ref.strategy;
  var elementClippingAncestors = boundary === "clippingAncestors" ? getClippingElementAncestors(element, this._c) : [].concat(boundary);
  var clippingAncestors = _to_consumable_array(elementClippingAncestors).concat([
    rootBoundary
  ]);
  var firstClippingAncestor = clippingAncestors[0];
  var clippingRect = clippingAncestors.reduce(function(accRect, clippingAncestor) {
    var rect = getClientRectFromClippingAncestor(element, clippingAncestor, strategy);
    accRect.top = max(rect.top, accRect.top);
    accRect.right = min(rect.right, accRect.right);
    accRect.bottom = min(rect.bottom, accRect.bottom);
    accRect.left = max(rect.left, accRect.left);
    return accRect;
  }, getClientRectFromClippingAncestor(element, firstClippingAncestor, strategy));
  return {
    width: clippingRect.right - clippingRect.left,
    height: clippingRect.bottom - clippingRect.top,
    x: clippingRect.left,
    y: clippingRect.top
  };
}
function getDimensions(element) {
  var _getCssDimensions = getCssDimensions(element), width = _getCssDimensions.width, height = _getCssDimensions.height;
  return {
    width,
    height
  };
}
function getRectRelativeToOffsetParent(element, offsetParent, strategy, floating) {
  var isOffsetParentAnElement = isHTMLElement(offsetParent);
  var documentElement = getDocumentElement(offsetParent);
  var isFixed = strategy === "fixed";
  var rect = getBoundingClientRect2(element, true, isFixed, offsetParent);
  var scroll = {
    scrollLeft: 0,
    scrollTop: 0
  };
  var offsets = createCoords(0);
  if (isOffsetParentAnElement || !isOffsetParentAnElement && !isFixed) {
    if (getNodeName(offsetParent) !== "body" || isOverflowElement(documentElement)) {
      scroll = getNodeScroll(offsetParent);
    }
    if (isOffsetParentAnElement) {
      var offsetRect = getBoundingClientRect2(offsetParent, true, isFixed, offsetParent);
      offsets.x = offsetRect.x + offsetParent.clientLeft;
      offsets.y = offsetRect.y + offsetParent.clientTop;
    } else if (documentElement) {
      offsets.x = getWindowScrollBarX(documentElement);
    }
  }
  var x = rect.left + scroll.scrollLeft - offsets.x;
  var y = rect.top + scroll.scrollTop - offsets.y;
  var _topLayer = _sliced_to_array(topLayer(floating), 3), isTopLayer = _topLayer[0], topLayerX = _topLayer[1], topLayerY = _topLayer[2];
  if (isTopLayer) {
    x += topLayerX;
    y += topLayerY;
    if (isOffsetParentAnElement) {
      x += offsetParent.clientLeft;
      y += offsetParent.clientTop;
    }
  }
  return {
    x,
    y,
    width: rect.width,
    height: rect.height
  };
}
function getTrueOffsetParent(element, polyfill) {
  if (!isHTMLElement(element) || getComputedStyle2(element).position === "fixed") {
    return null;
  }
  if (polyfill) {
    return polyfill(element);
  }
  return element.offsetParent;
}
function getOffsetParent(element, polyfill) {
  var window2 = getWindow(element);
  if (!isHTMLElement(element)) {
    return window2;
  }
  var offsetParent = getTrueOffsetParent(element, polyfill);
  while (offsetParent && isTableElement(offsetParent) && getComputedStyle2(offsetParent).position === "static") {
    offsetParent = getTrueOffsetParent(offsetParent, polyfill);
  }
  if (offsetParent && (getNodeName(offsetParent) === "html" || getNodeName(offsetParent) === "body" && getComputedStyle2(offsetParent).position === "static" && !isContainingBlock(offsetParent))) {
    return window2;
  }
  return offsetParent || getContainingBlock(element) || window2;
}
var getElementRects = function() {
  var _ref = _async_to_generator(function(data) {
    var getOffsetParentFn, getDimensionsFn, _tmp, _tmp1, _tmp2;
    return __generator(this, function(_state) {
      switch (_state.label) {
        case 0:
          getOffsetParentFn = this.getOffsetParent || getOffsetParent;
          getDimensionsFn = this.getDimensions;
          _tmp = {};
          _tmp1 = [
            data.reference
          ];
          return [
            4,
            getOffsetParentFn(data.floating)
          ];
        case 1:
          _tmp.reference = getRectRelativeToOffsetParent.apply(void 0, _tmp1.concat([
            _state.sent(),
            data.strategy,
            data.floating
          ]));
          _tmp2 = [
            {
              x: 0,
              y: 0
            }
          ];
          return [
            4,
            getDimensionsFn(data.floating)
          ];
        case 2:
          return [
            2,
            (_tmp.floating = _object_spread.apply(void 0, _tmp2.concat([
              _state.sent()
            ])), _tmp)
          ];
      }
    });
  });
  return function getElementRects2(data) {
    return _ref.apply(this, arguments);
  };
}();
function isRTL(element) {
  return getComputedStyle2(element).direction === "rtl";
}
var platform2 = {
  convertOffsetParentRelativeRectToViewportRelativeRect,
  getDocumentElement,
  getClippingRect,
  getOffsetParent,
  getElementRects,
  getClientRects,
  getDimensions,
  getScale,
  isElement,
  isRTL
};
function observeMove(element, onMove) {
  var io = null;
  var timeoutId;
  var root = getDocumentElement(element);
  function cleanup() {
    var _io;
    clearTimeout(timeoutId);
    (_io = io) == null || _io.disconnect();
    io = null;
  }
  function refresh(skip, threshold) {
    if (skip === void 0) {
      skip = false;
    }
    if (threshold === void 0) {
      threshold = 1;
    }
    cleanup();
    var _element_getBoundingClientRect = element.getBoundingClientRect(), left = _element_getBoundingClientRect.left, top = _element_getBoundingClientRect.top, width = _element_getBoundingClientRect.width, height = _element_getBoundingClientRect.height;
    if (!skip) {
      onMove();
    }
    if (!width || !height) {
      return;
    }
    var insetTop = floor(top);
    var insetRight = floor(root.clientWidth - (left + width));
    var insetBottom = floor(root.clientHeight - (top + height));
    var insetLeft = floor(left);
    var rootMargin = -insetTop + "px " + -insetRight + "px " + -insetBottom + "px " + -insetLeft + "px";
    var options = {
      rootMargin,
      threshold: max(0, min(1, threshold)) || 1
    };
    var isFirstUpdate = true;
    function handleObserve(entries) {
      var ratio = entries[0].intersectionRatio;
      if (ratio !== threshold) {
        if (!isFirstUpdate) {
          return refresh();
        }
        if (!ratio) {
          timeoutId = setTimeout(function() {
            refresh(false, 1e-7);
          }, 100);
        } else {
          refresh(false, ratio);
        }
      }
      isFirstUpdate = false;
    }
    try {
      io = new IntersectionObserver(handleObserve, _object_spread_props(_object_spread({}, options), {
        // Handle <iframe>s
        root: root.ownerDocument
      }));
    } catch (e) {
      io = new IntersectionObserver(handleObserve, options);
    }
    io.observe(element);
  }
  refresh(true);
  return cleanup;
}
function autoUpdate(reference, floating, update, options) {
  if (options === void 0) {
    options = {};
  }
  var _options_ancestorScroll = options.ancestorScroll, ancestorScroll = _options_ancestorScroll === void 0 ? true : _options_ancestorScroll, _options_ancestorResize = options.ancestorResize, ancestorResize = _options_ancestorResize === void 0 ? true : _options_ancestorResize, _options_elementResize = options.elementResize, elementResize = _options_elementResize === void 0 ? typeof ResizeObserver === "function" : _options_elementResize, _options_layoutShift = options.layoutShift, layoutShift = _options_layoutShift === void 0 ? typeof IntersectionObserver === "function" : _options_layoutShift, _options_animationFrame = options.animationFrame, animationFrame = _options_animationFrame === void 0 ? false : _options_animationFrame;
  var referenceEl = unwrapElement(reference);
  var ancestors = ancestorScroll || ancestorResize ? _to_consumable_array(referenceEl ? getOverflowAncestors(referenceEl) : []).concat(_to_consumable_array(getOverflowAncestors(floating))) : [];
  ancestors.forEach(function(ancestor) {
    ancestorScroll && ancestor.addEventListener("scroll", update, {
      passive: true
    });
    ancestorResize && ancestor.addEventListener("resize", update);
  });
  var cleanupIo = referenceEl && layoutShift ? observeMove(referenceEl, update) : null;
  var reobserveFrame = -1;
  var resizeObserver = null;
  if (elementResize) {
    resizeObserver = new ResizeObserver(function(_ref) {
      var _$_ref = _sliced_to_array(_ref, 1), firstEntry = _$_ref[0];
      if (firstEntry && firstEntry.target === referenceEl && resizeObserver) {
        resizeObserver.unobserve(floating);
        cancelAnimationFrame(reobserveFrame);
        reobserveFrame = requestAnimationFrame(function() {
          var _resizeObserver;
          (_resizeObserver = resizeObserver) == null || _resizeObserver.observe(floating);
        });
      }
      update();
    });
    if (referenceEl && !animationFrame) {
      resizeObserver.observe(referenceEl);
    }
    resizeObserver.observe(floating);
  }
  var frameId;
  var prevRefRect = animationFrame ? getBoundingClientRect2(reference) : null;
  if (animationFrame) {
    frameLoop();
  }
  function frameLoop() {
    var nextRefRect = getBoundingClientRect2(reference);
    if (prevRefRect && (nextRefRect.x !== prevRefRect.x || nextRefRect.y !== prevRefRect.y || nextRefRect.width !== prevRefRect.width || nextRefRect.height !== prevRefRect.height)) {
      update();
    }
    prevRefRect = nextRefRect;
    frameId = requestAnimationFrame(frameLoop);
  }
  update();
  return function() {
    var _resizeObserver2;
    ancestors.forEach(function(ancestor) {
      ancestorScroll && ancestor.removeEventListener("scroll", update);
      ancestorResize && ancestor.removeEventListener("resize", update);
    });
    cleanupIo == null || cleanupIo();
    (_resizeObserver2 = resizeObserver) == null || _resizeObserver2.disconnect();
    resizeObserver = null;
    if (animationFrame) {
      cancelAnimationFrame(frameId);
    }
  };
}
var autoPlacement3 = autoPlacement;
var shift3 = shift;
var flip3 = flip;
var size3 = size;
var hide3 = hide;
var arrow2 = arrow;
var computePosition2 = function(reference, floating, options) {
  var cache = /* @__PURE__ */ new Map();
  var mergedOptions = _object_spread({
    platform: platform2
  }, options);
  var platformWithCache = _object_spread_props(_object_spread({}, mergedOptions.platform), {
    _c: cache
  });
  return computePosition(reference, floating, _object_spread_props(_object_spread({}, mergedOptions), {
    platform: platformWithCache
  }));
};

// node_modules/@vkontakte/vkui-floating-ui/react-dom/dist/floating-ui.react-dom.mjs
var React56 = __toESM(require_react(), 1);
var import_react3 = __toESM(require_react(), 1);
var ReactDOM = __toESM(require_react_dom(), 1);
var arrow3 = function(options) {
  var isRef = function isRef2(value) {
    return {}.hasOwnProperty.call(value, "current");
  };
  return {
    name: "arrow",
    options,
    fn: function fn(state) {
      var _ref = typeof options === "function" ? options(state) : options, element = _ref.element, padding = _ref.padding;
      if (element && isRef(element)) {
        if (element.current != null) {
          return arrow2({
            element: element.current,
            padding
          }).fn(state);
        }
        return {};
      }
      if (element) {
        return arrow2({
          element,
          padding
        }).fn(state);
      }
      return {};
    }
  };
};
var index = typeof document !== "undefined" ? import_react3.useLayoutEffect : import_react3.useEffect;
function deepEqual(a, b) {
  if (a === b) {
    return true;
  }
  if ((typeof a === "undefined" ? "undefined" : _type_of(a)) !== (typeof b === "undefined" ? "undefined" : _type_of(b))) {
    return false;
  }
  if (typeof a === "function" && a.toString() === b.toString()) {
    return true;
  }
  var length;
  var i;
  var keys;
  if (a && b && typeof a === "object") {
    if (Array.isArray(a)) {
      length = a.length;
      if (length !== b.length)
        return false;
      for (i = length; i-- !== 0; ) {
        if (!deepEqual(a[i], b[i])) {
          return false;
        }
      }
      return true;
    }
    keys = Object.keys(a);
    length = keys.length;
    if (length !== Object.keys(b).length) {
      return false;
    }
    for (i = length; i-- !== 0; ) {
      if (!{}.hasOwnProperty.call(b, keys[i])) {
        return false;
      }
    }
    for (i = length; i-- !== 0; ) {
      var key = keys[i];
      if (key === "_owner" && a.$$typeof) {
        continue;
      }
      if (!deepEqual(a[key], b[key])) {
        return false;
      }
    }
    return true;
  }
  return a !== a && b !== b;
}
function getDPR(element) {
  if (typeof window === "undefined") {
    return 1;
  }
  var win = element.ownerDocument.defaultView || window;
  return win.devicePixelRatio || 1;
}
function roundByDPR(element, value) {
  var dpr = getDPR(element);
  return Math.round(value * dpr) / dpr;
}
function useLatestRef(value) {
  var ref = React56.useRef(value);
  index(function() {
    ref.current = value;
  });
  return ref;
}
function useFloating(options) {
  if (options === void 0) {
    options = {};
  }
  var _options_placement = options.placement, placement = _options_placement === void 0 ? "bottom" : _options_placement, _options_strategy = options.strategy, strategy = _options_strategy === void 0 ? "absolute" : _options_strategy, _options_middleware = options.middleware, middleware = _options_middleware === void 0 ? [] : _options_middleware, platform3 = options.platform, tmp = options.elements, _ref = tmp === void 0 ? {} : tmp, externalReference = _ref.reference, externalFloating = _ref.floating, _options_transform = options.transform, transform = _options_transform === void 0 ? true : _options_transform, whileElementsMounted2 = options.whileElementsMounted, open = options.open;
  var _React_useState = _sliced_to_array(React56.useState({
    x: 0,
    y: 0,
    strategy,
    placement,
    middlewareData: {},
    isPositioned: false
  }), 2), data = _React_useState[0], setData = _React_useState[1];
  var _React_useState1 = _sliced_to_array(React56.useState(middleware), 2), latestMiddleware = _React_useState1[0], setLatestMiddleware = _React_useState1[1];
  if (!deepEqual(latestMiddleware, middleware)) {
    setLatestMiddleware(middleware);
  }
  var _React_useState2 = _sliced_to_array(React56.useState(null), 2), _reference = _React_useState2[0], _setReference = _React_useState2[1];
  var _React_useState3 = _sliced_to_array(React56.useState(null), 2), _floating = _React_useState3[0], _setFloating = _React_useState3[1];
  var setReference = React56.useCallback(function(node) {
    if (node !== referenceRef.current) {
      referenceRef.current = node;
      _setReference(node);
    }
  }, []);
  var setFloating = React56.useCallback(function(node) {
    if (node !== floatingRef.current) {
      floatingRef.current = node;
      _setFloating(node);
    }
  }, []);
  var referenceEl = externalReference || _reference;
  var floatingEl = externalFloating || _floating;
  var referenceRef = React56.useRef(null);
  var floatingRef = React56.useRef(null);
  var dataRef = React56.useRef(data);
  var hasWhileElementsMounted = whileElementsMounted2 != null;
  var whileElementsMountedRef = useLatestRef(whileElementsMounted2);
  var platformRef = useLatestRef(platform3);
  var update = React56.useCallback(function() {
    if (!referenceRef.current || !floatingRef.current) {
      return;
    }
    var config = {
      placement,
      strategy,
      middleware: latestMiddleware
    };
    if (platformRef.current) {
      config.platform = platformRef.current;
    }
    computePosition2(referenceRef.current, floatingRef.current, config).then(function(data2) {
      var fullData = _object_spread_props(_object_spread({}, data2), {
        isPositioned: true
      });
      if (isMountedRef.current && !deepEqual(dataRef.current, fullData)) {
        dataRef.current = fullData;
        ReactDOM.flushSync(function() {
          setData(fullData);
        });
      }
    });
  }, [
    latestMiddleware,
    placement,
    strategy,
    platformRef
  ]);
  index(function() {
    if (open === false && dataRef.current.isPositioned) {
      dataRef.current.isPositioned = false;
      setData(function(data2) {
        return _object_spread_props(_object_spread({}, data2), {
          isPositioned: false
        });
      });
    }
  }, [
    open
  ]);
  var isMountedRef = React56.useRef(false);
  index(function() {
    isMountedRef.current = true;
    return function() {
      isMountedRef.current = false;
    };
  }, []);
  index(function() {
    if (referenceEl)
      referenceRef.current = referenceEl;
    if (floatingEl)
      floatingRef.current = floatingEl;
    if (referenceEl && floatingEl) {
      if (whileElementsMountedRef.current) {
        return whileElementsMountedRef.current(referenceEl, floatingEl, update);
      }
      update();
    }
  }, [
    referenceEl,
    floatingEl,
    update,
    whileElementsMountedRef,
    hasWhileElementsMounted
  ]);
  var refs = React56.useMemo(function() {
    return {
      reference: referenceRef,
      floating: floatingRef,
      setReference,
      setFloating
    };
  }, [
    setReference,
    setFloating
  ]);
  var elements = React56.useMemo(function() {
    return {
      reference: referenceEl,
      floating: floatingEl
    };
  }, [
    referenceEl,
    floatingEl
  ]);
  var floatingStyles = React56.useMemo(function() {
    var initialStyles = {
      position: strategy,
      left: 0,
      top: 0
    };
    if (!elements.floating) {
      return initialStyles;
    }
    var x = roundByDPR(elements.floating, data.x);
    var y = roundByDPR(elements.floating, data.y);
    if (transform) {
      return _object_spread(_object_spread_props(_object_spread({}, initialStyles), {
        transform: "translate(" + x + "px, " + y + "px)"
      }), getDPR(elements.floating) >= 1.5 && {
        willChange: "transform"
      });
    }
    return {
      position: strategy,
      left: x,
      top: y
    };
  }, [
    strategy,
    transform,
    elements.floating,
    data.x,
    data.y
  ]);
  return React56.useMemo(function() {
    return _object_spread_props(_object_spread({}, data), {
      update,
      refs,
      elements,
      floatingStyles
    });
  }, [
    data,
    update,
    refs,
    elements,
    floatingStyles
  ]);
}

// node_modules/@vkontakte/vkui/dist/lib/floating/customResizeObserver.js
var defaultIframeStyles = {
  position: "absolute",
  left: "0",
  top: "0",
  zIndex: "-1",
  width: "100%",
  height: "100%",
  pointerEvents: "none",
  opacity: "0"
};
var CustomResizeObserver = class {
  observe(element) {
    if (isPositioned(element)) {
      return this.observeUsingIframe(element);
    }
    return this.observeUsingMutationObserver(element);
  }
  appendToTheDOM() {
    for (let record of this.records) {
      record.target.appendChild(record.iframe);
    }
    for (let record of this.records) {
      if (record.iframe.contentWindow) {
        record.iframe.contentWindow.addEventListener("resize", this.updateFunction);
      }
    }
  }
  observeUsingIframe(element) {
    const iframe = element.ownerDocument.createElement("iframe");
    iframe.src = "javascript:void(0)";
    iframe.ariaHidden = "true";
    iframe.tabIndex = -1;
    Object.assign(iframe.style, defaultIframeStyles);
    this.records.push({
      target: element,
      iframe
    });
  }
  observeUsingMutationObserver(element) {
    if (!this.mutationObserverFallback) {
      this.mutationObserverFallback = new MutationObserver(this.updateFunction);
    }
    this.mutationObserverFallback.observe(element, {
      childList: true,
      subtree: true
    });
  }
  disconnect() {
    this.records.map(({ target, iframe }) => {
      if (iframe.contentWindow) {
        iframe.contentWindow.removeEventListener("resize", this.updateFunction);
      }
      target.removeChild(iframe);
    });
    this.records = [];
    if (this.mutationObserverFallback) {
      this.mutationObserverFallback.disconnect();
    }
    this.mutationObserverFallback = null;
  }
  constructor(updateFunction) {
    _define_property(this, "updateFunction", void 0);
    _define_property(this, "records", void 0);
    _define_property(this, "mutationObserverFallback", void 0);
    this.updateFunction = updateFunction;
    this.records = [];
    this.mutationObserverFallback = null;
    this.updateFunction = updateFunction;
  }
};
function isPositioned(element) {
  return getComputedStyle(element).position !== "static";
}

// node_modules/@vkontakte/vkui/dist/lib/floating/adapters.js
var defaultOptions = {
  ancestorScroll: true,
  ancestorResize: true,
  // По умолчанию отключаем, т.к. навешивать `CustomResizeObserver` может быть дорого.
  // В `autoUpdateLib` по умолчанию опция включена. Там используется ResizeObserver, но и он не менее дорогостоящий.
  // https://github.com/floating-ui/floating-ui/blob/0a34fe9cc2c7483976785a71bd0777cd7c3f2a6a/packages/dom/src/autoUpdate.ts#L6-L33
  elementResize: false,
  animationFrame: false
};
function autoUpdateFloatingElement(reference, floating, update, options = defaultOptions) {
  const { elementResize = false } = options, restOptions = _object_without_properties(options, [
    "elementResize"
  ]);
  const canUseResizeObserver = window.ResizeObserver !== void 0;
  const autoUpdateLibDisposer = autoUpdate(reference, floating, update, _object_spread_props(_object_spread({}, restOptions), {
    elementResize: elementResize && canUseResizeObserver
  }));
  let observer = null;
  if (elementResize && !canUseResizeObserver) {
    observer = new CustomResizeObserver(update);
    if (isHTMLElement(reference)) {
      observer.observe(reference);
    }
    observer.observe(floating);
    observer.appendToTheDOM();
  }
  return () => {
    if (observer) {
      observer.disconnect();
      observer = null;
    }
    autoUpdateLibDisposer();
  };
}

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingMiddlewaresBootstrap/index.js
var React57 = __toESM(require_react());
var useFloatingMiddlewaresBootstrap = ({ placement = "bottom-start", arrowRef = null, arrow: arrow4, arrowHeight, arrowPadding, sameWidth, offsetByMainAxis = 0, offsetByCrossAxis = 0, customMiddlewares, hideWhenReferenceHidden }) => {
  return React57.useMemo(() => {
    const isNotAutoPlacement = checkIsNotAutoPlacement(placement);
    const middlewares = [
      offset({
        crossAxis: offsetByCrossAxis,
        mainAxis: arrow4 && arrowHeight ? offsetByMainAxis + arrowHeight : offsetByMainAxis
      })
    ];
    if (isNotAutoPlacement) {
      middlewares.push(flip3({
        fallbackAxisSideDirection: "start"
      }));
    } else {
      middlewares.push(autoPlacement3({
        alignment: getAutoPlacementAlign(placement)
      }));
    }
    middlewares.push(shift3());
    if (sameWidth) {
      middlewares.push(size3({
        apply({ rects, elements }) {
          Object.assign(elements.floating.style, {
            width: `${rects.reference.width}px`
          });
        }
      }));
    }
    if (customMiddlewares) {
      middlewares.push(...customMiddlewares);
    }
    if (arrow4) {
      middlewares.push(arrow3({
        element: arrowRef,
        padding: arrowPadding
      }));
    }
    if (hideWhenReferenceHidden) {
      middlewares.push(hide3());
    }
    return {
      middlewares,
      strictPlacement: isNotAutoPlacement ? placement : void 0
    };
  }, [
    offsetByCrossAxis,
    arrowRef,
    arrow4,
    arrowHeight,
    arrowPadding,
    offsetByMainAxis,
    sameWidth,
    customMiddlewares,
    placement,
    hideWhenReferenceHidden
  ]);
};

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useFloatingWithInteractions.js
var React61 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useEnsuredControl.js
var React58 = __toESM(require_react());
function useEnsuredControl(_param) {
  var { onChange: onChangeProp, disabled } = _param, props = _object_without_properties(_param, [
    "onChange",
    "disabled"
  ]);
  const [value, onChangeValue] = useCustomEnsuredControl(props);
  const onChange = React58.useCallback((e) => {
    if (disabled) {
      return;
    }
    onChangeValue(e.target.value);
    onChangeProp && onChangeProp(e);
  }, [
    onChangeValue,
    onChangeProp,
    disabled
  ]);
  return [
    value,
    onChange
  ];
}
function useCustomEnsuredControl({ value, defaultValue, disabled, onChange: onChangeProp }) {
  const isControlled = value !== void 0;
  const [localValue, setLocalValue] = React58.useState(defaultValue);
  const preservedControlledValueRef = React58.useRef();
  useIsomorphicLayoutEffect(() => {
    preservedControlledValueRef.current = value;
  });
  const onChange = React58.useCallback((nextValue) => {
    if (disabled) {
      return;
    }
    if (isFunction(nextValue)) {
      if (!isControlled) {
        setLocalValue((prevValue) => {
          const resolvedValue = nextValue(prevValue);
          if (onChangeProp) {
            onChangeProp(resolvedValue);
          }
          return resolvedValue;
        });
      } else if (onChangeProp) {
        const resolvedValue = nextValue(preservedControlledValueRef.current);
        onChangeProp(resolvedValue);
      }
    } else {
      if (onChangeProp) {
        onChangeProp(nextValue);
      }
      if (!isControlled) {
        setLocalValue(nextValue);
      }
    }
  }, [
    disabled,
    isControlled,
    onChangeProp
  ]);
  return [
    isControlled ? value : localValue,
    onChange
  ];
}

// node_modules/@vkontakte/vkui/dist/hooks/useGlobalOnClickOutside.js
var React59 = __toESM(require_react());
var useGlobalOnClickOutside = (callback, ...refs) => {
  const { document: document2 } = useDOM();
  useIsomorphicLayoutEffect(() => {
    const someRefNotNull = refs.some((ref) => ref && ref.current !== null);
    if (!document2 || !someRefNotNull) {
      return;
    }
    const handleClick = (event) => {
      const targetEl = event.target;
      const someRefHasTargetEl = isElement(targetEl) && refs.some((ref) => ref && ref.current && ref.current.contains(targetEl));
      if (!someRefHasTargetEl) {
        callback(event);
      }
    };
    document2.addEventListener("click", handleClick, {
      passive: true,
      capture: true
    });
    return () => {
      document2.removeEventListener("click", handleClick, true);
    };
  }, [
    document2,
    callback,
    ...refs
  ]);
};

// node_modules/@vkontakte/vkui/dist/hooks/useStableCallback.js
var React60 = __toESM(require_react());
function useStableCallback(fn) {
  const ref = React60.useRef(fn);
  useIsomorphicLayoutEffect(() => {
    ref.current = fn;
  });
  return React60.useRef((...args) => (0, ref.current)(...args)).current;
}

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/constants.js
var DEFAULT_TRIGGER = "click";

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useResolveTriggerType.js
var useResolveTriggerType = (triggerProp) => (typeof triggerProp === "string" ? [
  triggerProp
] : triggerProp).reduce((result, trigger) => {
  switch (trigger) {
    case "click":
      result.triggerOnClick = true;
      return result;
    case "hover":
      result.triggerOnHover = true;
      return result;
    case "focus":
      result.triggerOnFocus = true;
      return result;
    case "manual":
      return result;
  }
}, {
  triggerOnFocus: false,
  triggerOnClick: false,
  triggerOnHover: false
});

// node_modules/@vkontakte/vkui/dist/lib/floating/useFloatingWithInteractions/useFloatingWithInteractions.js
var whileElementsMounted = (...args) => (
  /* istanbul ignore next: не знаю как проверить */
  autoUpdateFloatingElement(...args, {
    elementResize: true
  })
);
var useFloatingWithInteractions = ({
  trigger = DEFAULT_TRIGGER,
  // UseFloating
  placement: placementProp = "bottom",
  middlewares,
  hoverDelay = 0,
  closeAfterClick = false,
  // disables
  disabled = false,
  disableInteractive = false,
  disableCloseOnClickOutside = false,
  disableCloseOnEscKey = false,
  // uncontrolled
  defaultShown = false,
  // controlled
  shown: shownProp,
  onShownChange: onShownChangeProp
}) => {
  const memoizedValue = React61.useMemo(() => shownProp !== void 0 ? {
    shown: shownProp
  } : void 0, [
    shownProp
  ]);
  const [shownLocalState, setShownLocalState] = useCustomEnsuredControl({
    value: memoizedValue,
    disabled,
    defaultValue: {
      shown: defaultShown
    },
    onChange: useStableCallback(({ shown, reason }) => {
      if (onShownChangeProp) {
        onShownChangeProp(shown, reason);
      }
    })
  });
  const [shownFinalState, setShownFinalState] = React61.useState(() => shownLocalState.shown);
  const [willBeHide, setWillBeHide] = React61.useState(false);
  const hasCSSAnimation = React61.useRef(false);
  const blockMouseEnterRef = React61.useRef(false);
  const blockFocusRef = React61.useRef(false);
  const blurTimeoutRef = React61.useRef();
  const handleCloseOnReferenceClickOutsideDisabled = disabled || disableCloseOnClickOutside || willBeHide || !shownLocalState.shown;
  const handleCloseOnFloatingClickOutsideDisabled = disableInteractive || handleCloseOnReferenceClickOutsideDisabled;
  const { triggerOnFocus, triggerOnClick, triggerOnHover } = useResolveTriggerType(trigger);
  const { placement, x, y, strategy, refs, middlewareData } = useFloating({
    strategy: "fixed",
    placement: placementProp,
    middleware: middlewares,
    whileElementsMounted
  });
  const commitShownLocalState = React61.useCallback((nextShown, reason) => {
    setShownLocalState((prevState) => {
      if (prevState.shown !== nextShown) {
        return {
          shown: nextShown,
          reason
        };
      }
      return prevState;
    });
  }, [
    setShownLocalState
  ]);
  const [mouseEnterDelay, mouseLeaveDelay] = typeof hoverDelay === "number" ? [
    hoverDelay,
    hoverDelay
  ] : hoverDelay;
  const showWithDelay = React61.useMemo(() => debounce(() => commitShownLocalState(true, "hover"), mouseEnterDelay), [
    mouseEnterDelay,
    commitShownLocalState
  ]);
  const hideWithDelay = React61.useMemo(() => debounce(() => commitShownLocalState(false, "hover"), mouseLeaveDelay), [
    mouseLeaveDelay,
    commitShownLocalState
  ]);
  const handleFocusOnReference = useStableCallback(() => {
    if (blockFocusRef.current) {
      blockFocusRef.current = false;
      return;
    }
    commitShownLocalState(true, "focus");
  });
  const handleBlurOnReference = useStableCallback((event) => {
    blockFocusRef.current = false;
    blockMouseEnterRef.current = false;
    if (!shownLocalState.shown) {
      clearTimeout(blurTimeoutRef.current);
      return;
    }
    const relatedTarget = event.relatedTarget;
    blurTimeoutRef.current = setTimeout(function waitWindowBlurFire() {
      const reference = refs.reference.current;
      if (!relatedTarget && getActiveElementByAnotherElement(reference) === reference) {
        return;
      }
      if (contains(refs.floating.current, relatedTarget) || contains(reference, relatedTarget)) {
        return;
      }
      commitShownLocalState(false, "focus");
    });
  });
  const handleClickOnReference = useStableCallback(() => {
    commitShownLocalState(!shownLocalState.shown, "click");
  });
  const handleClickOnReferenceForOnlyClose = useStableCallback(() => {
    blockMouseEnterRef.current = true;
    commitShownLocalState(false, "click");
  });
  const handleMouseEnterOnBoth = useStableCallback(() => {
    showWithDelay.cancel();
    hideWithDelay.cancel();
    if (!blockMouseEnterRef.current && !shownLocalState.shown) {
      showWithDelay();
    }
  });
  const handleMouseLeaveOnBothForHoverAndFocusStates = useStableCallback(() => {
    blockFocusRef.current = false;
    blockMouseEnterRef.current = false;
    if (triggerOnHover) {
      showWithDelay.cancel();
      hideWithDelay.cancel();
      if (shownLocalState.reason !== "focus" && shownLocalState.reason !== "click") {
        hideWithDelay();
      }
    }
  });
  const handleFloatingAnimationStart = () => {
    hasCSSAnimation.current = true;
  };
  const handleFloatingAnimationEnd = () => {
    if (willBeHide) {
      setShownFinalState(false);
      setWillBeHide(false);
    }
  };
  const handleOnClose = React61.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "callback");
  }, [
    commitShownLocalState
  ]);
  const handleRestoreFocus = React61.useCallback(() => triggerOnFocus ? blockFocusRef.current : true, [
    triggerOnFocus
  ]);
  const handleEscapeKeyDown = React61.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "escape-key");
  }, [
    commitShownLocalState
  ]);
  const handleClickOutside = React61.useCallback(() => {
    blockFocusRef.current = true;
    commitShownLocalState(false, "click-outside");
  }, [
    commitShownLocalState
  ]);
  useGlobalOnClickOutside(handleClickOutside, handleCloseOnReferenceClickOutsideDisabled ? null : refs.reference, handleCloseOnFloatingClickOutsideDisabled ? null : refs.floating);
  useIsomorphicLayoutEffect(
    /**
    * Если пользователь покинул активное окно и:
    * 1. целевой элемент был в состоянии фокуса;
    * 2. всплывающий элемент был закрытом состоянии;
    * то фокус должен быть заблокирован, когда пользователь вернётся обратно. Иначе покажется
    * всплывающий элемент.
    */
    function setGlobalBlurForTriggerOnFocus() {
      if (!triggerOnFocus || !refs.reference.current) {
        return;
      }
      const handleGlobalBlur = () => {
        const reference = refs.reference.current;
        if (!shownLocalState.shown && isHTMLElement(reference) && reference === getActiveElementByAnotherElement(reference)) {
          blockFocusRef.current = true;
        }
      };
      const win = getWindow(refs.reference.current);
      win.addEventListener("blur", handleGlobalBlur);
      return () => {
        win.removeEventListener("blur", handleGlobalBlur);
      };
    },
    [
      triggerOnFocus,
      refs.reference,
      shownLocalState
    ]
  );
  useIsomorphicLayoutEffect(function resolveShownStates() {
    if (willBeHide || shownLocalState.shown === shownFinalState) {
      return;
    }
    if (shownLocalState.shown) {
      setShownFinalState(true);
    } else if (hasCSSAnimation.current && !willBeHide) {
      setWillBeHide(true);
    } else {
      setShownFinalState(false);
    }
    return () => {
      clearTimeout(blurTimeoutRef.current);
    };
  }, [
    shownLocalState,
    shownFinalState,
    willBeHide
  ]);
  const referencePropsRef = React61.useRef({});
  const floatingPropsRef = React61.useRef({
    style: {}
  });
  if (shownFinalState) {
    floatingPropsRef.current.style = convertFloatingDataToReactCSSProperties(strategy, x, y, void 0, middlewareData);
    if (disableInteractive) {
      floatingPropsRef.current.style.pointerEvents = "none";
    }
  }
  if (triggerOnFocus) {
    referencePropsRef.current.onFocus = handleFocusOnReference;
    referencePropsRef.current.onBlur = handleBlurOnReference;
  }
  if (triggerOnClick) {
    referencePropsRef.current.onClick = handleClickOnReference;
  }
  if (triggerOnHover) {
    referencePropsRef.current.onMouseOver = handleMouseEnterOnBoth;
    if (closeAfterClick && !triggerOnClick) {
      referencePropsRef.current.onClick = handleClickOnReferenceForOnlyClose;
    }
    if (!disableInteractive) {
      floatingPropsRef.current.onMouseOver = handleMouseEnterOnBoth;
    }
  }
  if (triggerOnHover || triggerOnFocus) {
    referencePropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;
    if (!disableInteractive) {
      floatingPropsRef.current.onMouseLeave = handleMouseLeaveOnBothForHoverAndFocusStates;
    }
  }
  if (shownFinalState) {
    floatingPropsRef.current.onAnimationStart = handleFloatingAnimationStart;
    floatingPropsRef.current.onAnimationEnd = handleFloatingAnimationEnd;
  }
  return {
    placement,
    shown: shownFinalState,
    willBeHide,
    refs,
    referenceProps: referencePropsRef.current,
    floatingProps: floatingPropsRef.current,
    middlewareData,
    onClose: handleOnClose,
    // FocusTrap уже определяет нажатие на ESC, поэтому название события содержит конкретный код
    // кнопки вместо просто onKeyDown.
    onEscapeKeyDown: !shownFinalState || disableCloseOnEscKey ? void 0 : handleEscapeKeyDown,
    // [Обход баги с FocusTrap]
    //
    // Если сфокусироваться на целевой элемент через нажатие, а потом нажать в область за пределами
    // целевого и всплывающего элемента, то появляется моргание из-за того, что FocusTrap
    // восстанавливает фокус, из-за чего всплывающий элемент снова показывается за счёт
    // `handleFocusOnReference`, а потом скрывается за счёт `handleBlurOnReference`.
    onRestoreFocus: handleRestoreFocus
  };
};

// node_modules/@vkontakte/vkui/dist/lib/floating/usePlacementChangeCallback.js
function usePlacementChangeCallback(placement, onPlacementChange) {
  const prevPlacement = usePrevious(placement);
  useIsomorphicLayoutEffect(() => {
    if (prevPlacement === void 0 || !onPlacementChange) {
      return;
    }
    if (prevPlacement !== placement) {
      onPlacementChange(placement);
    }
  }, [
    prevPlacement,
    placement,
    onPlacementChange
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/View/utils.js
var swipeBackExcludedSelector = "input, textarea, [data-vkui-swipe-back=false]";
function swipeBackExcluded(e) {
  var _target_closest;
  const target = e.originalEvent.target;
  return Boolean(target === null || target === void 0 ? void 0 : (_target_closest = target.closest) === null || _target_closest === void 0 ? void 0 : _target_closest.call(target, swipeBackExcludedSelector));
}
function hasHorizontalScrollableElementWithScrolledToLeft(node) {
  return getOverflowAncestors(node).some((node2) => "scrollLeft" in node2 ? node2.scrollLeft > 0 : false);
}
var SWIPE_BACK_EDGE_SIZE_THRESHOLD = 20;
var SWIPE_BACK_SHIFT_THRESHOLD = 10;
var getSwipeBackPredicates = (startX, shiftX, innerWidth) => {
  const swipedToOpposite = shiftX < 0;
  const swipeBackTriggered = shiftX >= SWIPE_BACK_SHIFT_THRESHOLD;
  const viewportStartEdgeTouched = startX <= SWIPE_BACK_EDGE_SIZE_THRESHOLD;
  const viewportEndEdgeTouched = startX >= innerWidth - SWIPE_BACK_EDGE_SIZE_THRESHOLD;
  return {
    swipedToOpposite,
    swipeBackTriggered,
    viewportStartEdgeTouched,
    viewportEndEdgeTouched
  };
};

// node_modules/@vkontakte/vkui/dist/components/View/View.js
var scrollsCache = {};
var warn3 = warnOnce("View");
var View = (_param) => {
  var { activePanel: activePanelProp, history, nav, onTransition, onSwipeBack, onSwipeBackStart, onSwipeBackCancel: onSwipeBackCancelProp, children, className } = _param, restProps = _object_without_properties(_param, [
    "activePanel",
    "history",
    "nav",
    "onTransition",
    "onSwipeBack",
    "onSwipeBackStart",
    "onSwipeBackCancel",
    "children",
    "className"
  ]);
  const id = getNavId({
    nav,
    id: restProps.id
  });
  const scrolls = React62.useRef(scrollsCache[id] || {});
  const afterTransition = React62.useRef(noop);
  React62.useEffect(() => () => {
    if (id) {
      scrollsCache[id] = scrolls.current;
    }
  });
  const panelNodes = React62.useRef({});
  const { window: window2, document: document2 } = useDOM();
  const scroll = useScroll();
  const configProvider = useConfigProvider();
  const splitCol = useSplitCol();
  const platform3 = usePlatform();
  const [animated, setAnimated] = React62.useState(false);
  const [visiblePanels, setVisiblePanels] = React62.useState([
    activePanelProp
  ]);
  const [activePanel, setActivePanel] = React62.useState(activePanelProp);
  const [isBack, setIsBack] = React62.useState(void 0);
  const [prevPanel, setPrevPanel] = React62.useState(null);
  const [nextPanel, setNextPanel] = React62.useState(null);
  const swipeBackPrevented = React62.useRef(false);
  const [swipingBack, setSwipingBack] = React62.useState(void 0);
  const [swipeBackStartX, setSwipeBackStartX] = React62.useState(0);
  const [swipeBackShift, setSwipeBackShift] = React62.useState(0);
  const [swipeBackNextPanel, setSwipeBackNextPanel] = React62.useState(null);
  const [swipeBackPrevPanel, setSwipeBackPrevPanel] = React62.useState(null);
  const [swipeBackResult, setSwipeBackResult] = React62.useState(null);
  const [browserSwipe, setBrowserSwipe] = React62.useState(false);
  const prevActivePanel = usePrevious(activePanelProp);
  const prevSwipingBack = usePrevious(swipingBack);
  const prevBrowserSwipe = usePrevious(browserSwipe);
  const prevSwipeBackResult = usePrevious(swipeBackResult);
  const prevSwipeBackShift = usePrevious(swipeBackShift);
  const prevSwipeBackPrevPanel = usePrevious(swipeBackPrevPanel);
  const prevOnTransition = usePrevious(onTransition);
  const panels = React62.Children.toArray(children).filter((panel) => {
    const panelId = getNavId(panel.props, warn3);
    return panelId !== void 0 && visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;
  });
  const disableAnimation = !configProvider.transitionMotionEnabled || !splitCol.animate || platform3 === "vkcom";
  const iOSSwipeBackSimulationEnabled = !disableAnimation && platform3 === "ios" && configProvider.isWebView && Boolean(onSwipeBack);
  const pickPanel = (id2) => {
    if (id2 === null) {
      return null;
    }
    return panelNodes.current[id2];
  };
  const flushTransition = React62.useCallback((prevPanel2, isBackTransition) => {
    if (isBackTransition) {
      scrolls.current[prevPanel2] = 0;
    }
    setPrevPanel(null);
    setNextPanel(null);
    setVisiblePanels([
      activePanelProp
    ]);
    setActivePanel(activePanelProp);
    setAnimated(false);
    setIsBack(isBackTransition);
    afterTransition.current = () => {
      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, isBackTransition ? scrolls.current[activePanelProp] : 0);
      onTransition && onTransition({
        isBack: isBackTransition,
        from: prevPanel2,
        to: activePanelProp
      });
    };
  }, [
    activePanelProp,
    onTransition,
    scroll
  ]);
  useIsomorphicLayoutEffect(() => {
    afterTransition.current();
    afterTransition.current = noop;
  }, [
    afterTransition.current
  ]);
  const transitionEndHandler = React62.useCallback((e) => {
    if ((!e || [
      "vkuianimation-ios-next-forward",
      "vkuianimation-ios-prev-back",
      "vkuianimation-view-next-forward",
      "vkuianimation-view-prev-back"
    ].includes(e.animationName)) && prevPanel !== null) {
      flushTransition(prevPanel, Boolean(isBack));
    }
  }, [
    flushTransition,
    isBack,
    prevPanel
  ]);
  const { waitTransitionFinish } = useWaitTransitionFinish();
  const animationFinishTimeout = useTimeout(transitionEndHandler, platform3 === "ios" ? 600 : 300);
  const onSwipeBackSuccess = React62.useCallback(() => {
    onSwipeBack && onSwipeBack();
  }, [
    onSwipeBack
  ]);
  const onSwipeBackCancel = React62.useCallback(() => {
    onSwipeBackCancelProp && onSwipeBackCancelProp();
    setSwipeBackPrevPanel(null);
    setSwipeBackNextPanel(null);
    setSwipingBack(false);
    setSwipeBackResult(null);
    setSwipeBackStartX(0);
    setSwipeBackShift(0);
  }, [
    onSwipeBackCancelProp
  ]);
  const swipingBackTransitionEndHandler = React62.useCallback((e) => {
    if (!e || (e === null || e === void 0 ? void 0 : e.propertyName.includes("transform")) && (e === null || e === void 0 ? void 0 : e.target) === pickPanel(swipeBackNextPanel)) {
      switch (swipeBackResult) {
        case "fail":
          onSwipeBackCancel();
          break;
        case "success":
          onSwipeBackSuccess();
      }
    }
  }, [
    onSwipeBackCancel,
    onSwipeBackSuccess,
    swipeBackNextPanel,
    swipeBackResult
  ]);
  const handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext = (event) => {
    if (browserSwipe) {
      return;
    }
    const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, window2.innerWidth);
    if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {
      setBrowserSwipe(true);
    }
  };
  const handleTouchMoveXForIOSSwipeBackSimulation = (event) => {
    if (swipeBackPrevented.current || swipeBackExcluded(event)) {
      return;
    }
    const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, window2.innerWidth);
    if (animated && swipeBackTriggered) {
      return;
    }
    if (!swipingBack && history && history.length > 1) {
      if (swipedToOpposite) {
        swipeBackPrevented.current = true;
        return;
      }
      if (!swipeBackTriggered) {
        return;
      }
      if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {
        swipeBackPrevented.current = true;
        return;
      }
      if (onSwipeBackStart) {
        const payload = onSwipeBackStart(activePanel);
        if (payload === "prevent") {
          swipeBackPrevented.current = true;
          return;
        }
      }
      if (activePanel !== null) {
        blurActiveElement(document2);
        scrolls.current[activePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;
      }
      setSwipingBack(true);
      setSwipeBackStartX(event.startX);
      setSwipeBackPrevPanel(activePanel);
      setSwipeBackNextPanel(history.slice(-2)[0]);
    }
    if (swipingBack) {
      if (event.shiftX < 0) {
        setSwipeBackShift(0);
      } else if (event.shiftX > window2.innerWidth - swipeBackStartX) {
        setSwipeBackShift(window2.innerWidth);
      } else {
        setSwipeBackShift(event.shiftX);
      }
    }
  };
  const handleTouchEndForIOSSwipeBackSimulation = (event) => {
    swipeBackPrevented.current = false;
    if (swipingBack) {
      const speed = swipeBackShift / event.duration * 1e3;
      var _window_innerWidth;
      if (swipeBackShift === 0) {
        onSwipeBackCancel();
      } else if (swipeBackShift >= ((_window_innerWidth = window2.innerWidth) !== null && _window_innerWidth !== void 0 ? _window_innerWidth : 0)) {
        onSwipeBackSuccess();
      } else if (speed > 250 || swipeBackShift >= window2.innerWidth / 2) {
        setSwipeBackResult("success");
      } else {
        setSwipeBackResult("fail");
      }
    }
  };
  const calcPanelSwipeStyles = (panelId) => {
    if (!canUseDOM || !window2) {
      return {};
    }
    const isPrev = panelId === swipeBackPrevPanel;
    const isNext = panelId === swipeBackNextPanel;
    if (!isPrev && !isNext || swipeBackResult) {
      return {};
    }
    let prevPanelTranslate = `${swipeBackShift}px`;
    let nextPanelTranslate = `${-50 + swipeBackShift * 100 / window2.innerWidth / 2}%`;
    if (isNext) {
      return {
        transform: `translate3d(${nextPanelTranslate}, 0, 0)`,
        WebkitTransform: `translate3d(${nextPanelTranslate}, 0, 0)`
      };
    }
    if (isPrev) {
      return {
        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,
        WebkitTransform: `translate3d(${prevPanelTranslate}, 0, 0)`
      };
    }
    return {};
  };
  const calcPanelSwipeBackOverlayStyles = (panelId) => {
    if (!canUseDOM || !window2) {
      return {};
    }
    const isNext = panelId === swipeBackNextPanel;
    if (!isNext) {
      return {};
    }
    const calculatedOpacity = 1 - swipeBackShift / window2.innerWidth;
    const opacityOnSwipeEnd = swipeBackResult === "success" ? 0 : swipeBackResult === "fail" ? 1 : null;
    return {
      display: "block",
      opacity: opacityOnSwipeEnd === null ? calculatedOpacity : opacityOnSwipeEnd
    };
  };
  React62.useEffect(() => {
    if (prevActivePanel && prevActivePanel !== activePanelProp && !prevSwipingBack && !prevBrowserSwipe) {
      const firstLayerId = React62.Children.toArray(children).map((panel) => getNavId(panel.props, warn3)).find((id2) => id2 === prevActivePanel || id2 === activePanelProp);
      const isBackTransition = firstLayerId === activePanelProp;
      scrolls.current[prevActivePanel] = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;
      if (disableAnimation) {
        flushTransition(prevActivePanel, isBackTransition);
      } else {
        blurActiveElement(document2);
        setVisiblePanels([
          prevActivePanel,
          activePanelProp
        ]);
        setPrevPanel(prevActivePanel);
        setNextPanel(activePanelProp);
        setActivePanel(null);
        setAnimated(true);
        setIsBack(isBackTransition);
        if (!animationEvent2.supported) {
          animationFinishTimeout.set();
        }
      }
    }
    if (prevActivePanel && prevActivePanel !== activePanelProp && prevSwipingBack) {
      const nextPanel2 = activePanelProp;
      const prevPanel2 = prevActivePanel;
      if (prevSwipeBackPrevPanel) {
        scrolls.current[prevSwipeBackPrevPanel] = 0;
      }
      setSwipeBackPrevPanel(null);
      setSwipeBackNextPanel(null);
      setSwipingBack(false);
      setSwipeBackResult(null);
      setSwipeBackStartX(0);
      setSwipeBackShift(0);
      setActivePanel(nextPanel2);
      setVisiblePanels([
        nextPanel2
      ]);
      setIsBack(true);
      afterTransition.current = () => {
        if (nextPanel2 !== null) {
          scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[nextPanel2]);
        }
        prevOnTransition && prevOnTransition({
          isBack: true,
          from: prevPanel2,
          to: nextPanel2
        });
      };
    }
    if (!prevSwipeBackResult && swipeBackResult) {
      waitTransitionFinish(pickPanel(swipeBackNextPanel), swipingBackTransitionEndHandler, platform3 === "ios" ? 600 : 300);
    }
    if (prevActivePanel !== activePanelProp && browserSwipe) {
      setBrowserSwipe(false);
      setNextPanel(null);
      setPrevPanel(null);
      setAnimated(false);
      setVisiblePanels([
        activePanelProp
      ]);
      setActivePanel(activePanelProp);
    }
  }, [
    activePanelProp,
    activePanel,
    animationFinishTimeout,
    browserSwipe,
    children,
    disableAnimation,
    document2,
    flushTransition,
    platform3,
    prevActivePanel,
    prevBrowserSwipe,
    prevOnTransition,
    prevSwipeBackPrevPanel,
    prevSwipeBackResult,
    prevSwipingBack,
    scroll,
    swipeBackNextPanel,
    swipeBackResult,
    swipingBackTransitionEndHandler,
    waitTransitionFinish
  ]);
  React62.useEffect(function restoreScrollPositionWhenSwipeBackIsCancelled() {
    const swipeBackCancelledInTheMiddleOfAction = prevSwipeBackResult === "fail" && !swipeBackResult;
    const swipeBackCancelledByMovingPanelBackToInitialPoint = prevSwipingBack && !swipingBack && prevSwipeBackShift === 0;
    if ((swipeBackCancelledInTheMiddleOfAction || swipeBackCancelledByMovingPanelBackToInitialPoint) && activePanel !== null) {
      scroll === null || scroll === void 0 ? void 0 : scroll.scrollTo(0, scrolls.current[activePanel]);
    }
  }, [
    prevSwipeBackResult,
    swipeBackResult,
    prevSwipingBack,
    swipingBack,
    prevSwipeBackShift,
    activePanel,
    scroll
  ]);
  return React62.createElement(NavViewIdContext.Provider, {
    value: id
  }, React62.createElement(Touch, _object_spread_props(_object_spread({
    Component: "section"
  }, restProps), {
    className: classNames("vkuiView", platform3 === "ios" && classNames("vkuiView--ios", "vkuiInternalView--ios"), !disableAnimation && animated && "vkuiView--animated", !disableAnimation && swipingBack && "vkuiView--swiping-back", disableAnimation && "vkuiView--no-motion", className),
    onMoveX: iOSSwipeBackSimulationEnabled ? handleTouchMoveXForIOSSwipeBackSimulation : platform3 === "ios" ? handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : void 0,
    onEnd: iOSSwipeBackSimulationEnabled ? handleTouchEndForIOSSwipeBackSimulation : void 0
  }), React62.createElement("div", {
    className: "vkuiView__panels"
  }, panels.map((panel) => {
    const panelId = getNavId(panel.props, warn3);
    const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;
    const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);
    const compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;
    var _scrolls_current_panelId;
    return React62.createElement("div", {
      className: classNames("vkuiView__panel", panelId === activePanel && "vkuiView__panel--active", panelId === prevPanel && "vkuiView__panel--prev", panelId === nextPanel && "vkuiView__panel--next", panelId === swipeBackPrevPanel && "vkuiView__panel--swipe-back-prev", panelId === swipeBackNextPanel && "vkuiView__panel--swipe-back-next", swipeBackResult === "success" && "vkuiView__panel--swipe-back-success", swipeBackResult === "fail" && "vkuiView__panel--swipe-back-failed"),
      onAnimationEnd: isTransitionTarget ? transitionEndHandler : void 0,
      ref: (el) => panelId !== void 0 && (panelNodes.current[panelId] = el),
      style: calcPanelSwipeStyles(panelId),
      key: panelId
    }, platform3 === "ios" && React62.createElement("div", {
      className: "vkuiView__panel-overlay",
      style: calcPanelSwipeBackOverlayStyles(panelId)
    }), React62.createElement("div", {
      className: "vkuiView__panel-in",
      style: {
        marginTop: compensateScroll ? -((_scrolls_current_panelId = scrolls.current[panelId]) !== null && _scrolls_current_panelId !== void 0 ? _scrolls_current_panelId : 0) : void 0
      }
    }, React62.createElement(NavTransitionDirectionProvider, {
      isBack: swipingBack || isBack
    }, React62.createElement(NavTransitionProvider, {
      entering: panelId === nextPanel || panelId === swipeBackNextPanel
    }, panel))));
  }))));
};

// node_modules/@vkontakte/vkui/dist/components/Panel/Panel.js
var React63 = __toESM(require_react());
var sizeXClassNames2 = {
  none: "vkuiPanel--sizeX-none",
  ["compact"]: "vkuiPanel--sizeX-compact",
  ["regular"]: "vkuiPanel--sizeX-regular"
};
var Panel = (_param) => {
  var { centered = false, children, nav } = _param, restProps = _object_without_properties(_param, [
    "centered",
    "children",
    "nav"
  ]);
  const { sizeX = "none" } = useAdaptivity();
  const { layout } = React63.useContext(AppRootContext);
  return React63.createElement(NavPanelIdContext.Provider, {
    value: restProps.id || nav
  }, React63.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiPanel", sizeXClassNames2[sizeX], centered && "vkuiInternalPanel--centered", layout === "card" && "vkuiPanel--layout-card")
  }), React63.createElement(Touch, {
    Component: OnboardingTooltipContainer,
    className: classNames("vkuiPanel__in", "vkuiInternalPanel__in")
  }, React63.createElement("div", {
    className: "vkuiPanel__in-before"
  }), centered ? React63.createElement("div", {
    className: "vkuiPanel__centered"
  }, children) : children, React63.createElement("div", {
    className: "vkuiPanel__in-after"
  }))));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderButton/PanelHeaderButton.js
var React64 = __toESM(require_react());
var platformClassNames = {
  ios: "vkuiPanelHeaderButton--ios",
  android: "vkuiPanelHeaderButton--android",
  vkcom: "vkuiPanelHeaderButton--vkcom"
};
var ButtonTypography = ({ primary, children }) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return React64.createElement(Title, {
      Component: "span",
      level: "3",
      weight: primary ? "1" : "3"
    }, children);
  }
  return React64.createElement(Text, {
    weight: platform3 === "vkcom" ? void 0 : "2"
  }, children);
};
var warn4 = warnOnce("PanelHeaderButton");
var PanelHeaderButton = (_param) => {
  var { children, primary = false, label, className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "primary",
    "label",
    "className"
  ]);
  const isPrimitive = isPrimitiveReactNode(children);
  const isPrimitiveLabel = isPrimitiveReactNode(label);
  const platform3 = usePlatform();
  let hoverMode;
  let activeMode;
  switch (platform3) {
    case "ios":
      hoverMode = "background";
      activeMode = "opacity";
      break;
    case "vkcom":
      hoverMode = "vkuiPanelHeaderButton--hover";
      activeMode = "vkuiPanelHeaderButton--active";
      break;
    default:
      hoverMode = "background";
      activeMode = "background";
  }
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn4(COMMON_WARNINGS.a11y[restProps.href ? "link-name" : "button-name"], "error");
    }
  }
  return React64.createElement(Tappable, _object_spread_props(_object_spread({
    Component: restProps.href ? "a" : "button"
  }, restProps), {
    hoverMode,
    activeEffectDelay: 200,
    activeMode,
    className: classNames("vkuiInternalPanelHeaderButton", "vkuiPanelHeaderButton", platformClassNames.hasOwnProperty(platform3) ? platformClassNames[platform3] : platformClassNames.android, isPrimitive && "vkuiPanelHeaderButton--primitive", !isPrimitive && !isPrimitiveLabel && "vkuiPanelHeaderButton--notPrimitive", className)
  }), isPrimitive ? React64.createElement(ButtonTypography, {
    primary
  }, children) : children, isPrimitiveLabel ? React64.createElement(ButtonTypography, {
    primary,
    className: "vkuiPanelHeaderButton__label"
  }, label) : label);
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeader/PanelHeader.js
var React69 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/useAdaptivityConditionalRender.js
var React65 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/constants.js
var sizeXCompactClassNames = {
  mq: {
    className: "vkui-sizeX--compact-mq"
  },
  ["compact"]: {
    className: "vkui-sizeX--compact-forced"
  }
};
var sizeXRegularClassNames = {
  mq: {
    className: "vkui-sizeX--regular-mq"
  },
  ["regular"]: {
    className: "vkui-sizeX--regular-forced"
  }
};
var sizeYCompactClassNames = {
  mq: {
    className: "vkui-sizeY--compact-mq"
  },
  ["compact"]: {
    className: "vkui-sizeY--compact-forced"
  }
};
var sizeYRegularClassNames = {
  mq: {
    className: "vkui-sizeY--regular-mq"
  },
  ["regular"]: {
    className: "vkui-sizeY--regular-forced"
  }
};
var viewWidthClassNames = {
  tabletMinus: {
    mq: {
      className: "vkui-viewWidth--tabletMinus-mq"
    },
    forced: {
      className: "vkui-viewWidth--tabletMinus-forced"
    }
  },
  tabletPlus: {
    mq: {
      className: "vkui-viewWidth--tabletPlus-mq"
    },
    forced: {
      className: "vkui-viewWidth--tabletPlus-forced"
    }
  }
};
var deviceTypeClassNames = {
  mobile: {
    mq: {
      className: "vkui-deviceType--mobile-mq"
    },
    forced: {
      className: "vkui-deviceType--mobile-forced"
    }
  },
  desktop: {
    mq: {
      className: "vkui-deviceType--desktop-mq"
    },
    forced: {
      className: "vkui-deviceType--desktop-forced"
    }
  }
};

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/helpers.js
var getAdaptiveSizeType = (type, compactClassNames, regularClassNames) => {
  return {
    compact: type === void 0 ? compactClassNames.mq : type === "compact" ? compactClassNames[type] : false,
    regular: type === void 0 ? regularClassNames.mq : type === "regular" ? regularClassNames[type] : false
  };
};
var getAdaptiveViewWidth = (viewWidth, viewWidthClassNames2) => {
  return {
    tabletMinus: viewWidth === void 0 ? viewWidthClassNames2.tabletMinus.mq : viewWidth < ViewWidth.TABLET ? viewWidthClassNames2.tabletMinus.forced : false,
    tabletPlus: viewWidth === void 0 ? viewWidthClassNames2.tabletPlus.mq : viewWidth >= ViewWidth.TABLET ? viewWidthClassNames2.tabletPlus.forced : false
  };
};
var getAdaptiveDeviceType = (viewWidth, viewHeight, hasPointer, platform3, deviceTypeClassNames2) => {
  const isDesktop = tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3);
  if (isDesktop === null) {
    return {
      mobile: deviceTypeClassNames2.mobile.mq,
      desktop: deviceTypeClassNames2.desktop.mq
    };
  }
  if (isDesktop) {
    return {
      mobile: false,
      desktop: deviceTypeClassNames2.desktop.forced
    };
  }
  return {
    mobile: deviceTypeClassNames2.mobile.forced,
    desktop: false
  };
};

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityConditionalRender/useAdaptivityConditionalRender.js
var useAdaptivityConditionalRender = () => {
  const { sizeX: sizeXContext, sizeY: sizeYContext, viewWidth: viewWidthContext, viewHeight: viewHeightContext, hasPointer: hasPointerContext } = React65.useContext(AdaptivityContext);
  const platform3 = usePlatform();
  return React65.useMemo(() => {
    const sizeX = getAdaptiveSizeType(sizeXContext, sizeXCompactClassNames, sizeXRegularClassNames);
    const sizeY = getAdaptiveSizeType(sizeYContext, sizeYCompactClassNames, sizeYRegularClassNames);
    const viewWidth = getAdaptiveViewWidth(viewWidthContext, viewWidthClassNames);
    const deviceType = getAdaptiveDeviceType(viewWidthContext, viewHeightContext, hasPointerContext, platform3, deviceTypeClassNames);
    return {
      sizeX,
      sizeY,
      viewWidth,
      deviceType
    };
  }, [
    sizeXContext,
    sizeYContext,
    viewWidthContext,
    viewHeightContext,
    hasPointerContext,
    platform3
  ]);
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootContext.js
var React66 = __toESM(require_react());
var ModalRootContext = React66.createContext({
  updateModalHeight: () => void 0,
  registerModal: () => void 0,
  isInsideModal: false
});
function useModalRegistry(id, type) {
  const modalContext = React66.useContext(ModalRootContext);
  const elements = React66.useRef({}).current;
  useIsomorphicLayoutEffect(() => {
    if (id !== void 0) {
      modalContext.registerModal(_object_spread_props(_object_spread({}, elements), {
        type,
        id
      }));
      const reset = Object.keys(elements).reduce((acc, k) => _object_spread_props(_object_spread({}, acc), {
        [k]: null
      }), {
        type,
        id
      });
      return () => modalContext.registerModal(reset);
    }
    return void 0;
  }, []);
  const refs = React66.useRef({
    modalElement: (e) => elements.modalElement = e,
    innerElement: (e) => elements.innerElement = e,
    headerElement: (e) => elements.headerElement = e,
    contentElement: (e) => elements.contentElement = e,
    bottomInset: (e) => elements.bottomInset = e
  }).current;
  return {
    refs
  };
}

// node_modules/@vkontakte/vkui/dist/components/Separator/Separator.js
var React67 = __toESM(require_react());
var Separator = (_param) => {
  var { wide } = _param, restProps = _object_without_properties(_param, [
    "wide"
  ]);
  return React67.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiSeparator", !wide && "vkuiSeparator--padded")
  }), React67.createElement("hr", {
    className: "vkuiSeparator__in"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Spacing/Spacing.js
var React68 = __toESM(require_react());
var Spacing = (_param) => {
  var { size: size4 = 8, style: styleProp } = _param, restProps = _object_without_properties(_param, [
    "size",
    "style"
  ]);
  const style = _object_spread({
    height: size4,
    padding: `${size4 / 2}px 0`
  }, styleProp);
  return React68.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: "vkuiSpacing",
    style
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeader/PanelHeader.js
var platformClassNames2 = {
  ios: "vkuiPanelHeader--ios",
  android: "vkuiPanelHeader--android",
  vkcom: classNames("vkuiPanelHeader--vkcom", "vkuiInternalPanelHeader--vkcom")
};
var sizeXClassNames3 = {
  none: "vkuiPanelHeader--sizeX-none",
  regular: "vkuiPanelHeader--sizeX-regular"
};
var sizeYClassNames6 = {
  none: "vkuiPanelHeader--sizeY-none",
  compact: "vkuiPanelHeader--sizeY-compact"
};
var PanelHeaderIn = ({ before, after, children, typographyProps = {} }) => {
  const { Component: Component3 = "span" } = typographyProps, restProps = _object_without_properties(typographyProps, [
    "Component"
  ]);
  const { hasCustomPanelHeaderAfter, customPanelHeaderAfterMinWidth } = useConfigProvider();
  const { isInsideModal } = React69.useContext(ModalRootContext);
  const platform3 = usePlatform();
  const afterSlotProps = !hasCustomPanelHeaderAfter || isInsideModal ? {
    children: after
  } : {
    style: {
      minWidth: customPanelHeaderAfterMinWidth
    }
  };
  const typographyNode = platform3 === "vkcom" ? React69.createElement(Text, _object_spread({
    weight: "2",
    Component: Component3
  }, restProps), children) : React69.createElement(Component3, _object_spread({
    className: "vkuiPanelHeader__content-in"
  }, restProps), children);
  return React69.createElement(OnboardingTooltipContainer, {
    fixed: true,
    className: "vkuiPanelHeader__in"
  }, React69.createElement("div", {
    className: classNames("vkuiPanelHeader__before", "vkuiInternalPanelHeader__before")
  }, before), React69.createElement("div", {
    className: "vkuiPanelHeader__content"
  }, typographyNode), React69.createElement("div", _object_spread({
    className: classNames("vkuiPanelHeader__after", "vkuiInternalPanelHeader__after")
  }, afterSlotProps)));
};
var PanelHeader = (_param) => {
  var { before, children, after, float = false, transparent = false, delimiter = "auto", shadow, getRef, getRootRef, fixed, typographyProps } = _param, restProps = _object_without_properties(_param, [
    "before",
    "children",
    "after",
    "float",
    "transparent",
    "delimiter",
    "shadow",
    "getRef",
    "getRootRef",
    "fixed",
    "typographyProps"
  ]);
  const platform3 = usePlatform();
  const { sizeX = "none", sizeY = "none" } = useAdaptivity();
  const { sizeX: adaptiveSizeX } = useAdaptivityConditionalRender();
  const isVKCOM = platform3 === "vkcom";
  const isFixed = fixed !== void 0 ? fixed : !isVKCOM;
  const separatorVisible = delimiter === "auto" || delimiter === "separator";
  const staticSeparatorVisible = !float && separatorVisible;
  const staticSpacingVisible = !float && (delimiter === "auto" || delimiter === "spacing");
  return React69.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiPanelHeader", "vkuiInternalPanelHeader", platformClassNames2.hasOwnProperty(platform3) ? platformClassNames2[platform3] : platformClassNames2.android, transparent && "vkuiPanelHeader--trnsp", shadow && "vkuiPanelHeader--shadow", !float && classNames("vkuiPanelHeader--static", "vkuiInternalPanelHeader--static"), staticSeparatorVisible && classNames("vkuiPanelHeader--sep", "vkuiInternalPanelHeader--sep"), !before && classNames("vkuiPanelHeader--no-before", "vkuiInternalPanelHeader--no-before"), !after && "vkuiPanelHeader--no-after", isFixed && "vkuiPanelHeader--fixed", sizeX !== "compact" && sizeXClassNames3[sizeX], sizeY !== "regular" && sizeYClassNames6[sizeY]),
    getRootRef: isFixed ? getRootRef : getRef
  }), isFixed ? React69.createElement(FixedLayout, {
    className: classNames("vkuiPanelHeader__fixed", "vkuiInternalPanelHeader__fixed"),
    vertical: "top",
    getRootRef: getRef
  }, React69.createElement(PanelHeaderIn, {
    before,
    after,
    typographyProps
  }, children)) : React69.createElement(PanelHeaderIn, {
    before,
    after,
    typographyProps
  }, children), !isVKCOM && React69.createElement(React69.Fragment, null, staticSeparatorVisible && adaptiveSizeX.compact && React69.createElement(Separator, {
    className: adaptiveSizeX.compact.className
  }), staticSpacingVisible && adaptiveSizeX.regular && React69.createElement(Spacing, {
    className: adaptiveSizeX.regular.className,
    size: 16
  })), separatorVisible && isVKCOM && React69.createElement(Separator, {
    className: "vkuiPanelHeader__separator",
    wide: true
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderContent/PanelHeaderContent.js
var React70 = __toESM(require_react());
var platformClassNames3 = {
  ios: "vkuiPanelHeaderContent--ios",
  android: "vkuiPanelHeaderContent--android",
  vkcom: "vkuiPanelHeaderContent--vkcom"
};
var sizeYClassNames7 = {
  none: "vkuiPanelHeaderContent--sizeY-none",
  compact: "vkuiPanelHeaderContent--sizeY-compact"
};
var PanelHeaderChildren = ({ hasStatus, hasBefore, children }) => {
  const platform3 = usePlatform();
  return hasStatus || hasBefore ? React70.createElement(Text, {
    className: "vkuiPanelHeaderContent__childrenText",
    Component: "div",
    weight: platform3 === "vkcom" ? "2" : void 0
  }, children) : React70.createElement("div", {
    className: "vkuiPanelHeaderContent__children-in"
  }, children);
};
var PanelHeaderContent = (_param) => {
  var { aside, status, before, children, onClick } = _param, restProps = _object_without_properties(_param, [
    "aside",
    "status",
    "before",
    "children",
    "onClick"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const InComponent = onClick ? Tappable : "div";
  const rootProps = onClick ? {} : restProps;
  const platform3 = usePlatform();
  const inProps = onClick ? _object_spread_props(_object_spread({}, restProps), {
    onClick,
    activeEffectDelay: 200,
    hasActive: platform3 === "ios",
    activeMode: "opacity"
  }) : {};
  return React70.createElement(RootComponent, _object_spread_props(_object_spread({}, rootProps), {
    baseClassName: classNames("vkuiPanelHeaderContent", platformClassNames3.hasOwnProperty(platform3) ? platformClassNames3[platform3] : platformClassNames3.android, sizeY !== "regular" && sizeYClassNames7[sizeY])
  }), hasReactNode(before) && React70.createElement("div", {
    className: "vkuiPanelHeaderContent__before"
  }, before), React70.createElement(InComponent, _object_spread_props(_object_spread({}, inProps), {
    className: classNames("vkuiPanelHeaderContent__in", !before && platform3 !== "android" && "vkuiPanelHeaderContent__in--centered")
  }), hasReactNode(status) && React70.createElement(Footnote, {
    className: "vkuiPanelHeaderContent__status"
  }, status), React70.createElement("div", {
    className: "vkuiPanelHeaderContent__children"
  }, React70.createElement(PanelHeaderChildren, {
    hasStatus: hasReactNode(status),
    hasBefore: hasReactNode(before)
  }, children), hasReactNode(aside) && React70.createElement("div", {
    className: "vkuiPanelHeaderContent__aside"
  }, aside)), hasReactNode(before) && React70.createElement("div", {
    className: "vkuiPanelHeaderContent__width"
  })));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderContext/PanelHeaderContext.js
var React71 = __toESM(require_react());
var sizeXClassNames4 = {
  none: "vkuiPanelHeaderContext--sizeX-none",
  ["compact"]: "vkuiPanelHeaderContext--sizeX-compact",
  ["regular"]: "vkuiPanelHeaderContext--sizeX-regular"
};
var PanelHeaderContext = (_param) => {
  var { children, onClose, opened = false, className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "onClose",
    "opened",
    "className"
  ]);
  const { document: document2 } = useDOM();
  const platform3 = usePlatform();
  const [visible, setVisible] = React71.useState(opened);
  const closing = visible && !opened;
  const { sizeX = "none" } = useAdaptivity();
  const elementRef = React71.useRef(null);
  useIsomorphicLayoutEffect(() => {
    opened && setVisible(true);
  }, [
    opened
  ]);
  useScrollLock(platform3 !== "vkcom" && opened);
  useGlobalEventListener(document2, "click", opened && !closing && ((event) => {
    if (elementRef.current && !elementRef.current.contains(event.target)) {
      event.stopPropagation();
      onClose();
    }
  }), {
    capture: true
  });
  const onAnimationEnd = () => setVisible(false);
  const animationFallback = useTimeout(onAnimationEnd, 200);
  React71.useEffect(() => closing ? animationFallback.set() : animationFallback.clear(), [
    animationFallback,
    closing
  ]);
  return React71.createElement(FixedLayout, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("vkuiPanelHeaderContext", platform3 === "ios" && "vkuiPanelHeaderContext--ios", opened && "vkuiPanelHeaderContext--opened", closing && "vkuiPanelHeaderContext--closing", sizeXClassNames4[sizeX], className),
    vertical: "top"
  }), visible && React71.createElement("div", {
    onClick: (event) => {
      event.stopPropagation();
      onClose();
    },
    className: "vkuiPanelHeaderContext__fade"
  }), React71.createElement("div", {
    className: "vkuiPanelHeaderContext__in",
    ref: elementRef,
    onAnimationEnd: closing ? onAnimationEnd : void 0
  }, visible && React71.createElement("div", {
    className: "vkuiPanelHeaderContext__content"
  }, children)));
};

// node_modules/@vkontakte/vkui/dist/components/SplitLayout/SplitLayout.js
var React76 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/PopoutRoot/PopoutRoot.js
var React75 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootPortal.js
var React74 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/createPortal.js
var ReactDOM2 = __toESM(require_react_dom());
var createPortal2 = (children, container, key) => {
  const resolvedContainer = container ? container : getDocumentBody();
  return resolvedContainer && ReactDOM2.createPortal(children, resolvedContainer, key);
};

// node_modules/@vkontakte/vkui/dist/components/AppearanceProvider/AppearanceProvider.js
var React73 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProviderOverride.js
var React72 = __toESM(require_react());
function ConfigProviderOverride(_param) {
  var { children } = _param, contextValue = _object_without_properties(_param, [
    "children"
  ]);
  const parentConfig = useConfigProvider();
  const configContext = useObjectMemo(_object_spread({}, parentConfig, contextValue));
  return React72.createElement(ConfigProviderContext.Provider, {
    value: configContext
  }, children);
}

// node_modules/@vkontakte/vkui/dist/components/AppearanceProvider/AppearanceProvider.js
var AppearanceProvider = ({ value, children }) => {
  return React73.createElement(ConfigProviderOverride, {
    appearance: value
  }, React73.createElement(TokensClassProvider, null, children));
};

// node_modules/@vkontakte/vkui/dist/components/AppRoot/AppRootPortal.js
var AppRootPortal = ({ children, usePortal }) => {
  const { portalRoot, mode, disablePortal } = React74.useContext(AppRootContext);
  const appearance = useAppearance();
  const isClient = useIsClient();
  if (!isClient) {
    return null;
  }
  const portalContainer = resolvePortalContainer(usePortal, portalRoot.current);
  if (!portalContainer || shouldDisablePortal(usePortal, mode, Boolean(disablePortal))) {
    return React74.createElement(React74.Fragment, null, children);
  }
  return createPortal2(React74.createElement(AppearanceProvider, {
    value: appearance
  }, children), portalContainer);
};
function shouldDisablePortal(usePortal, mode, disablePortal) {
  if (usePortal !== void 0) {
    if (typeof usePortal !== "boolean") {
      return false;
    }
    return disablePortal || usePortal !== true;
  }
  return disablePortal || mode === "full";
}
function resolvePortalContainer(usePortal, portalRootFromContext) {
  if (usePortal === true || !usePortal) {
    return portalRootFromContext ? portalRootFromContext : null;
  }
  return isRefObject(usePortal) ? usePortal.current : usePortal;
}

// node_modules/@vkontakte/vkui/dist/components/PopoutRoot/PopoutRoot.js
var PopoutRootPopout = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return React75.createElement("div", _object_spread({
    className: classNames("vkuiPopoutRoot__popout", className)
  }, restProps));
};
var PopoutRootModal = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return React75.createElement("div", _object_spread({
    className: classNames("vkuiPopoutRoot__modal", className)
  }, restProps));
};
var PopoutRoot = (_param) => {
  var { popout, modal, children } = _param, restProps = _object_without_properties(_param, [
    "popout",
    "modal",
    "children"
  ]);
  const { document: document2 } = useDOM();
  React75.useEffect(() => {
    popout && blurActiveElement(document2);
  }, [
    document2,
    popout
  ]);
  return React75.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: "vkuiPopoutRoot"
  }), children, React75.createElement(AppRootPortal, null, !!popout && React75.createElement(PopoutRootPopout, null, popout), !!modal && React75.createElement(PopoutRootModal, null, modal)));
};

// node_modules/@vkontakte/vkui/dist/components/SplitLayout/SplitLayout.js
var SplitLayout = (_param) => {
  var { popout, modal, header, children, getRootRef, getRef, className } = _param, restProps = _object_without_properties(_param, [
    "popout",
    "modal",
    "header",
    "children",
    "getRootRef",
    "getRef",
    "className"
  ]);
  const platform3 = usePlatform();
  return React76.createElement(PopoutRoot, {
    className: classNames("vkuiSplitLayout", platform3 === "ios" && "vkuiSplitLayout--ios"),
    popout,
    modal,
    getRootRef
  }, header, React76.createElement("div", _object_spread_props(_object_spread({}, restProps), {
    ref: getRef,
    className: classNames("vkuiSplitLayout__inner", !!header && "vkuiSplitLayout__inner--header", className)
  }), children));
};

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitCol.js
var React78 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useMediaQueries.js
var React77 = __toESM(require_react());
var storedMediaQueries = {
  window: void 0,
  mediaQueries: null
};
var useMediaQueries = () => {
  const { window: window2 } = useDOM();
  return React77.useMemo(function initializeStoreOrUpdateStoreIfWindowChanges() {
    if (storedMediaQueries.window === window2 && storedMediaQueries.mediaQueries !== null) {
      return storedMediaQueries.mediaQueries;
    }
    const matchMedia2 = window2 ? window2.matchMedia.bind(window2) : mediaQueryNull;
    storedMediaQueries.window = window2;
    storedMediaQueries.mediaQueries = {
      desktopPlus: matchMedia2(import_breakpoints.MEDIA_QUERIES.DESKTOP_PLUS),
      smallTabletPlus: matchMedia2(import_breakpoints.MEDIA_QUERIES.SMALL_TABLET_PLUS),
      tablet: matchMedia2(import_breakpoints.MEDIA_QUERIES.TABLET),
      smallTablet: matchMedia2(import_breakpoints.MEDIA_QUERIES.SMALL_TABLET),
      mobile: matchMedia2(import_breakpoints.MEDIA_QUERIES.MOBILE),
      mediumHeight: matchMedia2(import_breakpoints.MEDIA_QUERIES.MEDIUM_HEIGHT),
      mobileLandscapeHeight: matchMedia2(import_breakpoints.MEDIA_QUERIES.MOBILE_LANDSCAPE_HEIGHT)
    };
    return storedMediaQueries.mediaQueries;
  }, [
    window2
  ]);
};

// node_modules/@vkontakte/vkui/dist/lib/matchMedia.js
function matchMediaListAddListener(mediaQueryList, listener) {
  mediaQueryList.addEventListener ? mediaQueryList.addEventListener("change", listener) : mediaQueryList.addListener(listener);
}
function matchMediaListRemoveListener(mediaQueryList, listener) {
  mediaQueryList.removeEventListener ? mediaQueryList.removeEventListener("change", listener) : mediaQueryList.removeListener(listener);
}

// node_modules/@vkontakte/vkui/dist/components/SplitCol/SplitCol.js
var breakpointClassNames = {
  none: classNames("vkuiSplitCol--viewWidth-none", "vkuiInternalSplitCol--viewWidth-none"),
  tabletMinus: "vkuiSplitCol--viewWidth-tabletMinus",
  smallTabletPlus: "vkuiSplitCol--viewWidth-smallTabletPlus",
  tabletPlus: "vkuiInternalSplitCol--viewWidth-tabletPlus"
};
function useTransitionAnimate(animateProp) {
  const { viewWidth } = useAdaptivity();
  const [animate3, setAnimate] = React78.useState(Boolean(animateProp));
  const mediaQueries = useMediaQueries();
  React78.useEffect(() => {
    if (animateProp !== void 0) {
      setAnimate(animateProp);
      return;
    }
    if (viewWidth !== void 0) {
      setAnimate(viewWidth < ViewWidth.TABLET);
      return;
    }
    const listener = () => setAnimate(!mediaQueries.smallTabletPlus.matches);
    listener();
    matchMediaListAddListener(mediaQueries.smallTabletPlus, listener);
    return () => {
      matchMediaListRemoveListener(mediaQueries.smallTabletPlus, listener);
    };
  }, [
    animateProp,
    viewWidth,
    mediaQueries
  ]);
  return animate3;
}
var SplitCol = (props) => {
  const { children, width, maxWidth, minWidth, animate: animateProp, fixed, style, autoSpaced, stretchedOnMobile, getRootRef } = props, restProps = _object_without_properties(props, [
    "children",
    "width",
    "maxWidth",
    "minWidth",
    "animate",
    "fixed",
    "style",
    "autoSpaced",
    "stretchedOnMobile",
    "getRootRef"
  ]);
  const baseRef = useExternRef(getRootRef);
  const { viewWidth } = useAdaptivity();
  const animate3 = useTransitionAnimate(animateProp);
  const contextValue = useObjectMemo({
    colRef: baseRef,
    animate: animate3
  });
  return React78.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    style: _object_spread_props(_object_spread({}, style), {
      width,
      maxWidth,
      minWidth
    }),
    getRootRef: baseRef,
    baseClassName: classNames("vkuiSplitCol", viewWidthToClassName(breakpointClassNames, viewWidth), autoSpaced && classNames("vkuiSplitCol--spaced-auto", "vkuiInternalSplitCol--spaced-auto"), fixed && "vkuiSplitCol--fixed", stretchedOnMobile && "vkuiSplitCol--stretched-on-mobile")
  }), React78.createElement(SplitColContext.Provider, {
    value: contextValue
  }, fixed ? React78.createElement("div", {
    className: "vkuiSplitCol__fixedInner"
  }, children) : children));
};

// node_modules/@vkontakte/vkui/dist/components/Epic/Epic.js
var React80 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Epic/ScrollSaver.js
var React79 = __toESM(require_react());
var ScrollSaver = ({ children, initialScroll, saveScroll }) => {
  const { getScroll, scrollTo } = React79.useContext(ScrollContext);
  useIsomorphicLayoutEffect(() => {
    if (typeof initialScroll === "number") {
      scrollTo(0, initialScroll);
    }
    return () => saveScroll(getScroll().y);
  }, []);
  return React79.createElement(React79.Fragment, null, children);
};

// node_modules/@vkontakte/vkui/dist/components/Epic/Epic.js
var warn5 = warnOnce("Epic");
var Epic = (_param) => {
  var { activeStory, tabbar, children } = _param, restProps = _object_without_properties(_param, [
    "activeStory",
    "tabbar",
    "children"
  ]);
  const scroll = React80.useRef({}).current;
  var _React_Children_toArray_find;
  const story = (_React_Children_toArray_find = React80.Children.toArray(children).find((story2) => React80.isValidElement(story2) && getNavId(story2.props, warn5) === activeStory)) !== null && _React_Children_toArray_find !== void 0 ? _React_Children_toArray_find : null;
  return React80.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiEpic", tabbar && "vkuiInternalEpic--hasTabbar")
  }), React80.createElement(ScrollSaver, {
    key: activeStory,
    initialScroll: scroll[activeStory] || 0,
    saveScroll: (value) => scroll[activeStory] = value
  }, story), tabbar);
};

// node_modules/@vkontakte/vkui/dist/components/Tabbar/Tabbar.js
var React81 = __toESM(require_react());
var getItemsLayoutClassName = (itemsLayout, children) => {
  switch (itemsLayout) {
    case "horizontal":
      return "vkuiInternalTabbar--layout-horizontal";
    case "vertical":
      return "vkuiInternalTabbar--layout-vertical";
    default:
      return React81.Children.count(children) > 2 ? getItemsLayoutClassName("vertical", []) : getItemsLayoutClassName("horizontal", []);
  }
};
var Tabbar = (_param) => {
  var { plain = false, mode } = _param, restProps = _object_without_properties(_param, [
    "plain",
    "mode"
  ]);
  const platform3 = usePlatform();
  return React81.createElement(RootComponent, _object_spread({
    baseClassName: classNames("vkuiInternalTabbar", "vkuiTabbar", platform3 === "ios" && "vkuiTabbar--ios", getItemsLayoutClassName(mode, restProps.children), !plain && "vkuiTabbar--shadow")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/TabbarItem/TabbarItem.js
var React82 = __toESM(require_react());
var warn6 = warnOnce("TabbarItem");
var TabbarItem = (_param) => {
  var { children, selected, indicator, text, href, Component: Component3 = href ? "a" : "button", disabled } = _param, restProps = _object_without_properties(_param, [
    "children",
    "selected",
    "indicator",
    "text",
    "href",
    "Component",
    "disabled"
  ]);
  const platform3 = usePlatform();
  if (true) {
    const hasAccessibleName2 = text || restProps["aria-label"] || restProps["aria-labelledby"];
    if (!hasAccessibleName2) {
      warn6(COMMON_WARNINGS.a11y[Component3 === "a" ? "link-name" : "button-name"], "error");
    }
  }
  return React82.createElement(RootComponent, _object_spread_props(_object_spread({
    Component: Component3
  }, restProps), {
    disabled,
    href,
    baseClassName: classNames("vkuiTabbarItem", platform3 === "ios" && "vkuiTabbarItem--ios", platform3 === "android" && "vkuiTabbarItem--android", selected && "vkuiTabbarItem--selected")
  }), React82.createElement(Tappable, {
    role: "presentation",
    disabled,
    activeMode: platform3 === "ios" ? "vkuiTabbarItem__tappable--active" : "background",
    activeEffectDelay: platform3 === "ios" ? 0 : 300,
    hasHover: false,
    className: "vkuiTabbarItem__tappable",
    onClick: noop
  }), React82.createElement("div", {
    className: "vkuiTabbarItem__in"
  }, React82.createElement("div", {
    className: "vkuiTabbarItem__icon"
  }, children, React82.createElement("div", {
    className: "vkuiInternalTabbarItem__label"
  }, hasReactNode(indicator) && indicator)), text && React82.createElement(Footnote, {
    Component: "div",
    className: "vkuiTabbarItem__text",
    weight: "2"
  }, text)));
};

// node_modules/@vkontakte/vkui/dist/components/ScrollArrow/ScrollArrow.js
var React83 = __toESM(require_react());
var stylesSize2 = {
  m: "vkuiScrollArrow--size-m",
  l: "vkuiScrollArrow--size-l"
};
var stylesDirection = {
  up: "vkuiScrollArrow--direction-up",
  right: "vkuiScrollArrow--direction-right",
  down: "vkuiScrollArrow--direction-down",
  left: "vkuiScrollArrow--direction-left"
};
var labelDirection = {
  up: "Назад",
  right: "Вперед",
  down: "Вперед",
  left: "Назад"
};
var ArrowIcon = ({ size: size4 }) => {
  let Icon = Icon24Chevron;
  if (size4 === "m") {
    Icon = Icon16Chevron;
  }
  return React83.createElement(Icon, {
    className: "vkuiScrollArrow__defaultIcon"
  });
};
var ScrollArrow = (_param) => {
  var { size: size4 = "l", offsetY, direction, label: labelProp, children = React83.createElement(ArrowIcon, {
    size: size4
  }) } = _param, restProps = _object_without_properties(_param, [
    "size",
    "offsetY",
    "direction",
    "label",
    "children"
  ]);
  const label = labelProp !== null && labelProp !== void 0 ? labelProp : labelDirection[direction];
  return React83.createElement(RootComponent, _object_spread({
    Component: "button",
    type: "button",
    baseClassName: classNames("vkuiScrollArrow", stylesSize2[size4], stylesDirection[direction])
  }, restProps), label && React83.createElement(VisuallyHidden, null, label), React83.createElement("span", {
    className: "vkuiScrollArrow__icon",
    style: offsetY ? {
      top: offsetY
    } : void 0
  }, children));
};

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalScroll.js
var React85 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useDirection.js
var React84 = __toESM(require_react());
function useDirection() {
  const ref = React84.useRef(null);
  const [direction, setDirection] = React84.useState(void 0);
  const [writingMode, setWritingMode] = React84.useState(void 0);
  const { window: window2 } = useDOM();
  const update = () => {
    if (!window2 || !ref.current) {
      return;
    }
    const styleDeclaration = window2.getComputedStyle(ref.current);
    setDirection(styleDeclaration.direction);
    setWritingMode(styleDeclaration.writingMode);
  };
  useIsomorphicLayoutEffect(update, [
    window2
  ]);
  return [
    ref,
    direction,
    writingMode
  ];
}

// node_modules/@vkontakte/vkui/dist/lib/fx.js
function easeInOutSine(x) {
  return 0.5 * (1 - Math.cos(Math.PI * x));
}
function cubicBezier(x1, x2) {
  return function(progress) {
    const t = progress;
    const cx = 3 * x1;
    const bx = 3 * (x2 - x1) - cx;
    const ax = 1 - cx - bx;
    const x = ax * Math.pow(t, 3) + bx * Math.pow(t, 2) + cx * t;
    return x;
  };
}

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalScroll.js
function now() {
  return performance && performance.now ? performance.now() : Date.now();
}
function roundingAwayFromZero(value) {
  return value > 0 ? Math.ceil(value) : Math.floor(value);
}
var roundUpElementScrollLeft = (el) => roundingAwayFromZero(el.scrollLeft);
var SCROLL_ONE_FRAME_TIME = 250;
function doScroll({ scrollElement, getScrollPosition, animationQueue, onScrollToEndBorder, onScrollEnd, onScrollStart, initialScrollWidth, scrollAnimationDuration = SCROLL_ONE_FRAME_TIME, textDirection }) {
  if (!scrollElement || !getScrollPosition) {
    return;
  }
  const extremeScrollLeft = (textDirection === "ltr" ? 1 : -1) * (initialScrollWidth - scrollElement.offsetWidth);
  let startScrollLeft = roundUpElementScrollLeft(scrollElement);
  let endScrollLeft = getScrollPosition(startScrollLeft);
  onScrollStart();
  if (startScrollLeft * endScrollLeft < 0) {
    endScrollLeft = 0;
  }
  if (Math.abs(endScrollLeft) >= Math.abs(extremeScrollLeft)) {
    onScrollToEndBorder();
    endScrollLeft = extremeScrollLeft;
  }
  const startTime = now();
  (function scroll() {
    if (!scrollElement) {
      onScrollEnd();
      return;
    }
    const time = now();
    const elapsed = Math.min((time - startTime) / scrollAnimationDuration, 1);
    const value = easeInOutSine(elapsed);
    const currentScrollLeft = startScrollLeft + (endScrollLeft - startScrollLeft) * value;
    scrollElement.scrollLeft = roundingAwayFromZero(currentScrollLeft);
    const scrollEnd = textDirection === "ltr" ? Math.max(0, endScrollLeft) : Math.min(0, endScrollLeft);
    if (roundUpElementScrollLeft(scrollElement) !== scrollEnd && elapsed !== 1) {
      requestAnimationFrame(scroll);
      return;
    }
    onScrollEnd();
    animationQueue.shift();
    if (animationQueue.length > 0) {
      animationQueue[0]();
    }
  })();
}
var HorizontalScroll = (_param) => {
  var { children, getScrollToLeft, getScrollToRight, showArrows = true, arrowSize = "l", arrowOffsetY, scrollAnimationDuration = SCROLL_ONE_FRAME_TIME, getRef, scrollOnAnyWheel = false } = _param, restProps = _object_without_properties(_param, [
    "children",
    "getScrollToLeft",
    "getScrollToRight",
    "showArrows",
    "arrowSize",
    "arrowOffsetY",
    "scrollAnimationDuration",
    "getRef",
    "scrollOnAnyWheel"
  ]);
  const [canScrollLeft, setCanScrollLeft] = React85.useState(false);
  const [canScrollRight, setCanScrollRight] = React85.useState(false);
  const [directionRef, textDirection = "ltr"] = useDirection();
  const setCanScrollStart = textDirection === "ltr" ? setCanScrollLeft : setCanScrollRight;
  const setCanScrollEnd = textDirection === "ltr" ? setCanScrollRight : setCanScrollLeft;
  const isCustomScrollingRef = React85.useRef(false);
  const scrollerRef = useExternRef(getRef, directionRef);
  const animationQueue = React85.useRef([]);
  const hasPointer = useAdaptivityHasPointer();
  const scrollTo = React85.useCallback((getScrollPosition) => {
    const scrollElement = scrollerRef.current;
    animationQueue.current.push(() => {
      var _scrollElement_firstElementChild;
      return doScroll({
        scrollElement,
        getScrollPosition,
        animationQueue: animationQueue.current,
        onScrollToEndBorder: () => setCanScrollEnd(false),
        onScrollEnd: () => isCustomScrollingRef.current = false,
        onScrollStart: () => isCustomScrollingRef.current = true,
        initialScrollWidth: (scrollElement === null || scrollElement === void 0 ? void 0 : (_scrollElement_firstElementChild = scrollElement.firstElementChild) === null || _scrollElement_firstElementChild === void 0 ? void 0 : _scrollElement_firstElementChild.scrollWidth) || 0,
        scrollAnimationDuration,
        textDirection
      });
    });
    if (animationQueue.current.length === 1) {
      animationQueue.current[0]();
    }
  }, [
    scrollerRef,
    scrollAnimationDuration,
    textDirection,
    setCanScrollEnd
  ]);
  const scrollToLeft = React85.useCallback(() => {
    const getScrollPosition = getScrollToLeft !== null && getScrollToLeft !== void 0 ? getScrollToLeft : (i) => i - scrollerRef.current.offsetWidth;
    scrollTo(getScrollPosition);
  }, [
    getScrollToLeft,
    scrollTo,
    scrollerRef
  ]);
  const scrollToRight = React85.useCallback(() => {
    const getScrollPosition = getScrollToRight !== null && getScrollToRight !== void 0 ? getScrollToRight : (i) => i + scrollerRef.current.offsetWidth;
    scrollTo(getScrollPosition);
  }, [
    getScrollToRight,
    scrollTo,
    scrollerRef
  ]);
  const calculateArrowsVisibility = React85.useCallback(() => {
    if (showArrows && hasPointer && scrollerRef.current && !isCustomScrollingRef.current) {
      const scrollElement = scrollerRef.current;
      setCanScrollStart(scrollElement.scrollLeft !== 0);
      setCanScrollEnd(Math.abs(roundUpElementScrollLeft(scrollElement)) + scrollElement.offsetWidth < scrollElement.scrollWidth);
    }
  }, [
    showArrows,
    hasPointer,
    scrollerRef,
    setCanScrollStart,
    setCanScrollEnd
  ]);
  const scrollEvent = useEventListener("scroll", calculateArrowsVisibility);
  React85.useEffect(function addScrollerRefToScrollEvent() {
    if (!scrollerRef.current) {
      return noop;
    }
    scrollEvent.add(scrollerRef.current);
    return scrollEvent.remove;
  }, [
    scrollEvent,
    scrollerRef
  ]);
  React85.useEffect(calculateArrowsVisibility, [
    calculateArrowsVisibility,
    children
  ]);
  const onwheel = React85.useCallback((e) => {
    scrollerRef.current.scrollBy({
      left: e.deltaX + e.deltaY,
      behavior: "auto"
    });
    e.preventDefault();
  }, [
    scrollerRef
  ]);
  const wheelEvent = useEventListener("wheel", onwheel);
  React85.useEffect(function addScrollerRefToWheelEvent() {
    if (!scrollerRef.current || !scrollOnAnyWheel) {
      return noop;
    }
    wheelEvent.add(scrollerRef.current);
    return wheelEvent.remove;
  }, [
    wheelEvent,
    scrollerRef,
    scrollOnAnyWheel
  ]);
  return React85.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiHorizontalScroll", "vkuiInternalHorizontalScroll", showArrows === "always" && "vkuiHorizontalScroll--withConstArrows"),
    onMouseEnter: calculateArrowsVisibility
  }), showArrows && (hasPointer || hasPointer === void 0) && canScrollLeft && React85.createElement(ScrollArrow, {
    "data-testid": false ? "ScrollArrow" : void 0,
    size: arrowSize,
    offsetY: arrowOffsetY,
    direction: "left",
    "aria-hidden": true,
    tabIndex: -1,
    className: classNames("vkuiHorizontalScroll__arrow", "vkuiHorizontalScroll__arrowLeft"),
    onClick: scrollToLeft
  }), showArrows && (hasPointer || hasPointer === void 0) && canScrollRight && React85.createElement(ScrollArrow, {
    "data-testid": false ? "ScrollArrow" : void 0,
    size: arrowSize,
    offsetY: arrowOffsetY,
    direction: "right",
    "aria-hidden": true,
    tabIndex: -1,
    className: classNames("vkuiHorizontalScroll__arrow", "vkuiHorizontalScroll__arrowRight"),
    onClick: scrollToRight
  }), React85.createElement("div", {
    className: "vkuiHorizontalScroll__in",
    ref: scrollerRef
  }, React85.createElement("div", {
    className: "vkuiHorizontalScroll__in-wrapper"
  }, children)));
};

// node_modules/@vkontakte/vkui/dist/components/AspectRatio/AspectRatio.js
var React86 = __toESM(require_react());
function AspectRatio(_param) {
  var { ratio, mode = "stretch", style: styleProp } = _param, props = _object_without_properties(_param, [
    "ratio",
    "mode",
    "style"
  ]);
  const style = {
    ["--vkui_internal--aspect_ratio"]: String(ratio)
  };
  return React86.createElement(RootComponent, _object_spread({
    baseClassName: classNames("vkuiAspectRatio", mode === "stretch" && "vkuiAspectRatio--mode-stretch"),
    style: _object_spread({}, styleProp, style)
  }, props));
}

// node_modules/@vkontakte/vkui/dist/components/PopoutWrapper/PopoutWrapper.js
var React87 = __toESM(require_react());
var stylesAlignX = {
  center: "vkuiPopoutWrapper--alignX-center",
  left: "vkuiPopoutWrapper--alignX-left",
  right: "vkuiPopoutWrapper--alignX-right"
};
var stylesAlignY = {
  center: "vkuiPopoutWrapper--alignY-center",
  top: "vkuiPopoutWrapper--alignY-top",
  bottom: "vkuiPopoutWrapper--alignY-bottom"
};
var PopoutWrapper = (_param) => {
  var { alignY = "center", alignX = "center", closing = false, noBackground = false, fixed = true, children, onClick } = _param, restProps = _object_without_properties(_param, [
    "alignY",
    "alignX",
    "closing",
    "noBackground",
    "fixed",
    "children",
    "onClick"
  ]);
  const platform3 = usePlatform();
  const [opened, setOpened] = React87.useState(noBackground);
  const onFadeInEnd = (e) => {
    if (!e || e.animationName === "vkuianimation-full-fade-in") {
      setOpened(true);
    }
  };
  const animationFinishFallback = useTimeout(onFadeInEnd, platform3 === "ios" ? 300 : 200);
  React87.useEffect(() => {
    !opened && animationFinishFallback.set();
  }, [
    animationFinishFallback,
    opened
  ]);
  return React87.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiPopoutWrapper", stylesAlignY[alignY], stylesAlignX[alignX], closing && "vkuiPopoutWrapper--closing", opened && "vkuiPopoutWrapper--opened", fixed && "vkuiPopoutWrapper--fixed", !noBackground && "vkuiPopoutWrapper--masked"),
    onAnimationEnd: opened ? void 0 : onFadeInEnd
  }), React87.createElement("div", {
    className: "vkuiPopoutWrapper__container"
  }, React87.createElement("div", {
    className: "vkuiPopoutWrapper__overlay",
    onClick
  }), React87.createElement("div", {
    className: "vkuiPopoutWrapper__content"
  }, children)));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/Alert.js
var React94 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityWithJSMediaQueries.js
var React88 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/getOrDefault.js
function getOrDefault(value, defaultValue) {
  return value !== null && value !== void 0 ? value : defaultValue;
}

// node_modules/@vkontakte/vkui/dist/hooks/useAdaptivityWithJSMediaQueries.js
var useAdaptivityWithJSMediaQueries = () => {
  if (!canUseDOM) {
    console.error(`[useAdaptivityWithJSMediaQueries] Похоже, вы пытаетесь использовать хук вне браузера.

Постарайтесь этого избегать, чтобы не было ошибок при гидратации: при SSR нет информации о размерах экрана.

Используйте CSS Media Query или библиотеку по типу https://github.com/artsy/fresnel.`);
  }
  const { viewWidth: viewWidthContext, viewHeight: viewHeightContext, sizeX: sizeXContext, sizeY: sizeYContext, hasPointer: hasPointerContext, hasHover: hasHoverContext } = React88.useContext(AdaptivityContext);
  const platform3 = usePlatform();
  const mediaQueries = useMediaQueries();
  const [[viewWidthLocal, viewHeightLocal], setViewSizeLocal] = React88.useState(() => [
    getOrDefault(viewWidthContext, getViewWidthByMediaQueries(mediaQueries)),
    getOrDefault(viewHeightContext, getViewHeightByMediaQueries(mediaQueries))
  ]);
  const adaptivityProps = React88.useMemo(() => {
    const hasPointer = getOrDefault(hasPointerContext, hasMouse);
    const hasHover2 = getOrDefault(hasHoverContext, hasHover);
    const viewWidth = getOrDefault(viewWidthContext, viewWidthLocal);
    const viewHeight = getOrDefault(viewHeightContext, viewHeightLocal);
    const sizeX = getOrDefault(sizeXContext, getSizeX(viewWidth));
    const sizeY = getOrDefault(sizeYContext, getSizeY(viewWidth, viewHeight, hasPointer));
    const isDesktop = tryToCheckIsDesktop(viewWidth, viewHeight, hasPointer, platform3);
    return {
      viewWidth,
      viewHeight,
      sizeX,
      sizeY,
      hasPointer,
      hasHover: hasHover2,
      isDesktop
    };
  }, [
    viewWidthLocal,
    viewHeightLocal,
    viewWidthContext,
    viewHeightContext,
    sizeXContext,
    sizeYContext,
    hasPointerContext,
    hasHoverContext,
    platform3
  ]);
  React88.useEffect(() => {
    const handleMediaQuery = () => {
      setViewSizeLocal((prevSizeLocal) => {
        const newViewWidthLocal = getOrDefault(viewWidthContext, getViewWidthByMediaQueries(mediaQueries));
        const newViewHeightLocal = getOrDefault(viewHeightContext, getViewHeightByMediaQueries(mediaQueries));
        const [prevViewWidthLocal, prevViewHeightLocal] = prevSizeLocal;
        if (prevViewWidthLocal !== newViewWidthLocal || prevViewHeightLocal !== newViewHeightLocal) {
          return [
            newViewWidthLocal,
            newViewHeightLocal
          ];
        }
        return prevSizeLocal;
      });
    };
    if (!viewWidthContext) {
      [
        mediaQueries.desktopPlus,
        mediaQueries.tablet,
        mediaQueries.smallTablet,
        mediaQueries.mobile
      ].forEach((matchMediaListener) => matchMediaListAddListener(matchMediaListener, handleMediaQuery));
    }
    if (!viewHeightContext) {
      [
        mediaQueries.mediumHeight,
        mediaQueries.mobileLandscapeHeight
      ].forEach((matchMediaListener) => matchMediaListAddListener(matchMediaListener, handleMediaQuery));
    }
    return () => {
      [
        mediaQueries.desktopPlus,
        mediaQueries.tablet,
        mediaQueries.smallTablet,
        mediaQueries.mobile,
        mediaQueries.mediumHeight,
        mediaQueries.mobileLandscapeHeight
      ].forEach((matchMediaListener) => matchMediaListRemoveListener(matchMediaListener, handleMediaQuery));
    };
  }, [
    mediaQueries,
    viewWidthContext,
    viewHeightContext
  ]);
  return adaptivityProps;
};

// node_modules/@vkontakte/vkui/dist/components/FocusTrap/FocusTrap.js
var React89 = __toESM(require_react());
var FOCUSABLE_ELEMENTS = FOCUSABLE_ELEMENTS_LIST.join();
var FocusTrap = (_param) => {
  var { Component: Component3 = "div", onClose, autoFocus = true, restoreFocus = true, timeout = 0, getRootRef, children } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "onClose",
    "autoFocus",
    "restoreFocus",
    "timeout",
    "getRootRef",
    "children"
  ]);
  const ref = useExternRef(getRootRef);
  const { keyboardInput } = React89.useContext(AppRootContext);
  const focusableNodesRef = React89.useRef([]);
  useIsomorphicLayoutEffect(function collectFocusableNodesRef() {
    if (!ref.current) {
      return;
    }
    const nodes = [];
    ref.current.querySelectorAll(FOCUSABLE_ELEMENTS).forEach((focusableEl) => {
      const { display, visibility } = getComputedStyle(focusableEl);
      if (display !== "none" && visibility !== "hidden") {
        nodes.push(focusableEl);
      }
    });
    if (nodes.length === 0) {
      nodes.push(ref.current);
    }
    focusableNodesRef.current = nodes;
  }, [
    children
  ]);
  useIsomorphicLayoutEffect(function tryToAutoFocusToFirstNode() {
    if (!ref.current || !autoFocus || !keyboardInput) {
      return;
    }
    const autoFocusToFirstNode = () => {
      if (!ref.current || !focusableNodesRef.current.length) {
        return;
      }
      const activeElement = getActiveElementByAnotherElement(ref.current);
      if (!contains(ref.current, activeElement)) {
        focusableNodesRef.current[0].focus();
      }
    };
    const timeoutId = setTimeout(autoFocusToFirstNode, timeout);
    return () => {
      clearTimeout(timeoutId);
    };
  }, [
    autoFocus,
    timeout,
    keyboardInput
  ]);
  useIsomorphicLayoutEffect(function tryToRestoreFocusOnUnmount() {
    if (!ref.current || !restoreFocus) {
      return;
    }
    const restoreFocusTo = getActiveElementByAnotherElement(ref.current);
    return () => {
      const shouldRestoreFocus = typeof restoreFocus === "function" ? restoreFocus() : restoreFocus;
      if (!shouldRestoreFocus || !isHTMLElement(restoreFocusTo)) {
        return;
      }
      setTimeout(() => {
        if (restoreFocusTo) {
          restoreFocusTo.focus();
        }
      }, timeout);
    };
  }, [
    restoreFocus,
    timeout
  ]);
  useIsomorphicLayoutEffect(() => {
    if (!ref.current) {
      return;
    }
    const onDocumentKeydown = (event) => {
      const pressedKeyResult = pressedKey(event);
      switch (pressedKeyResult) {
        case Keys.TAB: {
          if (!focusableNodesRef.current.length) {
            return false;
          }
          const lastIdx = focusableNodesRef.current.length - 1;
          const targetIdx = focusableNodesRef.current.findIndex((node) => node === event.target);
          const shouldFocusFirstNode = targetIdx === -1 || targetIdx === lastIdx && !event.shiftKey;
          if (shouldFocusFirstNode || targetIdx === 0 && event.shiftKey) {
            event.preventDefault();
            const node = focusableNodesRef.current[shouldFocusFirstNode ? 0 : lastIdx];
            if (node !== getActiveElementByAnotherElement(node)) {
              node.focus();
            }
            return false;
          }
          break;
        }
        case Keys.ESCAPE: {
          if (onClose) {
            event.preventDefault();
            onClose();
          }
        }
      }
      return true;
    };
    const doc = getWindow(ref.current).document;
    doc.addEventListener("keydown", onDocumentKeydown, {
      capture: true
    });
    return () => {
      doc.removeEventListener("keydown", onDocumentKeydown, true);
    };
  }, [
    onClose,
    ref
  ]);
  return React89.createElement(Component3, _object_spread({
    tabIndex: -1,
    ref
  }, restProps), children);
};

// node_modules/@vkontakte/vkui/dist/components/ModalDismissButton/ModalDismissButton.js
var React90 = __toESM(require_react());
var ModalDismissButton = (_param) => {
  var { children = "Закрыть", className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  return React90.createElement(Tappable, _object_spread_props(_object_spread({
    className: classNames("vkuiModalDismissButton", className)
  }, restProps), {
    activeMode: "vkuiModalDismissButton--active",
    hoverMode: "vkuiModalDismissButton--hover"
  }), children && React90.createElement(VisuallyHidden, null, children), React90.createElement(Icon20Cancel, null));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertActions.js
var React92 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertAction.js
var React91 = __toESM(require_react());
var AlertActionIos = (_param) => {
  var { mode } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  return React91.createElement(Tappable, _object_spread({
    Component: restProps.href ? "a" : "button",
    className: classNames("vkuiAlert__action", mode === "destructive" && "vkuiAlert__action--mode-destructive", mode === "cancel" && "vkuiAlert__action--mode-cancel")
  }, restProps));
};
var AlertActionBase = (_param) => {
  var { mode } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  const platform3 = usePlatform();
  let buttonMode = "tertiary";
  if (platform3 === "vkcom") {
    buttonMode = mode === "cancel" ? "secondary" : "primary";
  }
  return React91.createElement(Button, _object_spread({
    className: classNames("vkuiAlert__button", mode === "cancel" && "vkuiAlert__button--mode-cancel"),
    mode: buttonMode,
    size: "m"
  }, restProps));
};
var AlertAction = (props) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return React91.createElement(AlertActionIos, props);
  }
  return React91.createElement(AlertActionBase, props);
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertActions.js
var alignStyles = {
  left: "vkuiAlert__actions--align-left",
  center: "vkuiAlert__actions--align-center",
  right: "vkuiAlert__actions--align-right"
};
var directionStyles = {
  vertical: "vkuiAlert__actions--direction-vertical",
  horizontal: "vkuiAlert__actions--direction-horizontal"
};
var AlertActions = ({ actions = [], renderAction = (props) => React92.createElement(AlertAction, props), onItemClick, actionsAlign, actionsLayout }) => {
  const platform3 = usePlatform();
  const direction = platform3 === "vkcom" ? "horizontal" : actionsLayout;
  return React92.createElement("div", {
    className: classNames("vkuiAlert__actions", actionsAlign && alignStyles[actionsAlign], direction && directionStyles[direction])
  }, actions.map((action, i) => {
    const { title: children, action: _, autoCloseDisabled } = action, restProps = _object_without_properties(action, [
      "title",
      "action",
      "autoCloseDisabled"
    ]);
    return React92.createElement(React92.Fragment, {
      key: i
    }, renderAction(_object_spread({
      children,
      onClick: () => onItemClick(action)
    }, restProps)));
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Alert/AlertTypography.js
var React93 = __toESM(require_react());
var AlertHeader = (props) => {
  const platform3 = usePlatform();
  switch (platform3) {
    case "ios":
      return React93.createElement(Title, _object_spread({
        className: "vkuiAlert__header",
        weight: "1",
        level: "3"
      }, props));
    default:
      return React93.createElement(Title, _object_spread({
        className: "vkuiAlert__header",
        weight: "2",
        level: "2"
      }, props));
  }
};
var AlertText = (props) => {
  const platform3 = usePlatform();
  switch (platform3) {
    case "vkcom":
      return React93.createElement(Footnote, _object_spread({
        className: "vkuiAlert__text"
      }, props));
    case "ios":
      return React93.createElement(Caption, _object_spread({
        className: "vkuiAlert__text"
      }, props));
    default:
      return React93.createElement(Text, _object_spread({
        Component: "span",
        className: "vkuiAlert__text",
        weight: "3"
      }, props));
  }
};

// node_modules/@vkontakte/vkui/dist/components/Alert/Alert.js
var Alert = (_param) => {
  var { actions = [], actionsLayout = "horizontal", children, className, style, text, header, onClose, dismissLabel = "Закрыть предупреждение", renderAction, actionsAlign, dismissButtonMode = "outside", dismissButtonTestId, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "actions",
    "actionsLayout",
    "children",
    "className",
    "style",
    "text",
    "header",
    "onClose",
    "dismissLabel",
    "renderAction",
    "actionsAlign",
    "dismissButtonMode",
    "dismissButtonTestId",
    "getRootRef"
  ]);
  const generatedId = React94.useId();
  const headerId = `vkui-alert-${generatedId}-header`;
  const textId = `vkui-alert-${generatedId}-text`;
  const platform3 = usePlatform();
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const { waitTransitionFinish } = useWaitTransitionFinish();
  const [closing, setClosing] = React94.useState(false);
  const isDismissButtonVisible = isDesktop && platform3 !== "ios";
  const elementRef = React94.useRef(null);
  const timeout = platform3 === "ios" ? 300 : 200;
  const close = React94.useCallback(() => {
    setClosing(true);
    waitTransitionFinish(elementRef.current, (e) => {
      if (!e || e.propertyName === "opacity") {
        onClose();
      }
    }, timeout);
  }, [
    elementRef,
    waitTransitionFinish,
    onClose,
    timeout
  ]);
  const onItemClick = React94.useCallback((item) => {
    const { action, autoCloseDisabled = false } = item;
    if (!autoCloseDisabled) {
      setClosing(true);
      waitTransitionFinish(elementRef.current, (e) => {
        if (!e || e.propertyName === "opacity") {
          onClose();
          action && action();
        }
      }, timeout);
    } else {
      action && action();
    }
  }, [
    elementRef,
    waitTransitionFinish,
    onClose,
    timeout
  ]);
  useScrollLock();
  return React94.createElement(PopoutWrapper, {
    className,
    closing,
    style,
    onClick: close,
    getRootRef
  }, React94.createElement(FocusTrap, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: elementRef,
    onClick: stopPropagation,
    onClose: close,
    timeout,
    className: classNames("vkuiAlert", platform3 === "ios" && "vkuiAlert--ios", platform3 === "vkcom" && "vkuiAlert--vkcom", closing && "vkuiAlert--closing", isDesktop && "vkuiAlert--desktop"),
    role: "alertdialog",
    "aria-modal": true,
    "aria-labelledby": headerId,
    "aria-describedby": textId
  }), React94.createElement("div", {
    className: classNames("vkuiAlert__content", dismissButtonMode === "inside" && "vkuiAlert__content--withButton")
  }, hasReactNode(header) && React94.createElement(AlertHeader, {
    id: headerId
  }, header), hasReactNode(text) && React94.createElement(AlertText, {
    id: textId
  }, text), children, isDismissButtonVisible && dismissButtonMode === "inside" && React94.createElement(IconButton, {
    label: dismissLabel,
    className: classNames("vkuiAlert__dismiss", "vkuiInternalAlert__dismiss"),
    onClick: close,
    hoverMode: "opacity",
    activeMode: "opacity",
    "data-testid": dismissButtonTestId
  }, React94.createElement(Icon20Cancel, null))), React94.createElement(AlertActions, {
    actions,
    actionsAlign,
    actionsLayout,
    renderAction,
    onItemClick
  }), isDismissButtonVisible && dismissButtonMode === "outside" && React94.createElement(ModalDismissButton, {
    onClick: close,
    "data-testid": dismissButtonTestId
  }, dismissLabel)));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheet.js
var React105 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetContext.js
var React95 = __toESM(require_react());
var ActionSheetContext = React95.createContext({});

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDefaultIosCloseItem.js
var React99 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/ActionSheetItem.js
var React98 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/subcomponents/Radio/Radio.js
var React97 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/AdaptiveIconRenderer/AdaptiveIconRenderer.js
var React96 = __toESM(require_react());
var AdaptiveIconRenderer = ({ IconCompact, IconRegular }) => {
  const { sizeY } = useAdaptivityConditionalRender();
  return React96.createElement(React96.Fragment, null, sizeY.compact && React96.createElement(IconCompact, {
    className: sizeY.compact.className
  }), sizeY.regular && React96.createElement(IconRegular, {
    className: sizeY.regular.className
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/subcomponents/Radio/Radio.js
var adaptiveIcon = React97.createElement(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckCircleOn,
  IconRegular: Icon24CheckCircleOn
});
var Radio = (_param) => {
  var { children = adaptiveIcon, getRootRef, getRef, className, style } = _param, restProps = _object_without_properties(_param, [
    "children",
    "getRootRef",
    "getRef",
    "className",
    "style"
  ]);
  return React97.createElement(RootComponent, {
    getRootRef,
    className,
    style
  }, React97.createElement(VisuallyHidden, _object_spread({
    Component: "input",
    getRootRef: getRef,
    type: "radio",
    className: "vkuiActionSheetItemRadio__input"
  }, restProps)), children);
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheetItem/ActionSheetItem.js
var ActionSheetItem = (_param) => {
  var { children, autoCloseDisabled = false, mode = "default", meta, subtitle, before, after, selectable, value, name, checked, defaultChecked, onChange, onClick, onImmediateClick, multiline = false, iconChecked, className, isCancelItem } = _param, restProps = _object_without_properties(_param, [
    "children",
    "autoCloseDisabled",
    "mode",
    "meta",
    "subtitle",
    "before",
    "after",
    "selectable",
    "value",
    "name",
    "checked",
    "defaultChecked",
    "onChange",
    "onClick",
    "onImmediateClick",
    "multiline",
    "iconChecked",
    "className",
    "isCancelItem"
  ]);
  const platform3 = usePlatform();
  const { onItemClick = () => noop, mode: actionSheetMode } = React98.useContext(ActionSheetContext);
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const Component3 = selectable ? "label" : void 0;
  const isRich = subtitle || meta || selectable;
  const isCentered = !isRich && !before && platform3 === "ios";
  return React98.createElement(Tappable, _object_spread_props(_object_spread({}, Component3 && {
    Component: Component3
  }, restProps), {
    onClick: selectable ? onClick : onItemClick({
      action: onClick,
      immediateAction: onImmediateClick,
      autoClose: !autoCloseDisabled,
      isCancelItem: Boolean(isCancelItem)
    }),
    activeMode: platform3 === "ios" ? "vkuiActionSheetItem--active" : void 0,
    className: classNames("vkuiActionSheetItem", platform3 === "ios" && "vkuiActionSheetItem--ios", mode === "cancel" && "vkuiActionSheetItem--mode-cancel", mode === "destructive" && "vkuiActionSheetItem--mode-destructive", sizeY === "compact" && "vkuiActionSheetItem--sizeY-compact", isRich && "vkuiActionSheetItem--rich", actionSheetMode === "menu" && "vkuiActionSheetItem--menu", selectable && "vkuiActionSheetItem--selectable", className)
  }), before && React98.createElement("div", {
    className: "vkuiActionSheetItem__before"
  }, before), React98.createElement("div", {
    className: classNames("vkuiActionSheetItem__container", !multiline && "vkuiActionSheetItem--ellipsis")
  }, React98.createElement("div", {
    className: classNames("vkuiActionSheetItem__content", isCentered && "vkuiActionSheetItem--centered")
  }, platform3 === "ios" ? React98.createElement(Title, {
    className: "vkuiActionSheetItem__children",
    weight: mode === "cancel" ? "2" : "3",
    level: isCentered ? "2" : "3"
  }, children) : React98.createElement(Text, {
    className: "vkuiActionSheetItem__children"
  }, children), meta && React98.createElement(Text, {
    className: "vkuiActionSheetItem__meta"
  }, meta)), subtitle && React98.createElement(Subhead, {
    className: "vkuiActionSheetItem__subtitle"
  }, subtitle)), (selectable || after) && React98.createElement("div", {
    className: "vkuiActionSheetItem__after"
  }, after, selectable && React98.createElement(Radio, {
    name,
    value,
    onChange,
    onClick: onItemClick({
      action: noop,
      immediateAction: noop,
      autoClose: !autoCloseDisabled,
      isCancelItem: Boolean(isCancelItem)
    }),
    defaultChecked,
    checked,
    disabled: restProps.disabled
  }, iconChecked)));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDefaultIosCloseItem.js
var ActionSheetDefaultIosCloseItem = (props) => {
  return React99.createElement(ActionSheetItem, _object_spread({
    mode: "cancel",
    isCancelItem: true
  }, props), "Отмена");
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownMenu.js
var React103 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useEffectDev.js
var import_react4 = __toESM(require_react());
var useEffectDev = true ? import_react4.useEffect : noop;

// node_modules/@vkontakte/vkui/dist/components/Popper/Popper.js
var React102 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/FloatingArrow/DefaultIcon.js
var React100 = __toESM(require_react());
var DEFAULT_ARROW_WIDTH = 20;
var DEFAULT_ARROW_HEIGHT = 8;
var DEFAULT_ARROW_PADDING = 10;
var PLATFORM_HEIGHT = 1;
var ARROW_HEIGHT_WITH_WHITE_SPACE = DEFAULT_ARROW_HEIGHT + PLATFORM_HEIGHT;
var DefaultIcon = (props) => {
  return React100.createElement("svg", _object_spread({
    width: DEFAULT_ARROW_WIDTH,
    height: ARROW_HEIGHT_WITH_WHITE_SPACE,
    viewBox: `0 0 ${DEFAULT_ARROW_WIDTH} ${ARROW_HEIGHT_WITH_WHITE_SPACE}`,
    xmlns: "http://www.w3.org/2000/svg"
  }, props), React100.createElement("path", {
    d: "M10 0c3 0 6 8 10 8v1H0V8c3.975 0 7-8 10-8Z",
    fill: "currentColor"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FloatingArrow/FloatingArrow.js
var React101 = __toESM(require_react());
var placementClassNames = {
  right: "vkuiFloatingArrow--placement-right",
  bottom: "vkuiFloatingArrow--placement-bottom",
  left: "vkuiFloatingArrow--placement-left"
};
var FloatingArrow = (_param) => {
  var { offset: offset3, isStaticOffset, coords, iconStyle, iconClassName, placement = "bottom", getRootRef, Icon = DefaultIcon } = _param, restProps = _object_without_properties(_param, [
    "offset",
    "isStaticOffset",
    "coords",
    "iconStyle",
    "iconClassName",
    "placement",
    "getRootRef",
    "Icon"
  ]);
  const [arrowPlacement, arrowStyles] = getArrowPositionData(placement, coords, offset3, isStaticOffset);
  return React101.createElement("div", _object_spread({
    ref: getRootRef,
    style: arrowStyles,
    className: classNames("vkuiFloatingArrow", arrowPlacement && placementClassNames[arrowPlacement])
  }, restProps), React101.createElement(Icon, {
    className: classNames("vkuiFloatingArrow__in", iconClassName),
    style: iconStyle
  }));
};
function getArrowPositionData(placement, coords = {
  x: 0,
  y: 0
}, offset3 = 0, isStaticOffset = false) {
  const withOffset = (isVerticalPlacement) => {
    const parsedCoords = {
      x: coords.x || 0,
      y: coords.y || 0
    };
    if (isVerticalPlacement) {
      return isStaticOffset ? offset3 : parsedCoords.y + offset3;
    } else {
      return isStaticOffset ? offset3 : parsedCoords.x + offset3;
    }
  };
  if (placement.startsWith("top")) {
    return [
      "bottom",
      {
        top: "100%",
        left: withOffset(false)
      }
    ];
  } else if (placement.startsWith("right")) {
    return [
      "left",
      {
        top: withOffset(true),
        left: 0
      }
    ];
  } else if (placement.startsWith("bottom")) {
    return [
      void 0,
      {
        bottom: "100%",
        left: withOffset(false)
      }
    ];
  } else {
    return [
      "right",
      {
        top: withOffset(true),
        right: 0
      }
    ];
  }
}

// node_modules/@vkontakte/vkui/dist/components/Popper/Popper.js
var Popper = (_param) => {
  var {
    // UseFloatingMiddlewaresBootstrapProps
    placement: placementProp = "bottom-start",
    sameWidth,
    hideWhenReferenceHidden,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    arrow: arrow4,
    arrowHeight = DEFAULT_ARROW_HEIGHT,
    arrowPadding = DEFAULT_ARROW_PADDING,
    customMiddlewares,
    // UseFloatingProps
    autoUpdateOnTargetResize = false,
    // ArrowProps
    arrowProps,
    ArrowIcon: ArrowIcon2 = DefaultIcon,
    // rest
    targetRef,
    getRootRef,
    children,
    usePortal = true,
    style: styleProp,
    onPlacementChange
  } = _param, restProps = _object_without_properties(_param, [
    "placement",
    "sameWidth",
    "hideWhenReferenceHidden",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "arrow",
    "arrowHeight",
    "arrowPadding",
    "customMiddlewares",
    "autoUpdateOnTargetResize",
    "arrowProps",
    "ArrowIcon",
    "targetRef",
    "getRootRef",
    "children",
    "usePortal",
    "style",
    "onPlacementChange"
  ]);
  const [arrowRef, setArrowRef] = React102.useState(null);
  const { strictPlacement, middlewares } = useFloatingMiddlewaresBootstrap({
    placement: placementProp,
    sameWidth,
    arrow: arrow4,
    arrowRef,
    arrowHeight,
    arrowPadding,
    offsetByMainAxis,
    offsetByCrossAxis,
    hideWhenReferenceHidden,
    customMiddlewares
  });
  const { x: floatingDataX, y: floatingDataY, strategy: floatingPositionStrategy, placement: resolvedPlacement, refs, middlewareData } = useFloating({
    placement: strictPlacement,
    middleware: middlewares,
    whileElementsMounted(...args) {
      return autoUpdateFloatingElement(...args, {
        elementResize: autoUpdateOnTargetResize
      });
    }
  });
  usePlacementChangeCallback(resolvedPlacement, onPlacementChange);
  const { arrow: arrowCoords } = middlewareData;
  const handleRootRef = useExternRef(refs.setFloating, getRootRef);
  useIsomorphicLayoutEffect(() => {
    refs.setReference("current" in targetRef ? targetRef.current : targetRef);
  }, [
    refs.setReference,
    targetRef
  ]);
  const dropdown = React102.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: "vkuiPopper",
    getRootRef: handleRootRef,
    style: _object_spread({}, styleProp, convertFloatingDataToReactCSSProperties(floatingPositionStrategy, floatingDataX, floatingDataY, sameWidth ? null : void 0, middlewareData))
  }), arrow4 && React102.createElement(FloatingArrow, _object_spread_props(_object_spread({}, arrowProps), {
    coords: arrowCoords,
    placement: resolvedPlacement,
    getRootRef: setArrowRef,
    Icon: ArrowIcon2
  })), children);
  return React102.createElement(AppRootPortal, {
    usePortal
  }, dropdown);
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownMenu.js
var warn7 = warnOnce("ActionSheet");
function getEl(ref) {
  return ref && "current" in ref ? ref.current : ref;
}
var ActionSheetDropdownMenu = (_param) => {
  var { children, toggleRef, closing, onClose, className, style, popupOffsetDistance = 0, placement } = _param, restProps = _object_without_properties(_param, [
    "children",
    "toggleRef",
    "closing",
    "onClose",
    "className",
    "style",
    "popupOffsetDistance",
    "placement"
  ]);
  const { document: document2 } = useDOM();
  const platform3 = usePlatform();
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const elementRef = React103.useRef(null);
  useEffectDev(() => {
    const toggleEl = getEl(toggleRef);
    if (!toggleEl) {
      warn7(`Свойство "toggleRef" не передано`, "error");
    }
  }, [
    toggleRef
  ]);
  const bodyClickListener = useEventListener("click", (e) => {
    const dropdownElement = elementRef === null || elementRef === void 0 ? void 0 : elementRef.current;
    if (dropdownElement && !dropdownElement.contains(e.target)) {
      onClose === null || onClose === void 0 ? void 0 : onClose();
    }
  });
  React103.useEffect(() => {
    setTimeout(() => {
      bodyClickListener.add(document2.body);
    });
  }, [
    bodyClickListener,
    document2
  ]);
  const onClick = React103.useCallback((e) => e.stopPropagation(), []);
  const targetRef = React103.useMemo(() => {
    if (isRefObject(toggleRef)) {
      return toggleRef;
    }
    return {
      current: toggleRef
    };
  }, [
    toggleRef
  ]);
  return React103.createElement(Popper, {
    targetRef,
    offsetByMainAxis: popupOffsetDistance,
    placement,
    className: classNames("vkuiActionSheet", platform3 === "ios" && "vkuiActionSheet--ios", "vkuiActionSheet--menu", sizeY === "compact" && "vkuiActionSheet--sizeY-compact", className),
    style,
    getRootRef: elementRef,
    usePortal: false
  }, React103.createElement(FocusTrap, _object_spread_props(_object_spread({
    onClose
  }, restProps), {
    onClick
  }), children));
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheetDropdownSheet.js
var React104 = __toESM(require_react());
var stopPropagation2 = (e) => e.stopPropagation();
var ActionSheetDropdownSheet = (_param) => {
  var {
    children,
    closing,
    // these 2 props are only omitted - ActionSheetDesktop compat
    toggleRef,
    className
  } = _param, restProps = _object_without_properties(_param, [
    "children",
    "closing",
    "toggleRef",
    "className"
  ]);
  const { sizeY } = useAdaptivityWithJSMediaQueries();
  const platform3 = usePlatform();
  return React104.createElement(FocusTrap, _object_spread_props(_object_spread({}, restProps), {
    onClick: stopPropagation2,
    className: classNames("vkuiActionSheet", platform3 === "ios" && "vkuiActionSheet--ios", closing && "vkuiActionSheet--closing", sizeY === "compact" && "vkuiActionSheet--sizeY-compact", className)
  }), children);
};

// node_modules/@vkontakte/vkui/dist/components/ActionSheet/ActionSheet.js
var ActionSheet = (_param) => {
  var { children, className, header, text, style, iosCloseItem, popupOffsetDistance, placement, mode: modeProp } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "header",
    "text",
    "style",
    "iosCloseItem",
    "popupOffsetDistance",
    "placement",
    "mode"
  ]);
  const platform3 = usePlatform();
  const [closingBy, setClosingBy] = React105.useState(void 0);
  const onClose = () => setClosingBy("other");
  const _action = React105.useRef(noop);
  const afterClose = () => {
    restProps.onClose({
      closedBy: closingBy || "other"
    });
    _action.current();
    _action.current = noop;
  };
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const mode = modeProp !== null && modeProp !== void 0 ? modeProp : isDesktop ? "menu" : "sheet";
  useScrollLock(mode === "sheet");
  let timeout = platform3 === "ios" ? 300 : 200;
  if (mode === "menu") {
    timeout = 0;
  }
  const fallbackTransitionFinish = useTimeout(afterClose, timeout);
  React105.useEffect(() => {
    if (closingBy) {
      fallbackTransitionFinish.set();
    } else {
      fallbackTransitionFinish.clear();
    }
  }, [
    closingBy,
    fallbackTransitionFinish
  ]);
  const onItemClick = React105.useCallback(({ action, immediateAction, autoClose, isCancelItem }) => (event) => {
    event.persist();
    immediateAction && immediateAction(event);
    if (autoClose) {
      _action.current = () => action && action(event);
      setClosingBy(isCancelItem ? "cancel-item" : "action-item");
    } else {
      action && action(event);
    }
  }, []);
  const contextValue = useObjectMemo({
    onItemClick,
    mode
  });
  const DropdownComponent = mode === "menu" ? ActionSheetDropdownMenu : ActionSheetDropdownSheet;
  const dropdownProps = mode === "menu" ? Object.assign(restProps, {
    popupOffsetDistance,
    placement
  }) : restProps;
  const actionSheet = React105.createElement(ActionSheetContext.Provider, {
    value: contextValue
  }, React105.createElement(DropdownComponent, _object_spread_props(_object_spread({
    closing: Boolean(closingBy),
    timeout
  }, dropdownProps), {
    onClose,
    className: mode === "menu" ? className : void 0,
    style: mode === "menu" ? style : void 0
  }), React105.createElement("div", {
    className: "vkuiActionSheet__content-wrapper"
  }, (header || text) && React105.createElement("div", {
    className: "vkuiActionSheet__header"
  }, header && React105.createElement(Footnote, {
    weight: "2",
    className: "vkuiActionSheet__title"
  }, header), text && React105.createElement(Footnote, {
    className: "vkuiActionSheet__text"
  }, text)), children), platform3 === "ios" && mode === "sheet" && React105.createElement("div", {
    className: "vkuiActionSheet__close-item-wrapper--ios"
  }, iosCloseItem !== null && iosCloseItem !== void 0 ? iosCloseItem : React105.createElement(ActionSheetDefaultIosCloseItem, null))));
  if (mode === "menu") {
    return actionSheet;
  }
  return React105.createElement(PopoutWrapper, {
    closing: Boolean(closingBy),
    alignY: "bottom",
    className,
    style,
    onClick: onClose,
    fixed: true
  }, actionSheet);
};

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinner.js
var React108 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/Icon48CancelCircle.js
var React106 = __toESM(require_react());
var Icon48CancelCircle = (props) => React106.createElement("svg", _object_spread({
  className: "vkuiIcon",
  width: "48",
  height: "48",
  viewBox: "0 0 48 48",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), React106.createElement("path", {
  fillRule: "evenodd",
  clipRule: "evenodd",
  d: "M40 24c0 8.837-7.163 16-16 16S8 32.837 8 24 15.163 8 24 8s16 7.163 16 16Zm-10.08-4.33a1.125 1.125 0 0 0-1.59-1.59L24 22.409l-4.33-4.33a1.125 1.125 0 0 0-1.59 0l-.101.116a1.125 1.125 0 0 0 .1 1.476L22.41 24l-4.33 4.33a1.125 1.125 0 0 0 1.591 1.59L24 25.591l4.33 4.33c.439.439 1.151.439 1.59 0l.101-.116a1.125 1.125 0 0 0-.1-1.476L25.59 24l4.33-4.33Z",
  fill: "currentColor"
}));

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/Icon48DoneOutline.js
var React107 = __toESM(require_react());
var Icon48DoneOutline = (props) => React107.createElement("svg", _object_spread({
  className: "vkuiIcon",
  width: "48",
  height: "48",
  viewBox: "0 0 48 48",
  fill: "none",
  xmlns: "http://www.w3.org/2000/svg"
}, props), React107.createElement("path", {
  d: "M9 24L19 34L39 14",
  stroke: "currentColor",
  strokeWidth: "3.5",
  strokeLinecap: "round",
  strokeLinejoin: "round"
}));

// node_modules/@vkontakte/vkui/dist/components/ScreenSpinner/ScreenSpinner.js
var ScreenSpinner = (_param) => {
  var { style, className, state = "loading", size: size4 = "large", onClick, children = "Пожалуйста, подождите..." } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "state",
    "size",
    "onClick",
    "children"
  ]);
  const hideSpinner = state === "done" || state === "error";
  const Icon = {
    loading: () => null,
    cancelable: Icon24Cancel,
    done: Icon48DoneOutline,
    error: Icon48CancelCircle
  }[state];
  useScrollLock();
  return React108.createElement(PopoutWrapper, {
    noBackground: true,
    className: classNames("vkuiScreenSpinner", state === "cancelable" && "vkuiScreenSpinner--clickable", className),
    style
  }, React108.createElement("div", {
    className: "vkuiScreenSpinner__container",
    onClick
  }, React108.createElement(Spinner, _object_spread({
    className: classNames("vkuiScreenSpinner__spinner", hideSpinner && "vkuiScreenSpinner__spinner--hidden"),
    size: size4
  }, restProps), children), React108.createElement("div", {
    className: classNames("vkuiScreenSpinner__icon", state === "done" && "vkuiScreenSpinner__icon--state-done")
  }, React108.createElement(Icon, null))));
};

// node_modules/@vkontakte/vkui/dist/components/Snackbar/Snackbar.js
var React110 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Snackbar/subcomponents/Basic/Basic.js
var React109 = __toESM(require_react());
var stylesLayout = {
  vertical: "vkuiSnackbar--layout-vertical",
  horizontal: "vkuiSnackbar--layout-horizontal"
};
function Basic(_param) {
  var { layout: layoutProps, action, after, before, mode, subtitle, children } = _param, restProps = _object_without_properties(_param, [
    "layout",
    "action",
    "after",
    "before",
    "mode",
    "subtitle",
    "children"
  ]);
  const layout = layoutProps || (after || subtitle ? "vertical" : "horizontal");
  return React109.createElement(RootComponent, _object_spread({
    baseClassName: classNames("vkuiSnackbar__body", stylesLayout[layout], mode === "dark" && "vkuiSnackbar--mode-dark")
  }, restProps), before && React109.createElement("div", {
    className: "vkuiSnackbar__before"
  }, before), React109.createElement("div", {
    className: "vkuiSnackbar__content"
  }, React109.createElement(Paragraph, {
    className: "vkuiSnackbar__content-text"
  }, children), subtitle && !action && React109.createElement(Subhead, {
    className: "vkuiSnackbar__content-subtitle"
  }, subtitle), action && !subtitle && React109.createElement("div", {
    className: "vkuiSnackbar__action"
  }, action)), after && React109.createElement("div", {
    className: "vkuiSnackbar__after"
  }, after));
}

// node_modules/@vkontakte/vkui/dist/components/Snackbar/Snackbar.js
var Snackbar = (_param) => {
  var { children, layout: layoutProps, action, before, after, duration = 4e3, onActionClick, onClose, mode = "default", subtitle, offsetY, style } = _param, restProps = _object_without_properties(_param, [
    "children",
    "layout",
    "action",
    "before",
    "after",
    "duration",
    "onActionClick",
    "onClose",
    "mode",
    "subtitle",
    "offsetY",
    "style"
  ]);
  const platform3 = usePlatform();
  const { viewWidth } = useAdaptivityWithJSMediaQueries();
  const isDesktop = viewWidth >= ViewWidth.SMALL_TABLET;
  const { waitTransitionFinish } = useWaitTransitionFinish();
  const [closing, setClosing] = React110.useState(false);
  const [touched, setTouched] = React110.useState(false);
  const shiftXPercentRef = React110.useRef(0);
  const shiftXCurrentRef = React110.useRef(0);
  const bodyElRef = React110.useRef(null);
  const innerElRef = React110.useRef(null);
  const animationFrameRef = React110.useRef(null);
  const transitionFinishDurationFallback = platform3 === "ios" ? 320 : 400;
  const close = () => {
    setClosing(true);
    waitTransitionFinish(innerElRef.current, () => {
      onClose();
    }, transitionFinishDurationFallback);
  };
  const handleActionClick = (e) => {
    close();
    if (action && typeof onActionClick === "function") {
      onActionClick(e);
    }
  };
  const closeTimeout = useTimeout(close, duration);
  const setBodyTransform = (percent) => {
    if (animationFrameRef.current !== null) {
      cancelAnimationFrame(animationFrameRef.current);
    }
    animationFrameRef.current = requestAnimationFrame(() => {
      if (bodyElRef.current) {
        bodyElRef.current.style.transform = `translate3d(${percent}%, 0, 0)`;
      }
    });
  };
  const onTouchStart = closeTimeout.clear;
  const onTouchMoveX = (event) => {
    var _bodyElRef_current;
    const { shiftX, originalEvent } = event;
    originalEvent.preventDefault();
    if (!touched) {
      setTouched(true);
    }
    var _bodyElRef_current_offsetWidth;
    shiftXPercentRef.current = shiftX / ((_bodyElRef_current_offsetWidth = (_bodyElRef_current = bodyElRef.current) === null || _bodyElRef_current === void 0 ? void 0 : _bodyElRef_current.offsetWidth) !== null && _bodyElRef_current_offsetWidth !== void 0 ? _bodyElRef_current_offsetWidth : 0) * 100;
    shiftXCurrentRef.current = rubber(shiftXPercentRef.current, 72, 1.2, platform3 !== "ios");
    setBodyTransform(shiftXCurrentRef.current);
  };
  const onTouchEnd = (e) => {
    let callback;
    if (touched) {
      let shiftXCurrent = shiftXCurrentRef.current;
      const expectTranslateY = shiftXCurrent / e.duration * 240 * 0.6;
      shiftXCurrent = shiftXCurrent + expectTranslateY;
      if (isDesktop && shiftXCurrent <= -50) {
        closeTimeout.clear();
        waitTransitionFinish(bodyElRef.current, () => {
          onClose();
        }, transitionFinishDurationFallback);
        setBodyTransform(-120);
      } else if (!isDesktop && shiftXCurrent >= 50) {
        closeTimeout.clear();
        waitTransitionFinish(bodyElRef.current, () => {
          onClose();
        }, transitionFinishDurationFallback);
        setBodyTransform(120);
      } else {
        callback = () => {
          closeTimeout.set();
          setBodyTransform(0);
        };
      }
    } else {
      closeTimeout.set();
    }
    setTouched(false);
    callback && requestAnimationFrame(callback);
  };
  React110.useEffect(() => closeTimeout.set(), [
    closeTimeout
  ]);
  const layout = layoutProps || (after || isDesktop || subtitle ? "vertical" : "horizontal");
  return React110.createElement(AppRootPortal, null, React110.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiSnackbar", platform3 === "ios" && "vkuiSnackbar--ios", closing && "vkuiSnackbar--closing", touched && "vkuiSnackbar--touched", isDesktop && "vkuiSnackbar--desktop"),
    style: offsetY ? _object_spread_props(_object_spread({}, style), {
      bottom: offsetY
    }) : style
  }), React110.createElement(Touch, {
    className: "vkuiSnackbar__in",
    getRootRef: innerElRef,
    onStart: onTouchStart,
    onMoveX: onTouchMoveX,
    onEnd: onTouchEnd
  }, React110.createElement(Basic, {
    className: "vkuiSnackbar__snackbar",
    getRootRef: bodyElRef,
    layout,
    mode,
    before,
    subtitle,
    action: action && React110.createElement(Button, {
      align: "left",
      mode: "link",
      appearance: mode === "dark" ? "overlay" : "accent",
      size: "s",
      onClick: handleActionClick
    }, action),
    after
  }, children))));
};
Snackbar.Basic = Basic;

// node_modules/@vkontakte/vkui/dist/components/Tooltip/Tooltip.js
var React114 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/usePatchChildren.js
var React112 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/getMergedSameEventsByProps.js
var React111 = __toESM(require_react());
var isFunctionExistInProps = (props, key) => typeof props[key] === "function";
var getMergedSameEventsByProps = (mainProps, secondProps) => {
  const result = {};
  for (const eventName in mainProps) {
    if (mainProps.hasOwnProperty(eventName) && secondProps.hasOwnProperty(eventName) && isFunctionExistInProps(mainProps, eventName) && isFunctionExistInProps(secondProps, eventName)) {
      result[eventName] = function mergeSameEventsByProps(...args) {
        secondProps[eventName].apply(this, args);
        mainProps[eventName].apply(this, args);
      };
    }
  }
  return result;
};

// node_modules/@vkontakte/vkui/dist/hooks/usePatchChildren.js
var warn8 = warnOnce("usePatchChildrenRef");
var usePatchChildren = (children, injectProps, externRef) => {
  const isValidElementResult = isValidNotReactFragmentElement(children);
  const isDOMTypeElementResult = isValidElementResult && isDOMTypeElement(children);
  const isForwardedRefElementResult = isValidElementResult && isForwardRefElement(children);
  const shouldUseRef = isDOMTypeElementResult || isForwardedRefElementResult;
  const childRef = useExternRef(shouldUseRef ? children.ref : isValidElementResult ? children.props.getRootRef : void 0, externRef);
  const mergedEventsByInjectProps = getMergedSameEventsByProps(injectProps ? injectProps : {}, isValidElementResult ? children.props : {});
  const props = shouldUseRef ? _object_spread({
    ref: childRef
  }, injectProps, mergedEventsByInjectProps) : isValidElementResult ? _object_spread({
    getRootRef: childRef
  }, injectProps, mergedEventsByInjectProps) : void 0;
  useEffectDev(() => {
    if (!childRef.current) {
      warn8("Кажется, в children передан компонент, который не поддерживает свойство getRootRef. Мы не можем получить ссылку на корневой dom-элемент этого компонента", "error");
    }
  }, [
    isValidElementResult ? children.type : null,
    childRef
  ]);
  return [
    childRef,
    isValidElementResult ? React112.cloneElement(children, props) : children
  ];
};

// node_modules/@vkontakte/vkui/dist/lib/cssAnimation/fades.js
var animationFadeClassNames = {
  in: "vkui-anim-fade-in",
  out: "vkui-anim-fade-out"
};

// node_modules/@vkontakte/vkui/dist/lib/cssAnimation/transformOrigin.js
var transformOriginClassNames = {
  "top": "vkui-anim-transform-origin-top",
  "top-start": "vkui-anim-transform-origin-top-start",
  "top-end": "vkui-anim-transform-origin-top-end",
  "right": "vkui-anim-transform-origin-right",
  "right-start": "vkui-anim-transform-origin-right-start",
  "right-end": "vkui-anim-transform-origin-right-end",
  "bottom": "vkui-anim-transform-origin-bottom",
  "bottom-start": "vkui-anim-transform-origin-bottom-start",
  "bottom-end": "vkui-anim-transform-origin-bottom-end",
  "left": "vkui-anim-transform-origin-left",
  "left-start": "vkui-anim-transform-origin-left-start",
  "left-end": "vkui-anim-transform-origin-left-end"
};

// node_modules/@vkontakte/vkui/dist/components/TooltipBase/TooltipBase.js
var React113 = __toESM(require_react());
var TOOLTIP_MAX_WIDTH = 220;
var stylesAppearance2 = {
  accent: "vkuiTooltipBase--appearance-accent",
  white: "vkuiTooltipBase--appearance-white",
  black: "vkuiTooltipBase--appearance-black",
  inversion: "vkuiTooltipBase--appearance-inversion"
};
var TooltipBase = (_param) => {
  var { appearance = "accent", arrowProps, ArrowIcon: ArrowIcon2 = DefaultIcon, text, header, maxWidth = TOOLTIP_MAX_WIDTH, className } = _param, restProps = _object_without_properties(_param, [
    "appearance",
    "arrowProps",
    "ArrowIcon",
    "text",
    "header",
    "maxWidth",
    "className"
  ]);
  return React113.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiTooltipBase", appearance !== "neutral" && stylesAppearance2[appearance], className),
    role: "tooltip"
  }), arrowProps && React113.createElement(FloatingArrow, _object_spread_props(_object_spread({}, arrowProps), {
    iconClassName: classNames("vkuiTooltipBase__arrow", arrowProps.iconClassName),
    Icon: ArrowIcon2
  })), React113.createElement("div", {
    className: "vkuiTooltipBase__content",
    style: maxWidth !== null ? {
      maxWidth
    } : void 0
  }, header && React113.createElement(Subhead, {
    weight: "2"
  }, header), text && React113.createElement(Subhead, null, text)));
};

// node_modules/@vkontakte/vkui/dist/components/Tooltip/Tooltip.js
var Tooltip = (_param) => {
  var {
    // UseFloatingMiddlewaresBootstrapOptions
    placement: placementProp = "bottom",
    arrowPadding = 10,
    arrowHeight = 8,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    hideWhenReferenceHidden,
    // useFloatingWithInteractions
    defaultShown,
    shown: shownProp,
    onShownChange,
    hoverDelay = 150,
    // инверсированные св-ва для useFloatingWithInteractions
    enableInteractive = false,
    disableArrow = false,
    disableCloseAfterClick = false,
    // Reference
    children,
    // AppRootProps
    usePortal,
    // TooltipBaseProps
    id: idProp,
    getRootRef,
    text,
    header,
    appearance = "neutral",
    style: styleProp,
    className,
    zIndex = "var(--vkui--z_index_popout)",
    onPlacementChange
  } = _param, popperProps = _object_without_properties(_param, [
    "placement",
    "arrowPadding",
    "arrowHeight",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "hideWhenReferenceHidden",
    "defaultShown",
    "shown",
    "onShownChange",
    "hoverDelay",
    "enableInteractive",
    "disableArrow",
    "disableCloseAfterClick",
    "children",
    "usePortal",
    "id",
    "getRootRef",
    "text",
    "header",
    "appearance",
    "style",
    "className",
    "zIndex",
    "onPlacementChange"
  ]);
  const generatedId = React114.useId();
  const tooltipId = idProp || generatedId;
  const [arrowRef, setArrowRef] = React114.useState(null);
  const { middlewares, strictPlacement } = useFloatingMiddlewaresBootstrap({
    placement: placementProp,
    offsetByMainAxis,
    offsetByCrossAxis,
    hideWhenReferenceHidden,
    arrow: !disableArrow,
    arrowRef,
    arrowPadding,
    arrowHeight
  });
  const { shown, willBeHide, placement, refs, referenceProps, floatingProps, middlewareData, onEscapeKeyDown } = useFloatingWithInteractions({
    defaultShown,
    shown: shownProp,
    onShownChange,
    placement: strictPlacement,
    trigger: [
      "hover",
      "focus"
    ],
    hoverDelay,
    closeAfterClick: !disableCloseAfterClick,
    disableInteractive: !enableInteractive,
    middlewares
  });
  const tooltipRef = useExternRef(getRootRef, refs.setFloating);
  usePlacementChangeCallback(placement, onPlacementChange);
  let tooltip = null;
  if (shown) {
    referenceProps["aria-describedby"] = tooltipId;
    floatingProps.style.zIndex = zIndex;
    if (styleProp) {
      Object.assign(floatingProps.style, styleProp);
    }
    tooltip = React114.createElement(AppRootPortal, {
      usePortal
    }, React114.createElement(TooltipBase, _object_spread_props(_object_spread({}, popperProps, floatingProps), {
      id: tooltipId,
      getRootRef: tooltipRef,
      appearance,
      arrowProps: disableArrow ? void 0 : {
        placement,
        coords: getArrowCoordsByMiddlewareData(middlewareData),
        getRootRef: setArrowRef
      },
      text: React114.createElement(React114.Fragment, null, hasReactNode(header) && React114.createElement(Subhead, {
        weight: "2"
      }, header), hasReactNode(text) && React114.createElement(Subhead, null, text)),
      className: classNames(willBeHide ? animationFadeClassNames.out : animationFadeClassNames.in, className)
    })));
  }
  const [childRef, child] = usePatchChildren(children, referenceProps, refs.setReference);
  useIsomorphicLayoutEffect(function handleGlobalKeyDownIfTooltipShown() {
    if (!onEscapeKeyDown || !shown) {
      return;
    }
    const handleKeyDown = (event) => {
      if (pressedKey(event) === Keys.ESCAPE) {
        onEscapeKeyDown();
      }
    };
    const doc = getWindow(childRef.current).document;
    doc.addEventListener("keydown", handleKeyDown, {
      passive: true,
      capture: true
    });
    return () => {
      doc.removeEventListener("keydown", handleKeyDown, {
        capture: true
      });
    };
  }, [
    shown,
    childRef,
    onEscapeKeyDown
  ]);
  return React114.createElement(React114.Fragment, null, child, tooltip);
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootAdaptive.js
var React121 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRoot.js
var React119 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hoc/withContext.js
var React115 = __toESM(require_react());
function withContext(Component3, Ctx, prop) {
  function WithContext(props) {
    const context = React115.useContext(Ctx);
    return React115.createElement(Component3, _object_spread_props(_object_spread({}, props), {
      [prop]: context
    }));
  }
  return WithContext;
}

// node_modules/@vkontakte/vkui/dist/hoc/withPlatform.js
var React116 = __toESM(require_react());
function withPlatform(Component3) {
  function WithPlatform(props) {
    const { platform: platform3 } = useConfigProvider();
    return React116.createElement(Component3, _object_spread_props(_object_spread({}, props), {
      platform: platform3
    }));
  }
  return WithPlatform;
}

// node_modules/@vkontakte/vkui/dist/lib/styles.js
function setTransformStyle(element, transform) {
  if (element) {
    element.style.transform = transform;
    element.style.webkitTransform = transform;
  }
}

// node_modules/@vkontakte/vkui/dist/components/Touch/TouchContext.js
var React117 = __toESM(require_react());
var TouchRootContext = React117.createContext(false);
var TouchContext_default = TouchRootContext;

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/constants.js
var MODAL_PAGE_DEFAULT_PERCENT_HEIGHT = 75;

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/useModalManager.js
var React118 = __toESM(require_react());
function getModals(children) {
  return React118.Children.toArray(children);
}
var warn9 = warnOnce("ModalRoot");
function modalTransitionReducer(state, action) {
  if (action.type === "setActive" && action.id !== state.activeModal) {
    const nextModal = action.id;
    const prevModal = state.exitingModal || state.activeModal;
    let history = state.history ? [
      ...state.history
    ] : [];
    const isBack = Boolean(nextModal && history.includes(nextModal));
    if (nextModal === null) {
      history = [];
    } else if (isBack) {
      history = history.splice(0, history.indexOf(nextModal) + 1);
    } else {
      history.push(nextModal);
    }
    return {
      activeModal: nextModal,
      // not entering yet
      enteringModal: null,
      exitingModal: prevModal,
      history,
      isBack
    };
  }
  if (action.type === "entered" && action.id === state.enteringModal) {
    return _object_spread_props(_object_spread({}, state), {
      enteringModal: null
    });
  }
  if (action.type === "exited" && action.id === state.exitingModal) {
    return _object_spread_props(_object_spread({}, state), {
      exitingModal: null
    });
  }
  if (action.type === "inited" && action.id === state.activeModal) {
    return _object_spread_props(_object_spread({}, state), {
      enteringModal: action.id
    });
  }
  return state;
}
function useModalManager(activeModal, children, onOpen = noop, onOpened = noop, onClose = noop, onClosed = noop, initModal2 = noop) {
  const modalsState = React118.useRef({}).current;
  getModals(children).forEach((Modal) => {
    const modalProps = Modal.props;
    const id = getNavId(modalProps, warn9);
    const state = id !== void 0 && modalsState[id] || {
      id: id !== null && id !== void 0 ? id : null
    };
    state.onOpen = Modal.props.onOpen;
    state.onOpened = Modal.props.onOpened;
    state.onClose = Modal.props.onClose;
    state.onClosed = Modal.props.onClosed;
    if (typeof modalProps.settlingHeight === "number") {
      state.settlingHeight = modalProps.settlingHeight;
    }
    if (state.id !== null) {
      modalsState[state.id] = state;
    }
  });
  const isMissing = activeModal && !modalsState[activeModal];
  const safeActiveModal = isMissing ? null : activeModal;
  const [transitionState, dispatchTransition] = React118.useReducer(modalTransitionReducer, {
    activeModal: safeActiveModal,
    enteringModal: null,
    exitingModal: null,
    history: safeActiveModal ? [
      safeActiveModal
    ] : [],
    isBack: false
  });
  useIsomorphicLayoutEffect(() => {
    if (isMissing) {
      warn9(`Переход невозможен - модальное окно (страница) ${activeModal} не существует`, "error");
    }
    dispatchTransition({
      type: "setActive",
      id: safeActiveModal !== null && safeActiveModal !== void 0 ? safeActiveModal : null
    });
  }, [
    activeModal
  ]);
  useIsomorphicLayoutEffect(() => {
    if (transitionState.activeModal) {
      initModal2(modalsState[transitionState.activeModal]);
      dispatchTransition({
        type: "inited",
        id: transitionState.activeModal
      });
    }
  }, [
    transitionState.activeModal
  ]);
  const isCard = (id) => {
    var _modalsState_id;
    return id != null && ((_modalsState_id = modalsState[id]) === null || _modalsState_id === void 0 ? void 0 : _modalsState_id.type) === "card";
  };
  const onEntered = React118.useCallback((id) => {
    if (id) {
      const modalState = modalsState[id];
      if (isFunction(modalState.onOpened)) {
        modalState.onOpened();
      } else if (isFunction(onOpened)) {
        onOpened(id);
      }
    }
    dispatchTransition({
      type: "entered",
      id
    });
  }, [
    modalsState,
    onOpened
  ]);
  const onExited = React118.useCallback((id) => {
    if (id) {
      const modalState = modalsState[id];
      if (isFunction(modalState.onClosed)) {
        modalState.onClosed();
      } else if (isFunction(onClosed)) {
        onClosed(id);
      }
    }
    dispatchTransition({
      type: "exited",
      id
    });
  }, [
    modalsState,
    onClosed
  ]);
  const delayEnter = Boolean(transitionState.exitingModal && (isCard(activeModal) || isCard(transitionState.exitingModal)));
  const getModalState = React118.useCallback((id) => id ? modalsState[id] : void 0, [
    modalsState
  ]);
  function onEnter() {
    const modalState = transitionState.activeModal && modalsState[transitionState.activeModal];
    if (modalState) {
      if (isFunction(modalState.onOpen)) {
        modalState.onOpen();
      } else if (isFunction(onOpen) && modalState.id) {
        onOpen(modalState.id);
      }
    }
  }
  function onExit() {
    const modalState = transitionState.activeModal && modalsState[transitionState.activeModal];
    if (modalState) {
      if (isFunction(modalState.onClose)) {
        modalState.onClose();
      } else if (isFunction(onClose) && modalState.id) {
        onClose(modalState.id);
      }
    }
  }
  return _object_spread_props(_object_spread({
    onEnter,
    onEntered,
    onExit,
    onExited
  }, transitionState), {
    delayEnter,
    getModalState
  });
}
function withModalManager(initModal2 = noop) {
  return function(Wrapped) {
    return function WithModalManager(props) {
      const transitionManager = useModalManager(props.activeModal, props.children, props.onOpen, props.onOpened, props.onClose, props.onClosed, initModal2);
      return React118.createElement(Wrapped, _object_spread({}, props, transitionManager));
    };
  };
}

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRoot.js
var warn10 = warnOnce("ModalRoot");
function numberInRange(number, range2) {
  if (!range2) {
    return false;
  }
  return number >= range2[0] && number <= range2[1];
}
function rangeTranslate(number) {
  return clamp2(number, 0, 98);
}
var ModalRootTouchComponent = class extends React119.Component {
  get timeout() {
    return this.props.platform === "ios" ? 400 : 320;
  }
  get document() {
    return this.props.document;
  }
  get window() {
    return this.props.window;
  }
  getModals() {
    return React119.Children.toArray(this.props.children);
  }
  componentDidMount() {
    var _this_window;
    (_this_window = this.window) === null || _this_window === void 0 ? void 0 : _this_window.addEventListener("resize", this.updateModalHeight, false);
  }
  componentWillUnmount() {
    this.toggleDocumentScrolling(true);
    this.window.removeEventListener("resize", this.updateModalHeight, false);
  }
  componentDidUpdate(prevProps) {
    if (this.props.exitingModal && this.props.exitingModal !== prevProps.exitingModal) {
      this.closeModal(this.props.exitingModal);
    }
    if (this.props.enteringModal && this.props.enteringModal !== prevProps.enteringModal) {
      const enteringState = this.props.getModalState(this.props.enteringModal);
      this.props.onEnter();
      this.waitTransitionFinish(enteringState, () => {
        if (enteringState) {
          if (enteringState.innerElement) {
            enteringState.innerElement.style.transitionDelay = "";
          }
          this.onEntered(enteringState);
        }
      });
      if (enteringState === null || enteringState === void 0 ? void 0 : enteringState.innerElement) {
        enteringState.innerElement.style.transitionDelay = this.props.delayEnter ? `${this.timeout}ms` : "";
        this.animateTranslate(enteringState, enteringState.translateY);
        this.setMaskOpacity(enteringState, 1);
      }
    }
    if (this.props.activeModal && !prevProps.activeModal) {
      this.restoreFocusTo = this.document.activeElement;
    }
    if (!this.props.activeModal && !this.props.exitingModal && this.restoreFocusTo) {
      this.restoreFocusTo.focus();
      this.restoreFocusTo = null;
    }
    this.toggleDocumentScrolling(!this.props.activeModal && !this.props.exitingModal);
  }
  /* Отключает скролл документа */
  toggleDocumentScrolling(enabled) {
    if (this.documentScrolling === enabled) {
      return;
    }
    this.documentScrolling = enabled;
    if (enabled) {
      this.document.documentElement.classList.remove("vkui--disable-overscroll-behavior");
      this.window.removeEventListener("touchmove", this.preventTouch, {
        // @ts-expect-error: TS2769 В интерфейсе EventListenerOptions нет поля passive
        passive: false
      });
    } else {
      this.document.documentElement.classList.add("vkui--disable-overscroll-behavior");
      this.window.addEventListener("touchmove", this.preventTouch, {
        passive: false
      });
    }
  }
  checkPageContentHeight() {
    const modalState = this.props.getModalState(this.props.activeModal);
    if ((modalState === null || modalState === void 0 ? void 0 : modalState.type) === "page" && (modalState === null || modalState === void 0 ? void 0 : modalState.modalElement)) {
      const prevModalState = _object_spread({}, modalState);
      initPageModal(modalState);
      const currentModalState = _object_spread({}, modalState);
      let needAnimate = false;
      if (prevModalState.expandable === currentModalState.expandable) {
        if (prevModalState.translateYFrom !== currentModalState.translateYFrom) {
          needAnimate = true;
        }
      } else {
        needAnimate = true;
      }
      if (needAnimate) {
        this.animateTranslate(modalState, modalState.translateY);
      }
    }
  }
  onEntered({ id, modalElement }) {
    if (!this.props.noFocusToDialog && modalElement && !modalElement.contains(this.document.activeElement)) {
      modalElement.focus();
    }
    this.props.onEntered(id);
  }
  closeModal(id) {
    this.setState({
      touchDown: false
    });
    const prevModalState = this.props.getModalState(id);
    if (!prevModalState) {
      id && warn10(`closeActiveModal: модальное окно (страница) ${id} не существует`, "error");
      return;
    }
    if (!this.state.modalOpenedLog.length) {
      this.setState((prevState) => ({
        modalOpenedLog: [
          ...prevState.modalOpenedLog,
          id
        ]
      }));
    }
    const nextModalState = this.props.getModalState(this.props.activeModal);
    const nextIsPage = !!nextModalState && nextModalState.type === "page";
    const prevIsPage = !!prevModalState && prevModalState.type === "page";
    this.waitTransitionFinish(prevModalState, () => this.props.onExited(id));
    var _prevModalState_translateY, _nextModalState_translateYFrom, _nextModalState_translateYFrom1;
    const exitTranslate = prevIsPage && nextIsPage && ((_prevModalState_translateY = prevModalState.translateY) !== null && _prevModalState_translateY !== void 0 ? _prevModalState_translateY : 0) <= ((_nextModalState_translateYFrom = nextModalState === null || nextModalState === void 0 ? void 0 : nextModalState.translateYFrom) !== null && _nextModalState_translateYFrom !== void 0 ? _nextModalState_translateYFrom : 0) && !this.props.isBack ? ((_nextModalState_translateYFrom1 = nextModalState === null || nextModalState === void 0 ? void 0 : nextModalState.translateYFrom) !== null && _nextModalState_translateYFrom1 !== void 0 ? _nextModalState_translateYFrom1 : 0) + 10 : 100;
    this.animateTranslate(prevModalState, exitTranslate);
    if (!nextModalState) {
      this.setMaskOpacity(prevModalState, 0);
      this.setState({
        modalOpenedLog: []
      });
      prevModalState.translateY = void 0;
      prevModalState.expandable = void 0;
    } else if (nextModalState.id && !this.state.modalOpenedLog.includes(nextModalState.id)) {
      nextModalState.translateY = void 0;
      this.setState((prevState) => ({
        modalOpenedLog: [
          ...prevState.modalOpenedLog,
          nextModalState.id
        ]
      }));
    }
  }
  onPageTouchMove(event, modalState) {
    var _modalState_innerElement, _modalState_headerElement;
    const { shiftY, originalEvent } = event;
    const target = originalEvent.target;
    if (!event.isY) {
      var _this_viewportRef_current;
      if ((_this_viewportRef_current = this.viewportRef.current) === null || _this_viewportRef_current === void 0 ? void 0 : _this_viewportRef_current.contains(target)) {
        originalEvent.preventDefault();
      }
      return;
    }
    if (!((_modalState_innerElement = modalState.innerElement) === null || _modalState_innerElement === void 0 ? void 0 : _modalState_innerElement.contains(target))) {
      return originalEvent.preventDefault();
    }
    originalEvent.stopPropagation();
    const { expandable, contentScrolled, collapsed, expanded } = modalState;
    if (!this.state.touchDown) {
      var _modalState_contentElement;
      var _modalState_contentElement_scrollTop;
      modalState.touchStartContentScrollTop = (_modalState_contentElement_scrollTop = (_modalState_contentElement = modalState.contentElement) === null || _modalState_contentElement === void 0 ? void 0 : _modalState_contentElement.scrollTop) !== null && _modalState_contentElement_scrollTop !== void 0 ? _modalState_contentElement_scrollTop : 0;
      this.setState({
        touchDown: true
      });
    }
    if (contentScrolled) {
      return;
    }
    if (modalState.touchMovePositive === null) {
      modalState.touchMovePositive = shiftY > 0;
    }
    if (!modalState.expandable || collapsed || expanded && modalState.touchMovePositive && modalState.touchStartContentScrollTop === 0 || ((_modalState_headerElement = modalState.headerElement) === null || _modalState_headerElement === void 0 ? void 0 : _modalState_headerElement.contains(target))) {
      originalEvent.preventDefault();
      if (!expandable && shiftY < 0 || !this.window) {
        return;
      }
      !this.state.dragging && this.setState({
        dragging: true
      });
      const shiftYPercent = shiftY / this.window.innerHeight * 100;
      const shiftYCurrent = rubber(shiftYPercent, 72, 0.8, this.props.platform !== "ios");
      modalState.touchShiftYPercent = shiftYPercent;
      var _modalState_translateY;
      modalState.translateYCurrent = rangeTranslate(((_modalState_translateY = modalState.translateY) !== null && _modalState_translateY !== void 0 ? _modalState_translateY : 0) + shiftYCurrent);
      this.animateTranslate(modalState, modalState.translateYCurrent);
      this.setMaskOpacity(modalState);
    }
  }
  onCardTouchMove(event, modalState) {
    var _modalState_innerElement;
    const { originalEvent, shiftY } = event;
    const target = originalEvent.target;
    if ((_modalState_innerElement = modalState.innerElement) === null || _modalState_innerElement === void 0 ? void 0 : _modalState_innerElement.contains(target)) {
      if (!this.state.touchDown) {
        this.setState({
          touchDown: true,
          dragging: true
        });
      }
      const shiftYPercent = shiftY / modalState.innerElement.offsetHeight * 100;
      const shiftYCurrent = rubber(shiftYPercent, 72, 1.2, this.props.platform !== "ios");
      modalState.touchShiftYPercent = shiftYPercent;
      var _modalState_translateY;
      modalState.translateYCurrent = Math.max(0, ((_modalState_translateY = modalState.translateY) !== null && _modalState_translateY !== void 0 ? _modalState_translateY : 0) + shiftYCurrent);
      this.animateTranslate(modalState, modalState.translateYCurrent);
      this.setMaskOpacity(modalState);
    }
  }
  onPageTouchEnd(event, modalState) {
    const { startY, shiftY } = event;
    modalState.contentScrolled = false;
    modalState.touchMovePositive = null;
    let setStateCallback;
    if (this.state.dragging && this.window) {
      const shiftYEndPercent = (startY + shiftY) / this.window.innerHeight * 100;
      var _modalState_translateYCurrent;
      let translateY = (_modalState_translateYCurrent = modalState.translateYCurrent) !== null && _modalState_translateYCurrent !== void 0 ? _modalState_translateYCurrent : 0;
      var _modalState_touchShiftYPercent;
      const expectTranslateY = translateY / event.duration * 240 * 0.6 * (((_modalState_touchShiftYPercent = modalState.touchShiftYPercent) !== null && _modalState_touchShiftYPercent !== void 0 ? _modalState_touchShiftYPercent : 0) < 0 ? -1 : 1);
      translateY = rangeTranslate(translateY + expectTranslateY);
      if (modalState.settlingHeight !== 100) {
        if (numberInRange(translateY, modalState.expandedRange)) {
          var _modalState_expandedRange;
          var _modalState_expandedRange_;
          translateY = (_modalState_expandedRange_ = (_modalState_expandedRange = modalState.expandedRange) === null || _modalState_expandedRange === void 0 ? void 0 : _modalState_expandedRange[0]) !== null && _modalState_expandedRange_ !== void 0 ? _modalState_expandedRange_ : 0;
        } else if (numberInRange(translateY, modalState.collapsedRange)) {
          var _modalState_translateYFrom;
          translateY = (_modalState_translateYFrom = modalState.translateYFrom) !== null && _modalState_translateYFrom !== void 0 ? _modalState_translateYFrom : 0;
        } else if (numberInRange(translateY, modalState.hiddenRange)) {
          translateY = 100;
        } else {
          var _modalState_translateYFrom1;
          translateY = (_modalState_translateYFrom1 = modalState.translateYFrom) !== null && _modalState_translateYFrom1 !== void 0 ? _modalState_translateYFrom1 : 0;
        }
      } else {
        if (numberInRange(translateY, [
          0,
          25
        ])) {
          translateY = 0;
        } else {
          translateY = 100;
        }
      }
      if (translateY !== 100 && shiftYEndPercent >= 75) {
        translateY = 100;
      }
      modalState.translateY = translateY;
      modalState.translateYCurrent = translateY;
      modalState.collapsed = numberInRange(translateY, modalState.collapsedRange);
      modalState.expanded = translateY === 0;
      modalState.hidden = translateY === 100;
      if (modalState.hidden) {
        this.props.onExit();
      }
      setStateCallback = () => {
        if (!modalState.hidden) {
          this.animateTranslate(modalState, modalState.translateY);
        }
        this.setMaskOpacity(modalState);
      };
    }
    this.setState({
      touchDown: false,
      dragging: false
    }, setStateCallback);
  }
  onCardTouchEnd({ duration }, modalState) {
    let setStateCallback;
    if (this.state.dragging) {
      var _modalState_translateYCurrent;
      let translateY = (_modalState_translateYCurrent = modalState.translateYCurrent) !== null && _modalState_translateYCurrent !== void 0 ? _modalState_translateYCurrent : 0;
      var _modalState_touchShiftYPercent;
      const expectTranslateY = translateY / duration * 240 * 0.6 * (((_modalState_touchShiftYPercent = modalState.touchShiftYPercent) !== null && _modalState_touchShiftYPercent !== void 0 ? _modalState_touchShiftYPercent : 0) < 0 ? -1 : 1);
      translateY = Math.max(0, translateY + expectTranslateY);
      if (translateY >= 30) {
        translateY = 100;
      } else {
        translateY = 0;
      }
      modalState.translateY = translateY;
      modalState.hidden = translateY === 100;
      if (modalState.hidden) {
        this.props.onExit();
      }
      setStateCallback = () => {
        if (!modalState.hidden) {
          this.animateTranslate(modalState, modalState.translateY);
        }
        this.setMaskOpacity(modalState);
      };
    }
    this.setState({
      touchDown: false,
      dragging: false
    }, setStateCallback);
  }
  waitTransitionFinish(modalState, eventHandler) {
    if (transitionEvent2.supported) {
      var _modalState_innerElement;
      const onceHandler = () => {
        var _modalState_innerElement2;
        modalState === null || modalState === void 0 ? void 0 : (_modalState_innerElement2 = modalState.innerElement) === null || _modalState_innerElement2 === void 0 ? void 0 : _modalState_innerElement2.removeEventListener(transitionEvent2.name, onceHandler);
        eventHandler();
      };
      modalState === null || modalState === void 0 ? void 0 : (_modalState_innerElement = modalState.innerElement) === null || _modalState_innerElement === void 0 ? void 0 : _modalState_innerElement.addEventListener(transitionEvent2.name, onceHandler);
    } else {
      setTimeout(eventHandler, this.timeout);
    }
  }
  /**
  * Анимирует сдвиг модалки
  *
  * @param {ModalsStateEntry} modalState
  * @param {number} percent Процент сдвига: 0 – полностью открыта, 100 – полностью закрыта
  */
  animateTranslate(modalState, percent) {
    const frameId = `animateTranslateFrame${modalState.id}`;
    cancelAnimationFrame(this.frameIds[frameId]);
    this.frameIds[frameId] = requestAnimationFrame(() => {
      setTransformStyle(modalState.innerElement, `translate3d(0, ${percent}%, 0)`);
    });
  }
  /* Устанавливает прозрачность для полупрозрачной подложки */
  setMaskOpacity(modalState, forceOpacity = null) {
    var _this_props_history;
    if (forceOpacity === null && ((_this_props_history = this.props.history) === null || _this_props_history === void 0 ? void 0 : _this_props_history[0]) !== modalState.id) {
      return;
    }
    if (this.maskAnimationFrame) {
      cancelAnimationFrame(this.maskAnimationFrame);
    }
    this.maskAnimationFrame = requestAnimationFrame(() => {
      if (this.maskElementRef.current) {
        const { translateY = 0, translateYCurrent = 0 } = modalState;
        const opacity = forceOpacity === null ? 1 - (translateYCurrent - translateY) / (100 - translateY) || 0 : forceOpacity;
        this.maskElementRef.current.style.opacity = clamp2(opacity, 0, 100).toString();
        this.maskElementRef.current.style.transitionDelay = opacity && this.props.delayEnter ? `${this.timeout}ms` : "";
      }
    });
  }
  render() {
    var _this_props_configProvider;
    const { activeModal, exitingModal, enteringModal, modalOverlayTestId } = this.props;
    const { touchDown, dragging } = this.state;
    if (!activeModal && !exitingModal) {
      return null;
    }
    return React119.createElement(TouchContext_default.Provider, {
      value: true
    }, React119.createElement(ModalRootContext.Provider, {
      value: this.modalRootContext
    }, React119.createElement(Touch, {
      className: classNames("vkuiModalRoot", ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.hasCustomPanelHeaderAfter) && "vkuiModalRoot--hasCustomPanelHeaderAfterSlot", touchDown && classNames("vkuiModalRoot--touched", "vkuiInternalModalRoot--touched"), !!(enteringModal || exitingModal) && classNames("vkuiModalRoot--switching", "vkuiInternalModalRoot--switching")),
      onMove: this.onTouchMove,
      onEnd: this.onTouchEnd,
      onScroll: this.onScroll
    }, React119.createElement("div", {
      "data-testid": modalOverlayTestId,
      className: "vkuiModalRoot__mask",
      onClick: this.props.onExit,
      ref: this.maskElementRef
    }), React119.createElement("div", {
      className: "vkuiModalRoot__viewport",
      ref: this.viewportRef
    }, this.getModals().map((Modal) => {
      const modalId = getNavId(Modal.props, warn10);
      const _modalState = this.props.getModalState(modalId);
      if (modalId !== activeModal && modalId !== exitingModal || !_modalState) {
        return null;
      }
      const modalState = _object_spread({}, _modalState);
      const isPage = modalState.type === "page";
      const key = `modal-${modalId}`;
      return React119.createElement(FocusTrap, {
        key,
        onClose: this.props.onExit,
        timeout: this.timeout,
        className: classNames("vkuiModalRoot__modal", dragging && "vkuiInternalModalRoot__modal--dragging", isPage && modalState.expandable && "vkuiInternalModalRoot__modal--expandable", isPage && modalState.collapsed && "vkuiInternalModalRoot__modal--collapsed"),
        restoreFocus: false
      }, Modal);
    })))));
  }
  constructor(props) {
    super(props);
    _define_property(this, "documentScrolling", false);
    _define_property(this, "maskElementRef", void 0);
    _define_property(this, "viewportRef", React119.createRef());
    _define_property(this, "maskAnimationFrame", void 0);
    _define_property(this, "modalRootContext", void 0);
    _define_property(this, "frameIds", void 0);
    _define_property(this, "restoreFocusTo", void 0);
    _define_property(this, "preventTouch", (event) => {
      if (!event) {
        return false;
      }
      while (event.originalEvent) {
        event = event.originalEvent;
      }
      if (event.preventDefault) {
        event.preventDefault();
      }
      return false;
    });
    _define_property(this, "updateModalHeight", () => {
      const modalState = this.props.getModalState(this.props.activeModal);
      if (modalState && modalState.type === "page") {
        if (this.props.enteringModal) {
          this.waitTransitionFinish(modalState, () => {
            requestAnimationFrame(() => this.checkPageContentHeight());
          });
        } else {
          requestAnimationFrame(() => this.checkPageContentHeight());
        }
      }
    });
    _define_property(this, "onTouchMove", (e) => {
      if (this.props.exitingModal) {
        return;
      }
      const modalState = this.props.getModalState(this.props.activeModal);
      if (!modalState) {
        return;
      }
      if (modalState.type === "page") {
        return this.onPageTouchMove(e, modalState);
      }
      if (modalState.type === "card") {
        return this.onCardTouchMove(e, modalState);
      }
    });
    _define_property(this, "onTouchEnd", (e) => {
      const modalState = this.props.getModalState(this.props.activeModal);
      if ((modalState === null || modalState === void 0 ? void 0 : modalState.type) === "page") {
        return this.onPageTouchEnd(e, modalState);
      }
      if ((modalState === null || modalState === void 0 ? void 0 : modalState.type) === "card") {
        return this.onCardTouchEnd(e, modalState);
      }
    });
    _define_property(this, "onScroll", (e) => {
      var _modalState_contentElement;
      const activeModal = this.props.activeModal;
      const target = e.target;
      if (!activeModal) {
        return;
      }
      const modalState = this.props.getModalState(activeModal);
      if ((modalState === null || modalState === void 0 ? void 0 : modalState.type) === "page" && (modalState === null || modalState === void 0 ? void 0 : (_modalState_contentElement = modalState.contentElement) === null || _modalState_contentElement === void 0 ? void 0 : _modalState_contentElement.contains(target))) {
        modalState.contentScrolled = true;
        if (modalState.contentScrollStopTimeout) {
          clearTimeout(modalState.contentScrollStopTimeout);
        }
        modalState.contentScrollStopTimeout = setTimeout(() => {
          if (modalState.contentScrolled) {
            modalState.contentScrolled = false;
          }
        }, 250);
      }
    });
    this.state = {
      touchDown: false,
      dragging: false,
      modalOpenedLog: []
    };
    this.maskElementRef = React119.createRef();
    this.modalRootContext = {
      updateModalHeight: this.updateModalHeight,
      registerModal: (_param) => {
        var { id } = _param, data = _object_without_properties(_param, [
          "id"
        ]);
        var _this_props_getModalState;
        return Object.assign((_this_props_getModalState = this.props.getModalState(id)) !== null && _this_props_getModalState !== void 0 ? _this_props_getModalState : {}, data);
      },
      onClose: () => this.props.onExit(),
      isInsideModal: true
    };
    this.frameIds = {};
  }
};
var ModalRootTouch = withContext(withPlatform(withDOM(withModalManager(initModal)(ModalRootTouchComponent))), ConfigProviderContext, "configProvider");
function initModal(modalState) {
  switch (modalState.type) {
    case "page":
      modalState.settlingHeight = modalState.settlingHeight || MODAL_PAGE_DEFAULT_PERCENT_HEIGHT;
      return initPageModal(modalState);
    case "card":
      return initCardModal(modalState);
    default:
      warn10(`initActiveModal: modalState.type="${modalState.type}" не поддерживается`, "error");
  }
}
function initPageModal(modalState) {
  const { contentElement, bottomInset } = modalState;
  const contentElementHeight = calculateModalContentHeight(contentElement === null || contentElement === void 0 ? void 0 : contentElement.firstElementChild, modalState.expandable);
  const bottomInsetHeight = (bottomInset === null || bottomInset === void 0 ? void 0 : bottomInset.offsetHeight) || 0;
  const contentHeight = contentElementHeight + bottomInsetHeight;
  let prevTranslateY = modalState.translateY;
  let prevExpandable = modalState.expandable;
  var _contentElement_clientHeight;
  modalState.expandable = contentHeight > ((_contentElement_clientHeight = contentElement === null || contentElement === void 0 ? void 0 : contentElement.clientHeight) !== null && _contentElement_clientHeight !== void 0 ? _contentElement_clientHeight : 0) || modalState.settlingHeight === 100;
  let collapsed = false;
  let expanded = false;
  let translateYFrom;
  let translateY;
  let expandedRange;
  let collapsedRange;
  let hiddenRange;
  const hasCollapsedState = Boolean(modalState.expandable && modalState.settlingHeight !== 100);
  if (modalState.expandable) {
    var _modalState_settlingHeight;
    translateYFrom = 100 - ((_modalState_settlingHeight = modalState.settlingHeight) !== null && _modalState_settlingHeight !== void 0 ? _modalState_settlingHeight : 0);
    const shiftHalf = translateYFrom / 2;
    const visiblePart = 100 - translateYFrom;
    expandedRange = [
      0,
      shiftHalf
    ];
    collapsedRange = hasCollapsedState ? [
      shiftHalf,
      translateYFrom + visiblePart / 4
    ] : void 0;
    hiddenRange = [
      translateYFrom + visiblePart / 4,
      100
    ];
    collapsed = hasCollapsedState && translateYFrom > 0;
    expanded = translateYFrom <= 0;
    translateY = translateYFrom;
  } else {
    var _modalState_headerElement, _modalState_innerElement_parentElement, _modalState_innerElement;
    var _modalState_headerElement_offsetHeight;
    const headerHeight = (_modalState_headerElement_offsetHeight = (_modalState_headerElement = modalState.headerElement) === null || _modalState_headerElement === void 0 ? void 0 : _modalState_headerElement.offsetHeight) !== null && _modalState_headerElement_offsetHeight !== void 0 ? _modalState_headerElement_offsetHeight : 0;
    const height = contentHeight + headerHeight;
    var _modalState_innerElement_parentElement_offsetHeight;
    translateYFrom = 100 - height / ((_modalState_innerElement_parentElement_offsetHeight = (_modalState_innerElement = modalState.innerElement) === null || _modalState_innerElement === void 0 ? void 0 : (_modalState_innerElement_parentElement = _modalState_innerElement.parentElement) === null || _modalState_innerElement_parentElement === void 0 ? void 0 : _modalState_innerElement_parentElement.offsetHeight) !== null && _modalState_innerElement_parentElement_offsetHeight !== void 0 ? _modalState_innerElement_parentElement_offsetHeight : 0) * 100;
    translateY = translateYFrom;
    expandedRange = [
      translateY,
      translateY + 25
    ];
    collapsedRange = void 0;
    hiddenRange = [
      translateY + 25,
      translateY + 100
    ];
  }
  const shouldExpand = prevExpandable && modalState.expandable;
  if (shouldExpand && translateY > (prevTranslateY !== null && prevTranslateY !== void 0 ? prevTranslateY : 100) || modalState.settlingHeight === 100) {
    translateY = 0;
  }
  if (translateY === 0) {
    expanded = true;
    collapsed = false;
  }
  modalState.expandedRange = expandedRange;
  modalState.collapsedRange = collapsedRange;
  modalState.hiddenRange = hiddenRange;
  modalState.translateY = translateY;
  modalState.translateYFrom = translateYFrom;
  modalState.collapsed = collapsed;
  modalState.expanded = expanded;
}
function initCardModal(modalState) {
  modalState.translateY = 0;
}
function calculateModalContentHeight(element, isExpandable) {
  if (!isExpandable) {
    return element.scrollHeight;
  }
  const currentHeightStyle = element.style.height;
  element.style.height = "auto";
  const elementHeight = element.scrollHeight;
  element.style.height = currentHeightStyle;
  return elementHeight;
}

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootDesktop.js
var React120 = __toESM(require_react());
var warn11 = warnOnce("ModalRoot");
var ModalRootDesktop = ({ activeModal: activeModalProp, children, noFocusToDialog = false, onOpen, onOpened, onClose, onClosed, modalOverlayTestId }) => {
  const maskElementRef = React120.useRef(null);
  const maskAnimationFrame = React120.useRef(void 0);
  const restoreFocusTo = React120.useRef(void 0);
  const { document: document2 } = useDOM();
  const { hasCustomPanelHeaderAfter, platform: platform3 } = useConfigProvider();
  const { activeModal, exitingModal, onExit, getModalState, enteringModal, onEnter, onEntered: onEnteredProp, onExited, history, delayEnter } = useModalManager(activeModalProp, children, onOpen, onOpened, onClose, onClosed, noop);
  const { waitTransitionFinish } = useWaitTransitionFinish();
  const prevProps = usePrevious({
    exitingModal,
    enteringModal,
    activeModal
  });
  const modalRootContext = useObjectMemo({
    updateModalHeight: () => void 0,
    registerModal: (_param) => {
      var { id } = _param, data = _object_without_properties(_param, [
        "id"
      ]);
      var _getModalState;
      return Object.assign((_getModalState = getModalState(id)) !== null && _getModalState !== void 0 ? _getModalState : {}, data);
    },
    onClose: onExit,
    isInsideModal: true
  });
  const timeout = platform3 === "ios" ? 400 : 320;
  const modals = React120.Children.toArray(children);
  const animateModalOpacity = (modalState, display) => {
    if (modalState === null || modalState === void 0 ? void 0 : modalState.innerElement) {
      modalState.innerElement.style.transition = "";
      modalState.innerElement.style.transitionDelay = display && delayEnter ? `${timeout}ms` : "";
      modalState.innerElement.style.opacity = display ? "1" : "0";
    }
  };
  const setMaskOpacity = (modalState, forceOpacity = null) => {
    if (forceOpacity === null && (history === null || history === void 0 ? void 0 : history[0]) !== modalState.id) {
      return;
    }
    if (maskAnimationFrame.current) {
      cancelAnimationFrame(maskAnimationFrame.current);
    }
    maskAnimationFrame.current = requestAnimationFrame(() => {
      if (maskElementRef.current) {
        const { translateY = 0, translateYCurrent = 0 } = modalState;
        const opacity = forceOpacity === null ? 1 - (translateYCurrent - translateY) / (100 - translateY) || 0 : forceOpacity;
        maskElementRef.current.style.opacity = clamp2(opacity, 0, 100).toString();
      }
    });
  };
  const onEntered = ({ id, modalElement }) => {
    if (!noFocusToDialog && modalElement && !modalElement.contains(document2.activeElement)) {
      modalElement.focus();
    }
    onEnteredProp(id);
  };
  const openModal = () => {
    if (!enteringModal || !prevProps) {
      return;
    }
    const enteringState = getModalState(enteringModal);
    onEnter();
    if (!prevProps.exitingModal) {
      requestAnimationFrame(() => {
        if (enteringModal === enteringModal && enteringState) {
          waitTransitionFinish(enteringState.innerElement, () => onEntered(enteringState), timeout);
          animateModalOpacity(enteringState, true);
          setMaskOpacity(enteringState, 1);
        }
      });
      return;
    }
    requestAnimationFrame(() => {
      if (enteringState === null || enteringState === void 0 ? void 0 : enteringState.innerElement) {
        enteringState.innerElement.style.transition = "none";
        enteringState.innerElement.style.opacity = "1";
        setMaskOpacity(enteringState, 1);
      }
    });
    if (enteringState) {
      onEntered(enteringState);
    }
  };
  const closeModal = (id) => {
    const prevModalState = getModalState(id);
    if (!prevModalState) {
      return;
    }
    if (!activeModal) {
      requestAnimationFrame(() => {
        waitTransitionFinish(prevModalState === null || prevModalState === void 0 ? void 0 : prevModalState.innerElement, () => onExited(id), timeout);
        animateModalOpacity(prevModalState, false);
        setMaskOpacity(prevModalState, 0);
      });
      return;
    }
    onExited(id);
  };
  React120.useEffect(() => {
    if (!prevProps) {
      return;
    }
    if (exitingModal && exitingModal !== prevProps.exitingModal) {
      closeModal(exitingModal);
    }
    if (enteringModal && enteringModal !== prevProps.enteringModal) {
      openModal();
    }
    if (activeModal && !prevProps.activeModal) {
      var _document_activeElement;
      restoreFocusTo.current = (_document_activeElement = document2 === null || document2 === void 0 ? void 0 : document2.activeElement) !== null && _document_activeElement !== void 0 ? _document_activeElement : void 0;
    }
    if (!activeModal && !exitingModal && restoreFocusTo.current) {
      restoreFocusTo.current.focus();
      restoreFocusTo.current = void 0;
    }
  });
  if (!activeModal && !exitingModal) {
    return null;
  }
  return React120.createElement(ModalRootContext.Provider, {
    value: modalRootContext
  }, React120.createElement("div", {
    className: classNames("vkuiModalRoot", hasCustomPanelHeaderAfter && "vkuiModalRoot--hasCustomPanelHeaderAfterSlot", "vkuiModalRoot--desktop")
  }, React120.createElement("div", {
    "data-testid": modalOverlayTestId,
    className: "vkuiModalRoot__mask",
    ref: maskElementRef,
    onClick: onExit
  }), React120.createElement("div", {
    className: "vkuiModalRoot__viewport"
  }, modals.map((Modal) => {
    const modalId = getNavId(Modal.props, warn11);
    if (modalId !== activeModal && modalId !== exitingModal) {
      return null;
    }
    const key = `modal-${modalId}`;
    return React120.createElement(FocusTrap, {
      restoreFocus: false,
      onClose: onExit,
      timeout,
      key,
      className: "vkuiModalRoot__modal"
    }, Modal);
  }))));
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/ModalRootAdaptive.js
var ModalRoot = (props) => {
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  useScrollLock(!!props.activeModal);
  const RootComponent2 = isDesktop ? ModalRootDesktop : ModalRootTouch;
  return React121.createElement(RootComponent2, props);
};

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/withModalRootContext.js
var React122 = __toESM(require_react());
function withModalRootContext(Component3) {
  function WithModalRootContext(props) {
    const { updateModalHeight } = React122.useContext(ModalRootContext);
    return React122.createElement(Component3, _object_spread_props(_object_spread({}, props), {
      updateModalHeight
    }));
  }
  return WithModalRootContext;
}

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPage.js
var React125 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useOrientationChange.js
var React123 = __toESM(require_react());
function getOrientation(window2) {
  var _window_screen_orientation, _window_screen;
  if (!window2) {
    return "portrait";
  }
  var _window_screen_orientation_angle;
  const angle = Math.abs((_window_screen_orientation_angle = (_window_screen = window2.screen) === null || _window_screen === void 0 ? void 0 : (_window_screen_orientation = _window_screen.orientation) === null || _window_screen_orientation === void 0 ? void 0 : _window_screen_orientation.angle) !== null && _window_screen_orientation_angle !== void 0 ? _window_screen_orientation_angle : Number(window2.orientation));
  return angle === 90 ? "landscape" : "portrait";
}
function useOrientationChange() {
  const { window: window2 } = useDOM();
  const [orientation, setOrientation] = React123.useState(() => getOrientation(window2));
  useGlobalEventListener(window2, "orientationchange", () => setOrientation(getOrientation(window2)));
  return orientation;
}

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPageContext.js
var React124 = __toESM(require_react());
var ModalPageContext = React124.createContext({});

// node_modules/@vkontakte/vkui/dist/components/ModalPage/ModalPage.js
var sizeClassName = {
  s: "vkuiModalPage--size-s",
  m: "vkuiModalPage--size-m",
  l: "vkuiModalPage--size-l"
};
var warn12 = warnOnce("ModalPage");
var ModalPage = (_param) => {
  var { children, header, size: sizeProp = "s", onOpen, onOpened, onClose, onClosed, settlingHeight, dynamicContentHeight, getModalContentRef, nav, id: idProp, hideCloseButton = false, height, modalContentTestId, modalDismissButtonTestId, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "children",
    "header",
    "size",
    "onOpen",
    "onOpened",
    "onClose",
    "onClosed",
    "settlingHeight",
    "dynamicContentHeight",
    "getModalContentRef",
    "nav",
    "id",
    "hideCloseButton",
    "height",
    "modalContentTestId",
    "modalDismissButtonTestId",
    "getRootRef"
  ]);
  const generatingId = React125.useId();
  const id = idProp || generatingId;
  const { updateModalHeight } = React125.useContext(ModalRootContext);
  const platform3 = usePlatform();
  const orientation = useOrientationChange();
  const { sizeX, isDesktop } = useAdaptivityWithJSMediaQueries();
  React125.useEffect(() => {
    if (dynamicContentHeight) {
      updateModalHeight();
    }
  }, [
    children,
    dynamicContentHeight,
    orientation,
    updateModalHeight
  ]);
  const isCloseButtonShown = !hideCloseButton && isDesktop;
  const size4 = isDesktop ? sizeProp : "s";
  const modalContext = React125.useContext(ModalRootContext);
  const { refs } = useModalRegistry(getNavId({
    nav,
    id
  }, warn12), "page");
  const rootRef = useExternRef(getRootRef, refs.modalElement);
  const contextValue = React125.useMemo(() => ({
    labelId: `${id}-label`
  }), [
    id
  ]);
  return React125.createElement(ModalPageContext.Provider, {
    value: contextValue
  }, React125.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: rootRef,
    tabIndex: -1,
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": contextValue.labelId,
    id,
    baseClassName: classNames("vkuiModalPage", platform3 === "ios" && "vkuiModalPage--ios", isDesktop && "vkuiModalPage--desktop", sizeX === "regular" && "vkuiInternalModalPage--sizeX-regular", typeof size4 === "string" && sizeClassName[size4])
  }), React125.createElement("div", {
    className: "vkuiModalPage__in-wrap",
    style: {
      maxWidth: typeof size4 === "number" ? size4 : void 0,
      height
    },
    ref: refs.innerElement
  }, React125.createElement("div", {
    className: "vkuiModalPage__in"
  }, React125.createElement("div", {
    className: "vkuiModalPage__header",
    ref: refs.headerElement
  }, header), React125.createElement("div", {
    className: "vkuiModalPage__content-wrap"
  }, React125.createElement("div", _object_spread({
    className: "vkuiModalPage__content",
    ref: multiRef(refs.contentElement, getModalContentRef)
  }, modalContentTestId && {
    "data-testid": modalContentTestId
  }), React125.createElement("div", {
    className: "vkuiModalPage__content-in"
  }, children)), React125.createElement("div", {
    ref: refs.bottomInset,
    className: "vkuiModalPage__bottom-inset"
  })), isCloseButtonShown && React125.createElement(ModalDismissButton, {
    "data-testid": modalDismissButtonTestId,
    onClick: onClose || modalContext.onClose
  })))));
};

// node_modules/@vkontakte/vkui/dist/components/ModalPageHeader/ModalPageHeader.js
var React126 = __toESM(require_react());
var ModalPageHeader = (_param) => {
  var { children, noSeparator = false, getRootRef, className, typographyProps } = _param, restProps = _object_without_properties(_param, [
    "children",
    "noSeparator",
    "getRootRef",
    "className",
    "typographyProps"
  ]);
  const platform3 = usePlatform();
  const { isDesktop, sizeX } = useAdaptivityWithJSMediaQueries();
  const { labelId } = React126.useContext(ModalPageContext);
  return React126.createElement("div", {
    className: classNames("vkuiModalPageHeader", platform3 !== "vkcom" && "vkuiModalPageHeader--withGaps", isDesktop && "vkuiModalPageHeader--desktop"),
    ref: getRootRef
  }, React126.createElement(PanelHeader, _object_spread_props(_object_spread({
    className: classNames("vkuiInternalModalPageHeader__in", className),
    typographyProps: _object_spread({
      Component: "h2",
      id: labelId
    }, typographyProps)
  }, restProps), {
    fixed: false,
    delimiter: "none",
    transparent: true
  }), children), !noSeparator && React126.createElement(Separator, {
    wide: sizeX === "regular"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ModalCard/ModalCard.js
var React130 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ModalCardBase/ModalCardBase.js
var React129 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useKeyboard.js
var React127 = __toESM(require_react());
var eventOptions = {
  passive: true,
  capture: false
};
function useKeyboard2() {
  var _document_activeElement;
  const { document: document2 } = useDOM();
  const [isOpened, setIsOpened] = React127.useState(false);
  const onFocus = React127.useCallback((event) => {
    var _document_activeElement2, _document_activeElement1;
    const isOpened2 = (event === true || event.type === "focusin") && ((document2 === null || document2 === void 0 ? void 0 : (_document_activeElement2 = document2.activeElement) === null || _document_activeElement2 === void 0 ? void 0 : _document_activeElement2.tagName) === "INPUT" || (document2 === null || document2 === void 0 ? void 0 : (_document_activeElement1 = document2.activeElement) === null || _document_activeElement1 === void 0 ? void 0 : _document_activeElement1.tagName) === "TEXTAREA");
    setIsOpened(isOpened2);
  }, [
    document2 === null || document2 === void 0 ? void 0 : (_document_activeElement = document2.activeElement) === null || _document_activeElement === void 0 ? void 0 : _document_activeElement.tagName
  ]);
  React127.useEffect(() => {
    onFocus(true);
  }, [
    onFocus
  ]);
  useGlobalEventListener(document2, "focusout", onFocus, eventOptions);
  useGlobalEventListener(document2, "focusin", onFocus, eventOptions);
  return {
    isOpened
  };
}

// node_modules/@vkontakte/vkui/dist/components/ModalCardBase/ModalCardBaseCloseButton.js
var React128 = __toESM(require_react());
function ModalCardBaseCloseButton({ children = "Закрыть", testId, mode, onClose }) {
  const platform3 = usePlatform();
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  if (isDesktop && mode === "outside") {
    return React128.createElement(ModalDismissButton, {
      "data-testid": testId,
      onClick: onClose
    }, children);
  }
  if (mode === "inside" || platform3 === "ios" && !isDesktop) {
    return React128.createElement(Tappable, {
      className: "vkuiModalCardBase__dismiss",
      onClick: onClose,
      hoverMode: "opacity",
      activeMode: "opacity",
      "data-testid": testId
    }, React128.createElement(VisuallyHidden, null, children), platform3 === "ios" ? React128.createElement(Icon24Dismiss, null) : React128.createElement(Icon20Cancel, null));
  }
  return null;
}

// node_modules/@vkontakte/vkui/dist/components/ModalCardBase/ModalCardBase.js
var ModalCardBase = (_param) => {
  var { icon, header, headerComponent = "span", subheader, subheaderComponent = "span", children, actions, onClose, dismissLabel = "Скрыть", style, size: sizeProp, modalDismissButtonTestId, dismissButtonMode = "outside" } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "header",
    "headerComponent",
    "subheader",
    "subheaderComponent",
    "children",
    "actions",
    "onClose",
    "dismissLabel",
    "style",
    "size",
    "modalDismissButtonTestId",
    "dismissButtonMode"
  ]);
  const platform3 = usePlatform();
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const isSoftwareKeyboardOpened = useKeyboard2().isOpened;
  const size4 = isDesktop ? sizeProp : void 0;
  const withSafeZone = !icon && (dismissButtonMode === "inside" || platform3 === "ios" && !isDesktop);
  const hasHeader = hasReactNode(header);
  const hasSubheader = hasReactNode(subheader);
  return React129.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiInternalModalCardBase", platform3 === "ios" && "vkuiModalCardBase--ios", isDesktop && "vkuiModalCardBase--desktop", withSafeZone && "vkuiModalCardBase--withSafeZone"),
    style: _object_spread_props(_object_spread({}, style), {
      maxWidth: size4
    })
  }), React129.createElement("div", {
    className: classNames("vkuiModalCardBase__container", isSoftwareKeyboardOpened && "vkuiModalCardBase__container--softwareKeyboardOpened")
  }, hasReactNode(icon) && React129.createElement("div", {
    className: "vkuiModalCardBase__icon"
  }, icon), hasReactNode(header) && React129.createElement(Title, {
    level: "2",
    weight: "2",
    className: "vkuiModalCardBase__header",
    Component: headerComponent
  }, header), hasHeader && hasSubheader && React129.createElement(Spacing, {
    size: 8
  }), hasSubheader && React129.createElement(AdaptivityContext.Provider, {
    value: {
      sizeY: "regular"
    }
  }, React129.createElement(Subhead, {
    className: "vkuiModalCardBase__subheader",
    Component: subheaderComponent
  }, subheader)), children, hasReactNode(actions) && React129.createElement("div", {
    className: "vkuiModalCardBase__actions"
  }, actions), React129.createElement(ModalCardBaseCloseButton, {
    testId: modalDismissButtonTestId,
    onClose,
    mode: dismissButtonMode
  }, dismissLabel)));
};

// node_modules/@vkontakte/vkui/dist/components/ModalCard/ModalCard.js
var platformClassNames4 = {
  ios: "vkuiModalCard--ios",
  android: "vkuiModalCard--android",
  vkcom: "vkuiModalCard--vkcom"
};
var warn13 = warnOnce("ModalCard");
var ModalCard = (_param) => {
  var { icon, header, headerComponent, subheader, subheaderComponent, children, actions, onClose, nav, id, size: size4, modalDismissButtonTestId, getRootRef, dismissButtonMode, dismissLabel } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "header",
    "headerComponent",
    "subheader",
    "subheaderComponent",
    "children",
    "actions",
    "onClose",
    "nav",
    "id",
    "size",
    "modalDismissButtonTestId",
    "getRootRef",
    "dismissButtonMode",
    "dismissLabel"
  ]);
  const { isDesktop } = useAdaptivityWithJSMediaQueries();
  const platform3 = usePlatform();
  const modalContext = React130.useContext(ModalRootContext);
  const { refs } = useModalRegistry(getNavId({
    nav,
    id
  }, warn13), "card");
  const rootRef = useExternRef(getRootRef, refs.modalElement);
  const contextValue = React130.useMemo(() => ({
    labelId: `${id}-label`
  }), [
    id
  ]);
  return React130.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: rootRef,
    tabIndex: -1,
    role: "dialog",
    "aria-modal": "true",
    "aria-labelledby": contextValue.labelId,
    id,
    baseClassName: classNames("vkuiModalCard", platformClassNames4.hasOwnProperty(platform3) ? platformClassNames4[platform3] : platformClassNames4.android, isDesktop && "vkuiModalCard--desktop")
  }), React130.createElement(ModalCardBase, {
    className: "vkuiModalCard__in",
    getRootRef: refs.innerElement,
    icon,
    header,
    headerComponent,
    subheader,
    subheaderComponent,
    actions,
    onClose: onClose || modalContext.onClose,
    size: size4,
    modalDismissButtonTestId,
    dismissButtonMode,
    dismissLabel
  }, children));
};

// node_modules/@vkontakte/vkui/dist/components/Badge/Badge.js
var React131 = __toESM(require_react());
var stylesMode2 = {
  new: "vkuiBadge--mode-new",
  prominent: "vkuiBadge--mode-prominent"
};
var Badge = (_param) => {
  var { mode = "new", children } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children"
  ]);
  return React131.createElement(RootComponent, _object_spread({
    Component: "span",
    baseClassName: classNames("vkuiBadge", stylesMode2[mode])
  }, restProps), children && React131.createElement(VisuallyHidden, null, children));
};

// node_modules/@vkontakte/vkui/dist/components/ButtonGroup/ButtonGroup.js
var React132 = __toESM(require_react());
var stylesMode3 = {
  vertical: "vkuiButtonGroup--mode-vertical",
  horizontal: "vkuiButtonGroup--mode-horizontal"
};
var stylesGap = {
  space: "vkuiButtonGroup--gap-space",
  s: "vkuiButtonGroup--gap-s",
  m: "vkuiButtonGroup--gap-m"
};
var stylesAlign2 = {
  left: "vkuiButtonGroup--align-left",
  center: "vkuiButtonGroup--align-center",
  right: "vkuiButtonGroup--align-right"
};
var ButtonGroup = (_param) => {
  var {
    mode = "horizontal",
    gap = "m",
    stretched = false,
    align = "left"
    /* NOTE: Чтобы блоки по-умолчанию не растягивались на всю ширину контейнера */
  } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "gap",
    "stretched",
    "align"
  ]);
  return React132.createElement(RootComponent, _object_spread({
    baseClassName: classNames("vkuiButtonGroup", stylesMode3[mode], gap !== "none" && stylesGap[gap], stretched && "vkuiButtonGroup--stretched", stylesAlign2[align]),
    role: "group"
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Card/Card.js
var React133 = __toESM(require_react());
var Card = (_param) => {
  var { mode = "tint" } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  const withBorder = mode === "outline" || mode === "outline-tint";
  return React133.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiCard", mode === "outline" && "vkuiCard--mode-outline", mode === "shadow" && "vkuiCard--mode-shadow", withBorder && "vkuiCard--withBorder")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CardGrid/CardGrid.js
var React134 = __toESM(require_react());
var sizeXClassNames5 = {
  none: "vkuiCardGrid--sizeX-none",
  ["compact"]: "vkuiCardGrid--sizeX-compact"
};
var stylesSize3 = {
  s: "vkuiInternalCardGrid--size-s",
  m: "vkuiInternalCardGrid--size-m",
  l: "vkuiInternalCardGrid--size-l"
};
var CardGrid = (_param) => {
  var { size: size4 = "s", spaced = false } = _param, restProps = _object_without_properties(_param, [
    "size",
    "spaced"
  ]);
  const { sizeX = "none" } = useAdaptivity();
  return React134.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiCardGrid", "vkuiInternalCardGrid", spaced && "vkuiCardGrid--spaced", stylesSize3[size4], sizeX !== "regular" && sizeXClassNames5[sizeX])
  }));
};

// node_modules/@vkontakte/vkui/dist/components/CardScroll/CardScroll.js
var React135 = __toESM(require_react());
var stylesSize4 = {
  s: "vkuiInternalCardScroll--size-s",
  m: "vkuiInternalCardScroll--size-m",
  l: "vkuiInternalCardScroll--size-l"
};
var CardScroll = (_param) => {
  var { children, size: size4 = "s", showArrows = true, noSpaces = false } = _param, restProps = _object_without_properties(_param, [
    "children",
    "size",
    "showArrows",
    "noSpaces"
  ]);
  const refContainer = React135.useRef(null);
  const gapRef = React135.useRef(null);
  const { window: window2 } = useDOM();
  function getScrollToLeft(offset3) {
    if (!refContainer.current || !gapRef.current) {
      return offset3;
    }
    const containerWidth = refContainer.current.offsetWidth;
    const slideIndex = [
      ...refContainer.current.children
    ].findIndex((el) => el.offsetLeft + el.offsetWidth + parseInt(window2.getComputedStyle(el).marginRight) - offset3 >= 0);
    if (slideIndex === -1) {
      return offset3;
    }
    if (slideIndex === 0) {
      return 0;
    }
    const slide = refContainer.current.children[slideIndex];
    const scrollTo = slide.offsetLeft - (containerWidth - slide.offsetWidth) + gapRef.current.offsetWidth;
    if (scrollTo <= 2 * gapRef.current.offsetWidth) {
      return 0;
    }
    return scrollTo;
  }
  function getScrollToRight(offset3) {
    if (!refContainer.current || !gapRef.current) {
      return offset3;
    }
    const containerWidth = refContainer.current.offsetWidth;
    const slide = Array.prototype.find.call(refContainer.current.children, (el) => el.offsetLeft + el.offsetWidth - offset3 > containerWidth);
    if (!slide) {
      return offset3;
    }
    return slide.offsetLeft - gapRef.current.offsetWidth;
  }
  return React135.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiCardScroll", "vkuiInternalCardScroll", size4 !== false && stylesSize4[size4], !noSpaces && "vkuiCardScroll--withSpaces")
  }), React135.createElement(HorizontalScroll, {
    getScrollToLeft,
    getScrollToRight,
    showArrows
  }, React135.createElement("div", {
    className: "vkuiCardScroll__in",
    ref: refContainer
  }, React135.createElement("span", {
    className: "vkuiCardScroll__gap",
    ref: gapRef
  }), children, React135.createElement("span", {
    className: "vkuiCardScroll__gap"
  }))));
};

// node_modules/@vkontakte/vkui/dist/components/ContentCard/ContentCard.js
var React136 = __toESM(require_react());
var ContentCard = (_param) => {
  var {
    subtitle,
    header,
    headerComponent = "span",
    text,
    caption,
    // card props
    className,
    mode = "shadow",
    style,
    getRootRef,
    // img props
    getRef,
    maxHeight,
    src,
    srcSet,
    alt = "",
    width,
    height,
    crossOrigin,
    decoding,
    loading,
    referrerPolicy,
    sizes,
    useMap,
    hasHover: hasHover2 = false,
    hasActive = false
  } = _param, restProps = _object_without_properties(_param, [
    "subtitle",
    "header",
    "headerComponent",
    "text",
    "caption",
    "className",
    "mode",
    "style",
    "getRootRef",
    "getRef",
    "maxHeight",
    "src",
    "srcSet",
    "alt",
    "width",
    "height",
    "crossOrigin",
    "decoding",
    "loading",
    "referrerPolicy",
    "sizes",
    "useMap",
    "hasHover",
    "hasActive"
  ]);
  return React136.createElement(Card, {
    mode,
    getRootRef,
    style,
    className: classNames(restProps.disabled && "vkuiContentCard--disabled", className)
  }, React136.createElement(Tappable, _object_spread_props(_object_spread({}, restProps), {
    hasHover: hasHover2,
    hasActive,
    className: "vkuiContentCard__tappable"
  }), (src || srcSet) && React136.createElement("img", {
    ref: getRef,
    className: "vkuiContentCard__img",
    src,
    srcSet,
    alt,
    crossOrigin,
    decoding,
    loading,
    referrerPolicy,
    sizes,
    useMap,
    height,
    style: {
      maxHeight
    },
    width: "100%"
  }), React136.createElement("div", {
    className: "vkuiContentCard__body"
  }, hasReactNode(subtitle) && React136.createElement(Caption, {
    className: classNames("vkuiContentCard__text", "vkuiContentCard__subtitle"),
    weight: "1",
    level: "3",
    caps: true
  }, subtitle), hasReactNode(header) && React136.createElement(Headline, {
    className: "vkuiContentCard__text",
    weight: "2",
    level: "1",
    Component: headerComponent
  }, header), hasReactNode(text) && React136.createElement(Text, {
    className: "vkuiContentCard__text"
  }, text), hasReactNode(caption) && React136.createElement(Footnote, {
    className: classNames("vkuiContentCard__text", "vkuiContentCard__caption")
  }, caption))));
};

// node_modules/@vkontakte/vkui/dist/components/Header/Header.js
var React137 = __toESM(require_react());
var HeaderContent = (_param) => {
  var { mode, size: size4 } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "size"
  ]);
  const isLarge = size4 === "large";
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    switch (mode) {
      case "primary":
        return isLarge ? React137.createElement(Title, _object_spread({
          level: "2",
          weight: "2"
        }, restProps)) : React137.createElement(Title, _object_spread({
          weight: "1",
          level: "3"
        }, restProps));
      case "secondary":
        return React137.createElement(Footnote, _object_spread({
          weight: "1",
          caps: true
        }, restProps));
      case "tertiary":
        return React137.createElement(Title, _object_spread({
          weight: "1",
          level: "3"
        }, restProps));
    }
  }
  switch (mode) {
    case "primary":
      return isLarge ? React137.createElement(Title, _object_spread({
        level: "2",
        weight: "2"
      }, restProps)) : React137.createElement(Headline, _object_spread({
        weight: "2"
      }, restProps));
    case "secondary":
      return React137.createElement(Footnote, _object_spread({
        weight: "1",
        caps: true
      }, restProps));
    case "tertiary":
      return React137.createElement(Headline, _object_spread({
        weight: "2"
      }, restProps));
  }
  return null;
};
var stylesMode4 = {
  primary: "vkuiHeader--mode-primary",
  secondary: "vkuiHeader--mode-secondary",
  tertiary: "vkuiHeader--mode-tertiary"
};
var Header = (_param) => {
  var { mode = "primary", size: size4 = "regular", Component: Component3 = "h2", children, subtitle, subtitleComponent = "span", indicator, aside, multiline } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "size",
    "Component",
    "children",
    "subtitle",
    "subtitleComponent",
    "indicator",
    "aside",
    "multiline"
  ]);
  return React137.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiHeader", stylesMode4[mode], size4 === "large" && "vkuiHeader--large", isPrimitiveReactNode(indicator) && "vkuiHeader--pi", hasReactNode(subtitle) && "vkuiHeader--with-subtitle")
  }), React137.createElement("div", {
    className: "vkuiHeader__main"
  }, React137.createElement(HeaderContent, {
    className: "vkuiHeader__content",
    Component: Component3,
    mode,
    size: size4
  }, React137.createElement("span", {
    className: classNames("vkuiHeader__content-in", multiline && "vkuiHeader__content--multiline")
  }, children), hasReactNode(indicator) && React137.createElement(Footnote, {
    className: "vkuiHeader__indicator",
    weight: "2"
  }, indicator)), hasReactNode(subtitle) && React137.createElement(Subhead, {
    className: classNames("vkuiHeader__subtitle", multiline && "vkuiHeader__content--multiline"),
    Component: subtitleComponent
  }, subtitle)), hasReactNode(aside) && React137.createElement(Paragraph, {
    className: "vkuiHeader__aside",
    Component: "span"
  }, aside));
};

// node_modules/@vkontakte/vkui/dist/components/Group/Group.js
var React138 = __toESM(require_react());
var sizeXClassNames6 = {
  none: classNames("vkuiGroup--sizeX-none", "vkuiInternalGroup--sizeX-none"),
  ["compact"]: "vkuiGroup--sizeX-compact"
};
var stylesMode5 = {
  none: classNames("vkuiGroup--mode-none", "vkuiInternalGroup--mode-none"),
  plain: classNames("vkuiGroup--mode-plain", "vkuiInternalGroup--mode-plain"),
  card: classNames("vkuiGroup--mode-card", "vkuiInternalGroup--mode-card")
};
var stylesPadding = {
  s: "vkuiGroup--padding-s",
  m: "vkuiGroup--padding-m"
};
function useGroupMode(forcedMode, sizeX, isInsideModal) {
  const { layout } = React138.useContext(AppRootContext);
  if (forcedMode) {
    return forcedMode;
  }
  if (isInsideModal) {
    return "plain";
  }
  if (layout) {
    return layout;
  }
  if (sizeX !== "none") {
    return sizeX === "regular" ? "card" : "plain";
  }
  return "none";
}
var warn14 = warnOnce("Group");
var Group = (_param) => {
  var { header, description, children, separator = "auto", mode: modeProps, padding = "m", tabIndex: tabIndexProp } = _param, restProps = _object_without_properties(_param, [
    "header",
    "description",
    "children",
    "separator",
    "mode",
    "padding",
    "tabIndex"
  ]);
  const { isInsideModal } = React138.useContext(ModalRootContext);
  const { sizeX = "none" } = useAdaptivity();
  const mode = useGroupMode(modeProps, sizeX, isInsideModal);
  const isTabPanel = restProps.role === "tabpanel";
  if (isTabPanel && (!restProps["aria-controls"] || !restProps["id"])) {
    warn14('При использовании роли "tabpanel" необходимо задать значение свойств "aria-controls" и "id"');
  }
  const tabIndex = isTabPanel && tabIndexProp === void 0 ? 0 : tabIndexProp;
  return React138.createElement(React138.Fragment, null, React138.createElement(RootComponent, _object_spread_props(_object_spread({
    Component: "section"
  }, restProps), {
    tabIndex,
    baseClassName: classNames("vkuiInternalGroup", "vkuiGroup", isInsideModal && "vkuiGroup--inside-modal", sizeX !== "regular" && sizeXClassNames6[sizeX], mode && stylesMode5[mode], stylesPadding[padding])
  }), hasReactNode(header) && React138.createElement("div", {
    className: "vkuiGroup__header"
  }, header), children, hasReactNode(description) && React138.createElement(Footnote, {
    className: "vkuiGroup__description"
  }, description)), separator !== "hide" && React138.createElement(React138.Fragment, null, React138.createElement(Spacing, {
    className: classNames("vkuiGroup__separator", "vkuiGroup__separator--spacing"),
    size: 16
  }), React138.createElement(Separator, {
    className: classNames("vkuiGroup__separator", "vkuiGroup__separator--separator", separator === "show" && "vkuiGroup__separator--force")
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Gradient/Gradient.js
var React139 = __toESM(require_react());
var Gradient = (_param) => {
  var { mode = "default", to = "top" } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "to"
  ]);
  return React139.createElement(RootComponent, _object_spread_props(_object_spread({
    role: "presentation"
  }, restProps), {
    baseClassName: classNames("vkuiGradient", mode !== "default" && "vkuiGradient--mode-tint", to === "bottom" && "vkuiGradient--to-bottom")
  }));
};

// node_modules/@vkontakte/vkui/dist/components/List/List.js
var React141 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/constants.js
var AUTO_SCROLL_START_DELAY = 300;
var ITEM_INITIAL_INDEX = -1;
var DATA_DRAGGABLE_PLACEHOLDER_KEY = "data-draggable-placeholder";
var DATA_DRAGGABLE_PLACEHOLDER_REACT_PROP = {
  [DATA_DRAGGABLE_PLACEHOLDER_KEY]: "true"
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/useDraggableWithDomApi.js
var React140 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/rafSchd.js
var rafSchd = (fn) => {
  let lastArgs = [];
  let frameId = null;
  const wrapperFn = (...args) => {
    lastArgs = args;
    if (frameId) {
      return;
    }
    frameId = requestAnimationFrame(() => {
      frameId = null;
      fn(...lastArgs);
    });
  };
  wrapperFn.cancel = () => {
    if (!frameId) {
      return;
    }
    cancelAnimationFrame(frameId);
    frameId = null;
  };
  return wrapperFn;
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/autoScroll.js
var SCROLL_SPEED = 10;
var EDGE_SIZE = 50;
var OUTBOX_OFFSET = -30;
var getAutoScrollingData = (clientY, scrollEl) => {
  const scrollTop = Math.floor(getNodeScroll(scrollEl).scrollTop);
  const { relative, edges } = getScrollRect(scrollEl);
  const viewportHeight = relative.height;
  const documentHeight = getScrollHeight(scrollEl);
  const maxScrollY = documentHeight - viewportHeight;
  const canScrollUp = scrollTop > 0;
  const canScrollDown = scrollTop < maxScrollY;
  const [edgeTop, edgeBottom] = edges.y;
  const topDistance = clientY - edgeTop;
  const bottomDistance = edgeBottom - clientY;
  const isInTopEdge = topDistance <= EDGE_SIZE;
  const isInBottomEdge = bottomDistance <= EDGE_SIZE;
  const result = {
    shouldScrolling: canScrollUp && isInTopEdge && topDistance >= OUTBOX_OFFSET || canScrollDown && isInBottomEdge && bottomDistance >= OUTBOX_OFFSET,
    y: 0
  };
  if (isInTopEdge) {
    result.y = -1 * ((EDGE_SIZE - topDistance) / EDGE_SIZE) * SCROLL_SPEED;
  } else if (isInBottomEdge) {
    result.y = (EDGE_SIZE - bottomDistance) / EDGE_SIZE * SCROLL_SPEED;
  }
  return result;
};
var createAutoScrollController = (scrollEl) => {
  let isRunning = false;
  const scheduledScroll = rafSchd(scroll);
  function scroll(fn) {
    const { shouldScrolling, y } = fn();
    if (shouldScrolling) {
      isRunning = true;
      scrollEl.scrollBy(0, y);
      scheduledScroll(fn);
    } else {
      isRunning = false;
      scheduledScroll.cancel();
    }
  }
  const tryAutoScroll = (fn) => {
    scheduledScroll(fn);
  };
  const stop = () => {
    isRunning = false;
    scheduledScroll.cancel();
  };
  return {
    tryAutoScroll,
    stop,
    get isRunning() {
      return isRunning;
    }
  };
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/utils.js
var getTargetIsOverOrUnderElData = (clientY, elRect) => {
  const elRectHalfHeight = elRect.height / 2;
  return {
    isUnderEl: clientY <= elRect.bottom - elRectHalfHeight,
    isOverEl: clientY >= elRect.top + elRectHalfHeight
  };
};
var setDraggingItemShiftStyles = (draggingEl, nextShiftY) => {
  requestAnimationFrame(() => {
    draggingEl.style.transform = `translateY(${nextShiftY}px)`;
  });
};
var setSiblingItemsShiftStyles = ([{ el, draggingElRect: { height } }, direction]) => {
  requestAnimationFrame(() => {
    if (direction === "up") {
      el.style.setProperty("transition", "transform 0.3s ease-in 0s");
      el.style.removeProperty("transform");
    } else {
      el.style.setProperty("transition", "transform 0.3s ease-out 0s");
      el.style.setProperty("transform", `translateY(${height}px)`);
    }
  });
};
var setInitialDraggingItemStyles = ({ el, draggingElRect }) => {
  const { top, left, width, height } = draggingElRect;
  requestAnimationFrame(() => {
    el.style.setProperty("pointer-events", "none");
    el.style.setProperty("position", "fixed");
    el.style.setProperty("top", `${top}px`);
    el.style.setProperty("left", `${left}px`);
    el.style.setProperty("width", `${width}px`);
    el.style.setProperty("height", `${height}px`);
    el.style.setProperty("z-index", "var(--vkui_internal--z_index_cell_dragging)");
    el.style.setProperty("box-sizing", "border-box");
    el.style.setProperty("transform", "translateY(0)");
  });
};
var unsetInitialDraggingItemStyles = ({ el }) => {
  requestAnimationFrame(() => {
    el.style.removeProperty("pointer-events");
    el.style.removeProperty("position");
    el.style.removeProperty("top");
    el.style.removeProperty("left");
    el.style.removeProperty("width");
    el.style.removeProperty("height");
    el.style.removeProperty("z-index");
    el.style.removeProperty("box-sizing");
    el.style.removeProperty("transform");
  });
};
var setInitialPlaceholderItemStyles = ({ el, draggingElRect }) => {
  if (el.firstElementChild) {
    return;
  }
  const { width, height } = draggingElRect;
  const node = el.cloneNode();
  node.style.setProperty("display", "block");
  node.style.setProperty("width", `${width}px`);
  node.style.setProperty("height", `${height}px`);
  node.style.setProperty("pointer-events", "none");
  el.appendChild(node);
};
var unsetInitialPlaceholderItemStyles = ({ el }) => {
  if (el.firstElementChild) {
    el.firstElementChild.remove();
  }
};
var setInitialSiblingItemStyles = ({ el, shifted, draggingElRect }) => {
  const { height } = draggingElRect;
  requestAnimationFrame(() => {
    el.style.setProperty("pointer-events", "none");
    el.style.setProperty("transition", "none 0s ease 0s");
    if (shifted) {
      el.style.setProperty("transform", `translateY(${height}px)`);
    }
  });
};
var unsetInitialSiblingItemStyles = ({ el }) => {
  requestAnimationFrame(() => {
    el.style.removeProperty("pointer-events");
    el.style.removeProperty("transition");
    el.style.removeProperty("transform");
  });
};

// node_modules/@vkontakte/vkui/dist/hooks/useDraggableWithDomApi/useDraggableWithDomApi.js
var useDraggableWithDomApi = ({ elRef: draggingElRef, onDragFinish }) => {
  const [dragging, setDragging] = React140.useState(false);
  const lastClientYRef = React140.useRef(0);
  const lastDragShiftYRef = React140.useRef(0);
  const scrollElRef = React140.useRef(null);
  const lastScrollTopRef = React140.useRef(0);
  const scrollControllerRef = React140.useRef(null);
  const initializeScrollRefs = (draggableEl) => {
    const node = getNearestOverflowAncestor2(draggableEl);
    if (node) {
      scrollElRef.current = node;
      lastScrollTopRef.current = getNodeScroll(node).scrollTop;
      scrollControllerRef.current = createAutoScrollController(scrollElRef.current);
    }
  };
  const cleanupScrollRefs = () => {
    var _scrollControllerRef_current;
    lastScrollTopRef.current = 0;
    (_scrollControllerRef_current = scrollControllerRef.current) === null || _scrollControllerRef_current === void 0 ? void 0 : _scrollControllerRef_current.stop();
    scrollElRef.current = scrollControllerRef.current = null;
  };
  const lastDragDirectionRef = React140.useRef(void 0);
  const toggleDragDirection = (prevShiftY, nextShiftY) => {
    const shiftYDiff = prevShiftY - nextShiftY;
    if (shiftYDiff < 0) {
      return "down";
    }
    if (shiftYDiff > 0) {
      return "up";
    }
    return lastDragDirectionRef.current;
  };
  const itemStartIndexRef = React140.useRef(ITEM_INITIAL_INDEX);
  const itemEndIndexRef = React140.useRef(ITEM_INITIAL_INDEX);
  const draggingItemRef = React140.useRef(null);
  const placeholderItemRef = React140.useRef(null);
  const siblingItemsRef = React140.useRef([]);
  const initializeItems = (draggingEl) => {
    const draggingElRect = getBoundingClientRect(draggingEl, true);
    const { children } = draggingEl.parentElement || {
      children: []
    };
    Array.prototype.forEach.call(children, (el, index2) => {
      if (el === draggingEl) {
        itemStartIndexRef.current = itemEndIndexRef.current = index2;
        draggingItemRef.current = {
          index: index2,
          el,
          draggingElRect
        };
      } else if (el.getAttribute(DATA_DRAGGABLE_PLACEHOLDER_KEY) !== null) {
        placeholderItemRef.current = {
          index: index2,
          el,
          draggingElRect
        };
      } else {
        siblingItemsRef.current.push({
          index: index2,
          el,
          shifted: itemStartIndexRef.current !== ITEM_INITIAL_INDEX && itemStartIndexRef.current < index2,
          draggingElRect
        });
      }
    });
    if (placeholderItemRef.current) {
      setInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
    if (draggingItemRef.current) {
      setInitialDraggingItemStyles(draggingItemRef.current);
    }
    siblingItemsRef.current.forEach(setInitialSiblingItemStyles);
  };
  const cleanupItems = () => {
    if (placeholderItemRef.current) {
      unsetInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
    if (draggingItemRef.current) {
      unsetInitialDraggingItemStyles(draggingItemRef.current);
    }
    siblingItemsRef.current.forEach(unsetInitialSiblingItemStyles);
    siblingItemsRef.current = [];
    placeholderItemRef.current = draggingItemRef.current = null;
    const swappedItemIndexRange = {
      from: itemStartIndexRef.current,
      to: itemEndIndexRef.current
    };
    itemStartIndexRef.current = itemEndIndexRef.current = ITEM_INITIAL_INDEX;
    return swappedItemIndexRange;
  };
  const getShiftAndUnshiftItemsPreparedData = (clientY) => {
    const shiftItemEls = [];
    const unshiftItemEls = [];
    itemEndIndexRef.current = itemStartIndexRef.current;
    siblingItemsRef.current.forEach((siblingItem) => {
      const { isOverEl, isUnderEl } = getTargetIsOverOrUnderElData(clientY, getBoundingClientRect(siblingItem.el));
      if (itemStartIndexRef.current < siblingItem.index) {
        if (isOverEl) {
          itemEndIndexRef.current = itemEndIndexRef.current + 1;
          if (lastDragDirectionRef.current === "down" && siblingItem.shifted) {
            siblingItem.shifted = false;
            shiftItemEls.push([
              siblingItem,
              "up"
            ]);
          }
        }
        if (isUnderEl) {
          if (lastDragDirectionRef.current === "up" && !siblingItem.shifted) {
            siblingItem.shifted = true;
            unshiftItemEls.push([
              siblingItem,
              "down"
            ]);
          }
        }
      } else if (itemStartIndexRef.current > siblingItem.index) {
        if (isUnderEl) {
          itemEndIndexRef.current = itemEndIndexRef.current - 1;
          if (lastDragDirectionRef.current === "up" && !siblingItem.shifted) {
            siblingItem.shifted = true;
            shiftItemEls.push([
              siblingItem,
              "down"
            ]);
          }
        }
        if (isOverEl) {
          if (lastDragDirectionRef.current === "down" && siblingItem.shifted) {
            siblingItem.shifted = false;
            unshiftItemEls.push([
              siblingItem,
              "up"
            ]);
          }
        }
      }
    });
    return [
      shiftItemEls,
      unshiftItemEls
    ];
  };
  const setShiftAndUnshiftItemStyles = (shiftItemEls, unshiftItemEls) => {
    shiftItemEls.forEach(setSiblingItemsShiftStyles);
    unshiftItemEls.forEach(setSiblingItemsShiftStyles);
  };
  const schedulingAutoScrollTimeoutIdRef = React140.useRef(null);
  const clearSchedulingAutoScrollTimeout = () => {
    if (schedulingAutoScrollTimeoutIdRef.current) {
      clearTimeout(schedulingAutoScrollTimeoutIdRef.current);
      schedulingAutoScrollTimeoutIdRef.current = null;
    }
  };
  const tryAutoScroll = () => {
    if (scrollControllerRef.current) {
      scrollControllerRef.current.tryAutoScroll(() => {
        return scrollElRef.current ? getAutoScrollingData(lastClientYRef.current, scrollElRef.current) : {
          shouldScrolling: false,
          y: 0
        };
      });
    }
  };
  const schedulingAutoScroll = () => {
    clearSchedulingAutoScrollTimeout();
    schedulingAutoScrollTimeoutIdRef.current = setTimeout(() => {
      schedulingAutoScrollTimeoutIdRef.current = null;
      tryAutoScroll();
    }, AUTO_SCROLL_START_DELAY);
  };
  const onDragStart = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
  };
  const onDragMove = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
    const draggingEl = draggingElRef.current;
    if (!draggingEl) {
      return;
    }
    if (dragging) {
      lastDragDirectionRef.current = toggleDragDirection(lastDragShiftYRef.current, event.shiftY);
      lastDragShiftYRef.current = event.shiftY;
      lastClientYRef.current = event.clientY;
      if (scrollControllerRef.current && scrollControllerRef.current.isRunning) {
        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);
      } else {
        const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(lastClientYRef.current);
        setDraggingItemShiftStyles(draggingEl, lastDragShiftYRef.current);
        setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);
        schedulingAutoScroll();
      }
    } else {
      setDragging((prevDragging) => {
        if (prevDragging) {
          return prevDragging;
        }
        initializeScrollRefs(draggingEl);
        initializeItems(draggingEl);
        return true;
      });
    }
  };
  const onDragEnd = (event) => {
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
    clearSchedulingAutoScrollTimeout();
    cleanupScrollRefs();
    lastClientYRef.current = lastDragShiftYRef.current = 0;
    lastDragDirectionRef.current = void 0;
    if (dragging) {
      const swappedItemRange = cleanupItems();
      if (onDragFinish) {
        onDragFinish(swappedItemRange);
      }
      setDragging(false);
    }
  };
  const handleScroll = React140.useCallback(() => {
    if (!draggingElRef.current || !scrollElRef.current) {
      return;
    }
    const nextScrollTop = getNodeScroll(scrollElRef.current).scrollTop;
    lastDragDirectionRef.current = toggleDragDirection(lastScrollTopRef.current, nextScrollTop);
    const scrollDiff = lastScrollTopRef.current - nextScrollTop;
    const clientYWithScrollOffset = lastClientYRef.current + scrollDiff;
    lastScrollTopRef.current = nextScrollTop;
    const [shiftItemEls, unshiftItemEls] = getShiftAndUnshiftItemsPreparedData(clientYWithScrollOffset);
    setShiftAndUnshiftItemStyles(shiftItemEls, unshiftItemEls);
  }, [
    draggingElRef
  ]);
  useIsomorphicLayoutEffect(function recalculateOnScroll() {
    const scrollEl = scrollElRef.current;
    if (!dragging || !scrollEl) {
      return;
    }
    scrollEl.addEventListener("scroll", handleScroll);
    return () => {
      if (scrollEl) {
        scrollEl.removeEventListener("scroll", handleScroll);
      }
    };
  }, [
    dragging,
    handleScroll
  ]);
  useIsomorphicLayoutEffect(() => function componentWillUnmount() {
    if (placeholderItemRef.current) {
      unsetInitialPlaceholderItemStyles(placeholderItemRef.current);
    }
  }, []);
  return {
    dragging,
    onDragStart,
    onDragMove,
    onDragEnd
  };
};

// node_modules/@vkontakte/vkui/dist/components/List/List.js
var List = (_param) => {
  var { children } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  return React141.createElement(RootComponent, _object_spread({
    role: "list"
  }, restProps), children, React141.createElement("div", _object_spread({
    "aria-hidden": true
  }, DATA_DRAGGABLE_PLACEHOLDER_REACT_PROP)));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/Cell.js
var React147 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Removable/Removable.js
var React142 = __toESM(require_react());
var RemovableIos = ({ onRemove, removePlaceholder, removePlaceholderString, children: childrenProp, toggleButtonTestId, removeButtonTestId }) => {
  const { window: window2 } = useDOM();
  const removeButtonRef = React142.useRef(null);
  const disabledRef = React142.useRef(true);
  const [removeOffset, updateRemoveOffset] = React142.useState(0);
  useGlobalEventListener(window2, "click", () => {
    if (removeOffset > 0) {
      updateRemoveOffset(0);
    }
  }, {
    capture: true
  });
  const onRemoveTransitionEnd = () => {
    if (removeOffset > 0) {
      var _removeButtonRef_current;
      removeButtonRef === null || removeButtonRef === void 0 ? void 0 : (_removeButtonRef_current = removeButtonRef.current) === null || _removeButtonRef_current === void 0 ? void 0 : _removeButtonRef_current.focus();
    } else {
      disabledRef.current = true;
    }
  };
  const onRemoveActivateClick = (e) => {
    e.stopPropagation();
    if (!removeButtonRef.current) {
      return;
    }
    const { offsetWidth } = removeButtonRef.current;
    disabledRef.current = false;
    updateRemoveOffset(offsetWidth);
  };
  return React142.createElement("div", {
    className: classNames("vkuiRemovable__content", "vkuiInternalRemovable__content"),
    style: {
      transform: `translateX(-${removeOffset !== null && removeOffset !== void 0 ? removeOffset : 0}px)`
    },
    onTransitionEnd: onRemoveTransitionEnd
  }, React142.createElement(IconButton, {
    hasActive: false,
    hasHover: false,
    className: classNames("vkuiRemovable__action", "vkuiRemovable__toggle", "vkuiInternalRemovable__action"),
    onClick: onRemoveActivateClick,
    disabled: removeOffset > 0,
    "data-testid": toggleButtonTestId
  }, React142.createElement(VisuallyHidden, null, removePlaceholderString), React142.createElement("i", {
    className: "vkuiRemovable__toggle-in",
    role: "presentation"
  })), typeof childrenProp === "function" ? childrenProp({
    isRemoving: removeOffset > 0
  }) : childrenProp, React142.createElement("span", {
    className: "vkuiRemovable__offset",
    "aria-hidden": true
  }), React142.createElement(Tappable, {
    Component: "button",
    hasActive: false,
    hasHover: false,
    disabled: disabledRef.current,
    getRootRef: removeButtonRef,
    className: "vkuiRemovable__remove",
    onClick: onRemove,
    "data-testid": removeButtonTestId
  }, React142.createElement("span", {
    className: "vkuiRemovable__remove-in"
  }, removePlaceholder)));
};
var Removable = (_param) => {
  var { children, onRemove = noop, removePlaceholder = "Удалить", align = "center", indent = false, toggleButtonTestId, removeButtonTestId } = _param, restProps = _object_without_properties(_param, [
    "children",
    "onRemove",
    "removePlaceholder",
    "align",
    "indent",
    "toggleButtonTestId",
    "removeButtonTestId"
  ]);
  const platform3 = usePlatform();
  const onRemoveClick = (e) => {
    e.preventDefault();
    onRemove(e);
  };
  const removePlaceholderString = getTextFromChildren(removePlaceholder);
  return React142.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames(platform3 === "ios" && "vkuiRemovable--ios", align === "start" && "vkuiRemovable--align-start", indent && "vkuiRemovable--indent")
  }), platform3 !== "ios" && React142.createElement("div", {
    className: classNames("vkuiRemovable__content", "vkuiInternalRemovable__content")
  }, typeof children === "function" ? children({
    isRemoving: false
  }) : children, React142.createElement(IconButton, {
    activeMode: "opacity",
    hoverMode: "opacity",
    className: classNames("vkuiRemovable__action", "vkuiInternalRemovable__action"),
    onClick: onRemoveClick,
    label: removePlaceholderString,
    "data-testid": removeButtonTestId
  }, React142.createElement(Icon24Cancel, {
    role: "presentation"
  })), React142.createElement("span", {
    className: "vkuiRemovable__offset",
    "aria-hidden": true
  })), platform3 === "ios" && React142.createElement(RemovableIos, {
    onRemove: onRemoveClick,
    removePlaceholder,
    removePlaceholderString,
    toggleButtonTestId,
    removeButtonTestId
  }, children));
};

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/SimpleCell.js
var React144 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/Chevron/Chevron.js
var React143 = __toESM(require_react());
var iconSize = {
  s: Icon16Chevron,
  m: Icon24ChevronCompactRight
};
var Chevron = (_param) => {
  var { size: size4 = "m" } = _param, restProps = _object_without_properties(_param, [
    "size"
  ]);
  const Icon = iconSize[size4];
  return React143.createElement(Icon, restProps);
};

// node_modules/@vkontakte/vkui/dist/components/SimpleCell/SimpleCell.js
var sizeYClassNames8 = {
  none: "vkuiSimpleCell--sizeY-none",
  ["compact"]: "vkuiSimpleCell--sizeY-compact"
};
var SimpleCell = (_param) => {
  var { badgeBeforeTitle, badgeAfterTitle, badgeBeforeSubtitle, badgeAfterSubtitle, before, indicator, children, after, expandable, multiline, subhead, subtitle, extraSubtitle, className, chevronSize = "m" } = _param, restProps = _object_without_properties(_param, [
    "badgeBeforeTitle",
    "badgeAfterTitle",
    "badgeBeforeSubtitle",
    "badgeAfterSubtitle",
    "before",
    "indicator",
    "children",
    "after",
    "expandable",
    "multiline",
    "subhead",
    "subtitle",
    "extraSubtitle",
    "className",
    "chevronSize"
  ]);
  const platform3 = usePlatform();
  const hasChevron = expandable === "always" || expandable === "auto" && platform3 === "ios";
  const hasAfter = hasReactNode(after) || hasChevron;
  const { sizeY = "none" } = useAdaptivity();
  return React144.createElement(Tappable, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("vkuiSimpleCell", sizeY !== "regular" && sizeYClassNames8[sizeY], multiline && "vkuiSimpleCell--mult", className)
  }), React144.createElement("div", {
    className: "vkuiSimpleCell__before"
  }, before), React144.createElement("div", {
    className: "vkuiSimpleCell__middle"
  }, subhead && React144.createElement(Subhead, {
    Component: "span",
    className: classNames("vkuiSimpleCell__text", "vkuiSimpleCell__subhead")
  }, subhead), React144.createElement("div", {
    className: "vkuiSimpleCell__content"
  }, badgeBeforeTitle && React144.createElement("span", {
    className: "vkuiSimpleCell__badge"
  }, badgeBeforeTitle), React144.createElement(Headline, {
    Component: "span",
    className: "vkuiSimpleCell__children",
    weight: "3"
  }, children), hasReactNode(badgeAfterTitle) && React144.createElement("span", {
    className: "vkuiSimpleCell__badge"
  }, badgeAfterTitle)), subtitle && React144.createElement("div", {
    className: "vkuiSimpleCell__content"
  }, badgeBeforeSubtitle && React144.createElement("span", {
    className: "vkuiSimpleCell__badge"
  }, badgeBeforeSubtitle), React144.createElement(Footnote, {
    normalize: false,
    className: classNames("vkuiSimpleCell__text", "vkuiSimpleCell__subtitle")
  }, subtitle), badgeAfterSubtitle && React144.createElement("span", {
    className: "vkuiSimpleCell__badge"
  }, badgeAfterSubtitle)), extraSubtitle && React144.createElement(Footnote, {
    className: classNames("vkuiSimpleCell__text", "vkuiSimpleCell__extraSubtitle")
  }, extraSubtitle)), hasReactNode(indicator) && React144.createElement(Headline, {
    Component: "span",
    weight: "3",
    className: "vkuiSimpleCell__indicator"
  }, indicator), hasAfter && React144.createElement("div", {
    className: classNames("vkuiSimpleCell__after", "vkuiInternalSimpleCell__after")
  }, after, hasChevron && React144.createElement(Chevron, {
    size: chevronSize,
    className: "vkuiSimpleCell__chevronIcon"
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/CellCheckbox/CellCheckbox.js
var React145 = __toESM(require_react());
var CheckBoxOn = () => React145.createElement(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckBoxOn,
  IconRegular: Icon24CheckBoxOn
});
var CheckBoxOff = () => React145.createElement(AdaptiveIconRenderer, {
  IconCompact: Icon20CheckBoxOff,
  IconRegular: Icon24CheckBoxOff
});
function useTypeIcon(type) {
  const platform3 = usePlatform();
  if (type !== "auto") {
    return type;
  }
  if (platform3 === "ios" || platform3 === "vkcom") {
    return "circle";
  }
  return "square";
}
var CellCheckbox = (_param) => {
  var { getRootRef, getRef, className, style, type = "auto" } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "getRef",
    "className",
    "style",
    "type"
  ]);
  const typeIcon = useTypeIcon(type);
  const IconOff = typeIcon === "circle" ? Icon24CheckCircleOff : CheckBoxOff;
  const IconOn = typeIcon === "circle" ? Icon24CheckCircleOn : CheckBoxOn;
  return React145.createElement("span", {
    className: classNames("vkuiCellCheckbox", className),
    style,
    ref: getRootRef
  }, React145.createElement(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
    Component: "input",
    type: "checkbox",
    className: "vkuiCellCheckbox__input",
    getRootRef: getRef
  })), React145.createElement("span", {
    className: classNames("vkuiCellCheckbox__icon", "vkuiCellCheckbox__icon--off"),
    "aria-hidden": true
  }, React145.createElement(IconOff, null)), React145.createElement("span", {
    className: classNames("vkuiCellCheckbox__icon", "vkuiCellCheckbox__icon--on"),
    "aria-hidden": true
  }, React145.createElement(IconOn, null)));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/CellDragger/CellDragger.js
var React146 = __toESM(require_react());
var CellDragger = (_param) => {
  var { elRef, disabled, className, onDragStateChange, onDragFinish, children } = _param, restProps = _object_without_properties(_param, [
    "elRef",
    "disabled",
    "className",
    "onDragStateChange",
    "onDragFinish",
    "children"
  ]);
  const platform3 = usePlatform();
  const Icon = platform3 === "ios" ? Icon24ReorderIos : Icon24Reorder;
  const { dragging, onDragStart, onDragMove, onDragEnd } = useDraggableWithDomApi({
    elRef,
    onDragFinish
  });
  useIsomorphicLayoutEffect(() => {
    if (onDragStateChange) {
      onDragStateChange(dragging);
    }
  }, [
    dragging,
    onDragStateChange
  ]);
  return React146.createElement(Touch, _object_spread({
    className: classNames("vkuiCellDragger", className),
    onStart: disabled ? void 0 : onDragStart,
    onMoveY: disabled ? void 0 : onDragMove,
    onEnd: disabled ? void 0 : onDragEnd
  }, restProps), children && React146.createElement(VisuallyHidden, null, children), React146.createElement(Icon, {
    className: "vkuiCellDragger__icon"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Cell/constants.js
var DEFAULT_DRAGGABLE_LABEL = "Перенести ячейку";

// node_modules/@vkontakte/vkui/dist/components/Cell/Cell.js
var Cell = (_param) => {
  var { mode, onRemove = noop, removePlaceholder = "Удалить", onDragFinish, before, after, disabled, draggable, Component: ComponentProps, onChange, name, value, checked, defaultChecked, getRootRef, draggerLabel = DEFAULT_DRAGGABLE_LABEL, className, style, toggleButtonTestId, removeButtonTestId } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "onRemove",
    "removePlaceholder",
    "onDragFinish",
    "before",
    "after",
    "disabled",
    "draggable",
    "Component",
    "onChange",
    "name",
    "value",
    "checked",
    "defaultChecked",
    "getRootRef",
    "draggerLabel",
    "className",
    "style",
    "toggleButtonTestId",
    "removeButtonTestId"
  ]);
  const [dragging, setDragging] = React147.useState(false);
  const selectable = mode === "selectable";
  const removable = mode === "removable";
  const Component3 = selectable ? "label" : ComponentProps;
  const platform3 = usePlatform();
  const rootElRef = useExternRef(getRootRef);
  const dragger = draggable ? React147.createElement(CellDragger, {
    elRef: rootElRef,
    className: "vkuiCell__dragger",
    disabled,
    onDragStateChange: setDragging,
    onDragFinish
  }, draggerLabel) : null;
  let checkbox;
  if (selectable) {
    const checkboxProps = {
      name,
      value,
      defaultChecked,
      checked,
      disabled,
      onChange
    };
    checkbox = React147.createElement(CellCheckbox, _object_spread({
      className: "vkuiCell__checkbox"
    }, checkboxProps));
  }
  const simpleCellDisabled = draggable && !selectable || removable && !restProps.onClick || disabled;
  const hasActive = !simpleCellDisabled && !dragging;
  const cellClasses = classNames("vkuiCell", dragging && "vkuiCell--dragging", platform3 === "ios" && "vkuiCell--ios", removable && "vkuiCell--removable", Component3 === "label" && "vkuiCell--selectable", disabled && "vkuiCell--disabled");
  const simpleCellProps = _object_spread_props(_object_spread({
    hasActive,
    hasHover: hasActive && !removable
  }, restProps), {
    className: "vkuiCell__content",
    Component: Component3,
    before: React147.createElement(React147.Fragment, null, draggable && platform3 !== "ios" && dragger, selectable && checkbox, before),
    after: React147.createElement(React147.Fragment, null, draggable && platform3 === "ios" && dragger, after)
  });
  if (restProps.onClick) {
    simpleCellProps.disabled = simpleCellDisabled;
  }
  if (removable) {
    return React147.createElement(Removable, {
      className: classNames(cellClasses, className),
      style,
      getRootRef: rootElRef,
      removePlaceholder,
      onRemove: (e) => onRemove(e, rootElRef.current),
      toggleButtonTestId,
      removeButtonTestId
    }, platform3 === "ios" ? ({ isRemoving }) => {
      if (simpleCellProps.onClick) {
        simpleCellProps.disabled = isRemoving || !simpleCellProps.disabled;
      }
      return React147.createElement(SimpleCell, simpleCellProps);
    } : React147.createElement(SimpleCell, simpleCellProps));
  }
  return React147.createElement("div", {
    className: classNames(cellClasses, className),
    style,
    ref: rootElRef
  }, React147.createElement(SimpleCell, simpleCellProps));
};
Cell.Checkbox = CellCheckbox;

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCell.js
var React149 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCellIcon/RichCellIcon.js
var React148 = __toESM(require_react());
var RichCellIcon = (props) => {
  return React148.createElement(RootComponent, _object_spread({
    baseClassName: "vkuiRichCellIcon"
  }, props));
};

// node_modules/@vkontakte/vkui/dist/components/RichCell/RichCell.js
var sizeYClassNames9 = {
  none: "vkuiRichCell--sizeY-none",
  ["compact"]: "vkuiRichCell--sizeY-compact"
};
var RichCell = (_param) => {
  var { subhead, children, text, caption, before, after, afterCaption, bottom, actions, multiline, className } = _param, restProps = _object_without_properties(_param, [
    "subhead",
    "children",
    "text",
    "caption",
    "before",
    "after",
    "afterCaption",
    "bottom",
    "actions",
    "multiline",
    "className"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return React149.createElement(Tappable, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("vkuiRichCell", !multiline && "vkuiRichCell--text-ellipsis", sizeY !== "regular" && sizeYClassNames9[sizeY], className)
  }), before && React149.createElement("div", {
    className: "vkuiRichCell__before"
  }, before), React149.createElement("div", {
    className: "vkuiRichCell__in"
  }, React149.createElement("div", {
    className: "vkuiRichCell__content"
  }, React149.createElement("div", {
    className: "vkuiRichCell__content-before"
  }, subhead && React149.createElement(Subhead, {
    Component: "div",
    className: "vkuiRichCell__subhead"
  }, subhead), React149.createElement("div", {
    className: "vkuiRichCell__children"
  }, children), text && React149.createElement("div", {
    className: "vkuiRichCell__text"
  }, text), caption && React149.createElement(Subhead, {
    Component: "div",
    className: "vkuiRichCell__caption"
  }, caption)), (after || afterCaption) && React149.createElement("div", {
    className: "vkuiRichCell__content-after"
  }, after && React149.createElement("div", {
    className: "vkuiRichCell__after-children"
  }, after), afterCaption && React149.createElement("div", {
    className: "vkuiRichCell__after-caption"
  }, afterCaption))), bottom && React149.createElement("div", {
    className: "vkuiRichCell__bottom"
  }, bottom), actions && React149.createElement("div", {
    className: "vkuiRichCell__actions"
  }, actions)));
};
RichCell.Icon = RichCellIcon;

// node_modules/@vkontakte/vkui/dist/components/CellButton/CellButton.js
var React150 = __toESM(require_react());
var CellButton = (_param) => {
  var { centered = false, mode = "primary", className } = _param, restProps = _object_without_properties(_param, [
    "centered",
    "mode",
    "className"
  ]);
  return React150.createElement(SimpleCell, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("vkuiCellButton", mode === "danger" && "vkuiCellButton--mode-danger", centered && "vkuiCellButton--centered", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/HorizontalCell/HorizontalCell.js
var React155 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Avatar/Avatar.js
var React154 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadge.js
var React151 = __toESM(require_react());
var AvatarBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size4 } = React151.useContext(ImageBaseContext);
  return React151.createElement(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("vkuiAvatarBadge", size4 < 96 && "vkuiAvatarBadge--shifted", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadgeWithPreset.js
var React153 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/icons.js
var React152 = __toESM(require_react());
var Icon12Circle2 = (_param) => {
  var { width = 12, height = 12 } = _param, restProps = _object_without_properties(_param, [
    "width",
    "height"
  ]);
  return React152.createElement(Icon12Circle, _object_spread_props(_object_spread({}, restProps), {
    width: width >= 24 ? 15 : 12,
    height: height >= 24 ? 15 : 12
  }));
};
var Icon12OnlineMobile2 = (_param) => {
  var { width = 8, height = 12 } = _param, restProps = _object_without_properties(_param, [
    "width",
    "height"
  ]);
  return React152.createElement(Icon12OnlineMobile, _object_spread_props(_object_spread({}, restProps), {
    width: width >= 24 ? 9 : 8,
    height: height >= 24 ? 15 : 12
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Avatar/AvatarBadge/AvatarBadgeWithPreset.js
var AvatarBadgeWithPreset = (_param) => {
  var { preset = "online", className } = _param, restProps = _object_without_properties(_param, [
    "preset",
    "className"
  ]);
  const { size: size4 } = React153.useContext(ImageBaseContext);
  const badgeSize = getBadgeIconSizeByImageBaseSize(size4);
  const isOnlinePreset = preset === "online";
  const presetClassName = isOnlinePreset ? "vkuiAvatarBadge--preset-online" : "vkuiAvatarBadge--preset-onlineMobile";
  const Icon = isOnlinePreset ? Icon12Circle2 : Icon12OnlineMobile2;
  return React153.createElement(ImageBase.Badge, _object_spread({
    background: "stroke",
    className: classNames("vkuiAvatarBadge", presetClassName, className)
  }, restProps), React153.createElement(Icon, {
    width: badgeSize,
    height: badgeSize
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Avatar/helpers.js
var MAX_FONT_SIZE = 30;
var MAX_IMAGE_BASE_SIZE = 96;
var RELATIVE_SIZE = MAX_FONT_SIZE / MAX_IMAGE_BASE_SIZE;
function getInitialsFontSize(avatarSize) {
  if (avatarSize <= 16) {
    return 5;
  } else if (avatarSize <= 24) {
    return 8;
  } else if (avatarSize <= 32) {
    return 10;
  } else if (avatarSize <= 36) {
    return 13;
  } else if (avatarSize <= 44) {
    return 14;
  } else if (avatarSize <= 48) {
    return 17;
  } else if (avatarSize < 56) {
    return 18;
  } else if (avatarSize <= 64) {
    return 21;
  } else if (avatarSize <= 88) {
    return 26;
  } else if (avatarSize <= MAX_IMAGE_BASE_SIZE) {
    return MAX_FONT_SIZE;
  }
  const calculatedFontSize = Math.ceil(avatarSize * RELATIVE_SIZE);
  const evenFix = calculatedFontSize % 2;
  return calculatedFontSize + evenFix;
}

// node_modules/@vkontakte/vkui/dist/components/Avatar/Avatar.js
var AVATAR_DEFAULT_SIZE = 48;
var COLORS_NUMBER_TO_TEXT_MAP = {
  1: "red",
  2: "orange",
  3: "yellow",
  4: "green",
  5: "l-blue",
  6: "violet"
};
var gradientStyles = {
  "red": "vkuiAvatar--gradient-red",
  "orange": "vkuiAvatar--gradient-orange",
  "yellow": "vkuiAvatar--gradient-yellow",
  "green": "vkuiAvatar--gradient-green",
  "blue": "vkuiAvatar--gradient-blue",
  "l-blue": "vkuiAvatar--gradient-l-blue",
  "violet": "vkuiAvatar--gradient-violet"
};
var Avatar = (_param) => {
  var { size: size4 = AVATAR_DEFAULT_SIZE, className, gradientColor, initials, fallbackIcon: fallbackIconProp, children } = _param, restProps = _object_without_properties(_param, [
    "size",
    "className",
    "gradientColor",
    "initials",
    "fallbackIcon",
    "children"
  ]);
  const gradientName = typeof gradientColor === "number" ? COLORS_NUMBER_TO_TEXT_MAP[gradientColor] : gradientColor;
  const isGradientNotCustom = gradientName && gradientName !== "custom";
  const fallbackIcon = initials ? React154.createElement("div", {
    className: "vkuiAvatar__initials",
    style: {
      fontSize: getInitialsFontSize(size4)
    }
  }, initials) : fallbackIconProp;
  return React154.createElement(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    size: size4,
    fallbackIcon,
    className: classNames("vkuiAvatar", gradientName && "vkuiAvatar--has-gradient", isGradientNotCustom && gradientStyles[gradientName], className)
  }), children);
};
Avatar.Badge = AvatarBadge;
Avatar.BadgeWithPreset = AvatarBadgeWithPreset;
Avatar.Overlay = ImageBase.Overlay;
Avatar.getInitialsFontSize = getInitialsFontSize;

// node_modules/@vkontakte/vkui/dist/components/HorizontalCell/HorizontalCell.js
var stylesSize5 = {
  s: "vkuiHorizontalCell--size-s",
  m: "vkuiHorizontalCell--size-m",
  l: "vkuiHorizontalCell--size-l"
};
var CellTypography = (_param) => {
  var { size: size4, children } = _param, restProps = _object_without_properties(_param, [
    "size",
    "children"
  ]);
  return size4 === "s" ? React155.createElement(Caption, restProps, children) : React155.createElement(Subhead, restProps, children);
};
var HorizontalCell = (_param) => {
  var { className, header, style, subtitle, size: size4 = "s", children = React155.createElement(Avatar, {
    size: 56
  }), getRootRef, getRef, extraSubtitle } = _param, restProps = _object_without_properties(_param, [
    "className",
    "header",
    "style",
    "subtitle",
    "size",
    "children",
    "getRootRef",
    "getRef",
    "extraSubtitle"
  ]);
  return React155.createElement("div", {
    ref: getRootRef,
    style,
    className: classNames("vkuiHorizontalCell", stylesSize5[size4], className)
  }, React155.createElement(Tappable, _object_spread({
    className: "vkuiHorizontalCell__body",
    getRootRef: getRef
  }, restProps), hasReactNode(children) && React155.createElement("div", {
    className: "vkuiHorizontalCell__image"
  }, children), (header || subtitle || extraSubtitle) && React155.createElement("div", {
    className: "vkuiHorizontalCell__content"
  }, hasReactNode(header) && React155.createElement(CellTypography, {
    size: size4
  }, header), hasReactNode(subtitle) && React155.createElement(Footnote, {
    className: "vkuiHorizontalCell__subtitle"
  }, subtitle), hasReactNode(extraSubtitle) && React155.createElement(Footnote, {
    className: "vkuiHorizontalCell__subtitle"
  }, extraSubtitle))));
};

// node_modules/@vkontakte/vkui/dist/components/HorizontalScroll/HorizontalCellShowMore/HorizontalCellShowMore.js
var React156 = __toESM(require_react());
var sizeClassNames = {
  s: "vkuiHorizontalCellShowMore--size-s",
  m: "vkuiHorizontalCellShowMore--size-m",
  l: "vkuiHorizontalCellShowMore--size-l"
};
var HorizontalCellShowMore = (_param) => {
  var { className, style, getRef, getRootRef, compensateLastCellIndent, height, size: size4 = "s", children = size4 === "s" ? "Все" : "Показать все" } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "getRef",
    "getRootRef",
    "compensateLastCellIndent",
    "height",
    "size",
    "children"
  ]);
  return React156.createElement("div", {
    style,
    className: classNames("vkuiHorizontalCellShowMore", compensateLastCellIndent && "vkuiHorizontalCellShowMore--compensate-last-cell-indent", sizeClassNames[size4], className),
    ref: getRootRef
  }, React156.createElement(Tappable, _object_spread({
    style: size4 === "s" ? void 0 : {
      height
    },
    className: "vkuiHorizontalCellShowMore__body",
    getRootRef: getRef,
    activeMode: "opacity",
    hoverMode: "opacity"
  }, restProps), React156.createElement(Icon28ChevronRightCircle, {
    className: "vkuiHorizontalCellShowMore__icon",
    fill: "currentColor"
  }), React156.createElement(Subhead, {
    className: "vkuiHorizontalCellShowMore__text",
    weight: "2"
  }, children)));
};

// node_modules/@vkontakte/vkui/dist/components/Footer/Footer.js
var React157 = __toESM(require_react());
var Footer = (_param) => {
  var { children, className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  return React157.createElement(Footnote, _object_spread_props(_object_spread({
    Component: "footer"
  }, restProps), {
    className: classNames("vkuiFooter", className)
  }), children);
};

// node_modules/@vkontakte/vkui/dist/components/InfoRow/InfoRow.js
var React158 = __toESM(require_react());
var InfoRow = (_param) => {
  var { header, children, className } = _param, restProps = _object_without_properties(_param, [
    "header",
    "children",
    "className"
  ]);
  return React158.createElement(Headline, _object_spread_props(_object_spread({}, restProps), {
    Component: "span",
    className: classNames("vkuiInfoRow", className),
    weight: "3"
  }), hasReactNode(header) && React158.createElement(Subhead, {
    Component: "strong",
    className: "vkuiInfoRow__header"
  }, header, React158.createElement(VisuallyHidden, null, " ")), children);
};

// node_modules/@vkontakte/vkui/dist/components/Gallery/Gallery.js
var React163 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/BaseGallery.js
var React159 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/helpers.js
var calcMin = ({ containerWidth = 0, layerWidth = 0, slides = [], viewportOffsetWidth = 0, align, isCenterWithCustomWidth }) => {
  switch (align) {
    case "left":
      return containerWidth - layerWidth;
    case "right":
      return viewportOffsetWidth - layerWidth;
    case "center":
      if (isCenterWithCustomWidth && slides.length) {
        const { coordX: coordX2, width } = slides[slides.length - 1];
        return viewportOffsetWidth / 2 - coordX2 - width / 2;
      } else {
        return viewportOffsetWidth - (containerWidth - viewportOffsetWidth) / 2 - layerWidth;
      }
  }
  return void 0;
};
var calcMax = ({ slides = [], viewportOffsetWidth = 0, isCenterWithCustomWidth }) => {
  if (isCenterWithCustomWidth && slides.length) {
    const { width, coordX: coordX2 } = slides[0];
    return viewportOffsetWidth / 2 - coordX2 - width / 2;
  }
  return 0;
};

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/BaseGallery.js
var ANIMATION_DURATION = 0.24;
var LAYOUT_DEFAULT_STATE = {
  containerWidth: 0,
  viewportOffsetWidth: 0,
  layerWidth: 0,
  min: 0,
  max: 0,
  slides: [],
  isFullyVisible: true
};
var SHIFT_DEFAULT_STATE = {
  animation: void 0,
  shiftX: 0,
  dragging: false,
  deltaX: 0,
  indent: 0
};
var stylesBullets = {
  dark: "vkuiBaseGallery__bullets--dark",
  light: "vkuiBaseGallery__bullets--light"
};
var BaseGallery = (_param) => {
  var { bullets = false, getRootRef, children, slideWidth = "100%", slideIndex = 0, dragDisabled = false, onDragStart, onDragEnd, onChange, onPrevClick, onNextClick, align = "left", showArrows, getRef, arrowSize = "l" } = _param, restProps = _object_without_properties(_param, [
    "bullets",
    "getRootRef",
    "children",
    "slideWidth",
    "slideIndex",
    "dragDisabled",
    "onDragStart",
    "onDragEnd",
    "onChange",
    "onPrevClick",
    "onNextClick",
    "align",
    "showArrows",
    "getRef",
    "arrowSize"
  ]);
  const slidesStore = React159.useRef({});
  const layoutState = React159.useRef(LAYOUT_DEFAULT_STATE);
  const [shiftState, setShiftState] = React159.useState(SHIFT_DEFAULT_STATE);
  const rootRef = useExternRef(getRootRef);
  const viewportRef = useExternRef(getRef);
  const { window: window2 } = useDOM();
  const hasPointer = useAdaptivityHasPointer();
  const isCenterWithCustomWidth = slideWidth === "custom" && align === "center";
  const validateIndent = (value) => {
    var _layoutState_current_max;
    const localMax = (_layoutState_current_max = layoutState.current.max) !== null && _layoutState_current_max !== void 0 ? _layoutState_current_max : 0;
    var _layoutState_current_min;
    const localMin = (_layoutState_current_min = layoutState.current.min) !== null && _layoutState_current_min !== void 0 ? _layoutState_current_min : 0;
    if (value < localMin) {
      return localMin;
    } else if (value > localMax) {
      return localMax;
    }
    return value;
  };
  const calculateIndent2 = (targetIndex) => {
    var _layoutState_current_slides;
    if (layoutState.current.isFullyVisible) {
      return 0;
    }
    const targetSlide = ((_layoutState_current_slides = layoutState.current.slides) === null || _layoutState_current_slides === void 0 ? void 0 : _layoutState_current_slides.length) ? layoutState.current.slides[targetIndex] : null;
    if (targetSlide) {
      const { coordX: coordX2, width } = targetSlide;
      if (isCenterWithCustomWidth) {
        var _layoutState_current_viewportOffsetWidth;
        const viewportWidth = (_layoutState_current_viewportOffsetWidth = layoutState.current.viewportOffsetWidth) !== null && _layoutState_current_viewportOffsetWidth !== void 0 ? _layoutState_current_viewportOffsetWidth : 0;
        return viewportWidth / 2 - coordX2 - width / 2;
      }
      return validateIndent(-1 * coordX2);
    }
    return 0;
  };
  const calculateDragIndent = () => {
    var _layoutState_current_max;
    const localMax = (_layoutState_current_max = layoutState.current.max) !== null && _layoutState_current_max !== void 0 ? _layoutState_current_max : 0;
    var _layoutState_current_min;
    const localMin = (_layoutState_current_min = layoutState.current.min) !== null && _layoutState_current_min !== void 0 ? _layoutState_current_min : 0;
    const indent2 = shiftState.shiftX + shiftState.deltaX;
    if (indent2 > localMax) {
      return localMax + Number((indent2 - localMax) / 3);
    } else if (indent2 < localMin) {
      return localMin + Number((indent2 - localMin) / 3);
    }
    return indent2;
  };
  const initializeSlides = (options = {}) => {
    var _rootRef_current, _viewportRef_current, _layoutState_current_slides_slideIndex, _localSlides_slideIndex;
    var _React_Children_map;
    const localSlides = (_React_Children_map = React159.Children.map(children, (_item, i) => {
      const elem = slidesStore.current[`slide-${i}`];
      var _elem_offsetLeft, _elem_offsetWidth;
      return {
        coordX: (_elem_offsetLeft = elem === null || elem === void 0 ? void 0 : elem.offsetLeft) !== null && _elem_offsetLeft !== void 0 ? _elem_offsetLeft : 0,
        width: (_elem_offsetWidth = elem === null || elem === void 0 ? void 0 : elem.offsetWidth) !== null && _elem_offsetWidth !== void 0 ? _elem_offsetWidth : 0
      };
    })) !== null && _React_Children_map !== void 0 ? _React_Children_map : [];
    var _rootRef_current_offsetWidth;
    const localContainerWidth = (_rootRef_current_offsetWidth = (_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.offsetWidth) !== null && _rootRef_current_offsetWidth !== void 0 ? _rootRef_current_offsetWidth : 0;
    var _viewportRef_current_offsetWidth;
    const localViewportOffsetWidth = (_viewportRef_current_offsetWidth = (_viewportRef_current = viewportRef.current) === null || _viewportRef_current === void 0 ? void 0 : _viewportRef_current.offsetWidth) !== null && _viewportRef_current_offsetWidth !== void 0 ? _viewportRef_current_offsetWidth : 0;
    const localLayerWidth = localSlides.reduce((val, slide) => slide.width + val, 0);
    const adjustShiftX = localSlides.length <= layoutState.current.slides.length || ((_layoutState_current_slides_slideIndex = layoutState.current.slides[slideIndex]) === null || _layoutState_current_slides_slideIndex === void 0 ? void 0 : _layoutState_current_slides_slideIndex.coordX) !== ((_localSlides_slideIndex = localSlides[slideIndex]) === null || _localSlides_slideIndex === void 0 ? void 0 : _localSlides_slideIndex.coordX);
    layoutState.current = {
      containerWidth: localContainerWidth,
      viewportOffsetWidth: localViewportOffsetWidth,
      layerWidth: localLayerWidth,
      max: calcMax({
        slides: localSlides,
        viewportOffsetWidth: localViewportOffsetWidth,
        isCenterWithCustomWidth
      }),
      min: calcMin({
        containerWidth: localContainerWidth,
        layerWidth: localLayerWidth,
        slides: localSlides,
        viewportOffsetWidth: localViewportOffsetWidth,
        isCenterWithCustomWidth,
        align
      }),
      slides: localSlides,
      isFullyVisible: localLayerWidth <= localContainerWidth
    };
    setShiftState((prevState) => {
      var _options_animation;
      return _object_spread_props(_object_spread({}, prevState), {
        shiftX: adjustShiftX ? calculateIndent2(slideIndex) : prevState.shiftX,
        animation: (_options_animation = options.animation) !== null && _options_animation !== void 0 ? _options_animation : prevState.shiftX === validateIndent(prevState.shiftX)
      });
    });
  };
  const onResize = () => {
    if (shiftState.animation !== void 0) {
      initializeSlides({
        animation: false
      });
    }
  };
  useGlobalEventListener(window2, "resize", onResize);
  useIsomorphicLayoutEffect(() => {
    initializeSlides({
      animation: false
    });
  }, [
    children,
    align,
    slideWidth
  ]);
  useIsomorphicLayoutEffect(() => {
    if (shiftState.animation !== void 0) {
      setShiftState((prevState) => _object_spread_props(_object_spread({}, prevState), {
        animation: true,
        deltaX: 0,
        shiftX: calculateIndent2(slideIndex !== null && slideIndex !== void 0 ? slideIndex : 0)
      }));
    }
  }, [
    slideIndex
  ]);
  const slideLeft = (event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex - 1);
    onPrevClick === null || onPrevClick === void 0 ? void 0 : onPrevClick(event);
  };
  const slideRight = (event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(slideIndex + 1);
    onNextClick === null || onNextClick === void 0 ? void 0 : onNextClick(event);
  };
  const getTarget = (e) => {
    const expectDeltaX = shiftState.deltaX / e.duration * 240 * 0.6;
    var _layoutState_current_max;
    const shift4 = shiftState.shiftX + shiftState.deltaX + expectDeltaX - ((_layoutState_current_max = layoutState.current.max) !== null && _layoutState_current_max !== void 0 ? _layoutState_current_max : 0);
    const direction = shiftState.deltaX < 0 ? 1 : -1;
    let targetIndex = layoutState.current.slides.reduce((val, item, index2) => {
      const previousValue = Math.abs(layoutState.current.slides[val].coordX + shift4);
      const currentValue = Math.abs(item.coordX + shift4);
      return previousValue < currentValue ? val : index2;
    }, slideIndex);
    if (targetIndex === slideIndex) {
      let targetSlide = slideIndex + direction;
      if (targetSlide >= 0 && targetSlide < layoutState.current.slides.length) {
        if (Math.abs(shiftState.deltaX) > layoutState.current.slides[targetSlide].width * 0.05) {
          targetIndex = targetSlide;
        }
      }
    }
    return targetIndex;
  };
  const isDraggable = !dragDisabled && !layoutState.current.isFullyVisible;
  const onStart = (e) => {
    e.originalEvent.stopPropagation();
    if (isDraggable) {
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(e);
      setShiftState((prevState) => _object_spread_props(_object_spread({}, prevState), {
        animation: false
      }));
    }
  };
  const onMoveX = (e) => {
    if (isDraggable) {
      e.originalEvent.preventDefault();
      if (e.isSlideX) {
        if (shiftState.deltaX !== e.shiftX) {
          setShiftState((prevState) => _object_spread_props(_object_spread({}, prevState), {
            deltaX: e.shiftX,
            dragging: e.isSlideX
          }));
        }
      }
    }
  };
  const onEnd = (e) => {
    if (isDraggable) {
      const targetIndex = e.isSlide ? getTarget(e) : slideIndex !== null && slideIndex !== void 0 ? slideIndex : 0;
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(e, targetIndex);
      const nextShiftState = {
        animation: true,
        dragging: false,
        deltaX: 0
      };
      const shiftXStick = calculateDragIndent();
      if (targetIndex !== slideIndex) {
        nextShiftState.shiftX = shiftXStick;
      }
      setShiftState((prevState) => _object_spread({}, prevState, nextShiftState));
      if (targetIndex !== slideIndex) {
        onChange === null || onChange === void 0 ? void 0 : onChange(targetIndex);
      }
    }
  };
  const indent = shiftState.dragging ? calculateDragIndent() : shiftState.shiftX;
  const layerStyle = {
    WebkitTransform: `translateX(${indent}px)`,
    transform: `translateX(${indent}px)`,
    WebkitTransition: shiftState.animation ? `-webkit-transform ${ANIMATION_DURATION}s cubic-bezier(.1, 0, .25, 1)` : "none",
    transition: shiftState.animation ? `transform ${ANIMATION_DURATION}s cubic-bezier(.1, 0, .25, 1)` : "none"
  };
  const setSlideRef = (slideRef, slideIndex2) => {
    slidesStore.current[`slide-${slideIndex2}`] = slideRef;
  };
  const canSlideLeft = !layoutState.current.isFullyVisible && shiftState.shiftX < 0;
  var _layoutState_current_layerWidth;
  const canSlideRight = !layoutState.current.isFullyVisible && // we can't move right when gallery layer fully scrolled right, if gallery aligned by left side
  (align === "left" && layoutState.current.containerWidth - shiftState.shiftX < ((_layoutState_current_layerWidth = layoutState.current.layerWidth) !== null && _layoutState_current_layerWidth !== void 0 ? _layoutState_current_layerWidth : 0) || // otherwise we need to check current slide index (align = right or align = center)
  align !== "left" && slideIndex < layoutState.current.slides.length - 1);
  return React159.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiBaseGallery", align === "center" && "vkuiBaseGallery--align-center", slideWidth === "custom" && "vkuiBaseGallery--custom-width", isDraggable && "vkuiBaseGallery--draggable"),
    getRootRef: rootRef
  }), React159.createElement(Touch, {
    className: "vkuiBaseGallery__viewport",
    onStartX: onStart,
    onMoveX,
    onEnd,
    style: {
      width: slideWidth === "custom" ? "100%" : slideWidth
    },
    getRootRef: viewportRef,
    noSlideClick: true
  }, React159.createElement("div", {
    className: "vkuiBaseGallery__layer",
    style: layerStyle
  }, React159.Children.map(children, (item, i) => React159.createElement("div", {
    className: "vkuiBaseGallery__slide",
    key: `slide-${i}`,
    ref: (el) => setSlideRef(el, i)
  }, item)))), bullets && React159.createElement("div", {
    "aria-hidden": true,
    className: classNames("vkuiBaseGallery__bullets", stylesBullets[bullets])
  }, React159.Children.map(children, (_item, index2) => React159.createElement("div", {
    className: classNames("vkuiBaseGallery__bullet", index2 === slideIndex && "vkuiBaseGallery__bullet--active"),
    key: index2
  }))), showArrows && hasPointer && canSlideLeft && React159.createElement(ScrollArrow, {
    className: "vkuiBaseGallery__arrow",
    direction: "left",
    onClick: slideLeft,
    size: arrowSize
  }), showArrows && hasPointer && canSlideRight && React159.createElement(ScrollArrow, {
    className: "vkuiBaseGallery__arrow",
    direction: "right",
    onClick: slideRight,
    size: arrowSize
  }));
};

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/CarouselBase.js
var React161 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/constants.js
var ANIMATION_DURATION2 = 240;
var SLIDE_THRESHOLD = 0.05;
var CONTROL_ELEMENTS_STATE = {
  canSlideLeft: true,
  canSlideRight: true,
  isDraggable: true
};
var SLIDES_MANAGER_STATE = {
  viewportOffsetWidth: 0,
  slides: [],
  isFullyVisible: true,
  loopPoints: [],
  contentSize: 0,
  snaps: []
};

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/helpers.js
function calculateIndent(targetIndex, slidesManager, isCenterWithCustomWidth) {
  if (slidesManager.isFullyVisible || !slidesManager.slides.length) {
    return 0;
  }
  const targetSlide = slidesManager.slides[targetIndex];
  if (targetSlide) {
    const { coordX: coordX2, width } = targetSlide;
    if (isCenterWithCustomWidth) {
      return slidesManager.viewportOffsetWidth / 2 - coordX2 - width / 2;
    }
    return -1 * coordX2;
  }
  return 0;
}
function getShiftedIndexes(direction, slides, availableWidth) {
  let gap = availableWidth;
  const shiftedSlideIndexes = [];
  const startIndex = direction === 1 ? 0 : slides.length - 1;
  const endIndex = direction === 1 ? slides.length - 1 : 0;
  for (let i = startIndex; (direction === 1 ? i <= endIndex : i >= endIndex) && gap > 0; i += direction) {
    const slideWidth = slides[i].width;
    if (gap > 0) {
      shiftedSlideIndexes.push(i);
    }
    gap -= slideWidth;
  }
  return shiftedSlideIndexes;
}
function calculateLoopPoints(indexes, edge, slidesManager, containerWidth) {
  const { contentSize, slides, snaps } = slidesManager;
  const isStartEdge = edge === "start";
  const offset3 = isStartEdge ? -contentSize : contentSize;
  return indexes.map((index2) => {
    const initial = isStartEdge ? 0 : -contentSize;
    const altered = isStartEdge ? contentSize : 0;
    const loopPoint = isStartEdge ? snaps[index2] + containerWidth + offset3 : snaps[index2] - slides[index2].width + offset3 - snaps[0];
    return {
      index: index2,
      target: (currentLocation) => {
        return currentLocation >= loopPoint ? initial : altered;
      }
    };
  });
}
function getLoopPoints(slidesManager, containerWidth) {
  const { slides, snaps } = slidesManager;
  const startShiftedIndexes = getShiftedIndexes(-1, slides, snaps[0]);
  const endShiftedIndexes = getShiftedIndexes(1, slides, containerWidth - snaps[0]);
  return [
    ...calculateLoopPoints(endShiftedIndexes, "start", slidesManager, containerWidth),
    ...calculateLoopPoints(startShiftedIndexes, "end", slidesManager, containerWidth)
  ];
}
function getTargetIndex(slides, slideIndex, currentShiftX, currentShiftXDelta) {
  const shift4 = currentShiftX + currentShiftXDelta;
  const direction = currentShiftXDelta < 0 ? 1 : -1;
  let targetIndex = slides.reduce((val, item, index2) => {
    const previousValue = Math.abs(slides[val].coordX + shift4);
    const currentValue = Math.abs(item.coordX + shift4);
    return previousValue < currentValue ? val : index2;
  }, slideIndex);
  if (targetIndex === slideIndex) {
    let targetSlide = slideIndex + direction;
    if (targetSlide >= 0 && targetSlide < slides.length) {
      if (Math.abs(currentShiftXDelta) > slides[targetSlide].width * SLIDE_THRESHOLD) {
        return targetSlide;
      }
      return targetIndex;
    }
    return direction < 0 ? (targetSlide + slides.length) % slides.length : targetSlide % slides.length;
  }
  return targetIndex;
}

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/hooks.js
var React160 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/animate.js
function animate2({ duration, timing, draw, animationQueue = [] }) {
  if (!canUseDOM) {
    return;
  }
  let start;
  requestAnimationFrame(function animate3(time) {
    if (!start) {
      start = time;
    }
    let timeFraction = Math.min((time - start) / duration, 1);
    const progress = timing(timeFraction);
    draw(progress);
    if (timeFraction < 1) {
      requestAnimationFrame(animate3);
      return;
    }
    animationQueue.shift();
    if (animationQueue.length > 0) {
      animationQueue[0]();
    }
  });
}

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/hooks.js
var TIMING_FUNCTION = cubicBezier(0.8, 1);
function useSlideAnimation() {
  const animationQueue = React160.useRef([]);
  function getAnimateFunction(drawFunction) {
    return () => {
      animate2({
        duration: ANIMATION_DURATION2,
        timing: TIMING_FUNCTION,
        animationQueue: animationQueue.current,
        draw: drawFunction
      });
    };
  }
  function addToAnimationQueue(func) {
    animationQueue.current.push(func);
  }
  function startAnimation() {
    if (animationQueue.current.length === 1) {
      animationQueue.current[0]();
    }
  }
  return {
    getAnimateFunction,
    addToAnimationQueue,
    startAnimation
  };
}

// node_modules/@vkontakte/vkui/dist/components/BaseGallery/CarouselBase/CarouselBase.js
var stylesBullets2 = {
  dark: "vkuiBaseGallery__bullets--dark",
  light: "vkuiBaseGallery__bullets--light"
};
var warn15 = warnOnce("Gallery");
var CarouselBase = (_param) => {
  var { bullets = false, getRootRef, children, slideWidth = "100%", slideIndex = 0, dragDisabled = false, onDragStart, onDragEnd, onChange, onPrevClick, onNextClick, align = "left", showArrows, getRef, arrowSize = "l" } = _param, restProps = _object_without_properties(_param, [
    "bullets",
    "getRootRef",
    "children",
    "slideWidth",
    "slideIndex",
    "dragDisabled",
    "onDragStart",
    "onDragEnd",
    "onChange",
    "onPrevClick",
    "onNextClick",
    "align",
    "showArrows",
    "getRef",
    "arrowSize"
  ]);
  const slidesStore = React161.useRef({});
  const slidesManager = React161.useRef(SLIDES_MANAGER_STATE);
  const rootRef = useExternRef(getRootRef);
  const viewportRef = useExternRef(getRef);
  const layerRef = React161.useRef(null);
  const animationFrameRef = React161.useRef(null);
  const shiftXCurrentRef = React161.useRef(0);
  const shiftXDeltaRef = React161.useRef(0);
  const initialized = React161.useRef(false);
  const { addToAnimationQueue, getAnimateFunction, startAnimation } = useSlideAnimation();
  const [controlElementsState, setControlElementsState] = React161.useState(CONTROL_ELEMENTS_STATE);
  const { window: window2 } = useDOM();
  const hasPointer = useAdaptivityHasPointer();
  const isCenterWithCustomWidth = slideWidth === "custom" && align === "center";
  const transformCssStyles = (shiftX, animation = false) => {
    slidesManager.current.loopPoints.forEach((loopPoint) => {
      const { target, index: index2 } = loopPoint;
      const slide = slidesStore.current[index2];
      if (slide) {
        slide.style.transform = `translate3d(${target(shiftX)}px, 0, 0)`;
      }
    });
    if (layerRef.current) {
      layerRef.current.style.transform = `translate3d(${shiftX}px, 0, 0)`;
      layerRef.current.style.transition = animation ? `transform ${ANIMATION_DURATION2}ms cubic-bezier(.1, 0, .25, 1)` : "";
    }
  };
  const requestTransform = (shiftX, animation = false) => {
    const { snaps, contentSize, slides } = slidesManager.current;
    if (animationFrameRef.current !== null) {
      cancelAnimationFrame(animationFrameRef.current);
    }
    animationFrameRef.current = requestAnimationFrame(() => {
      if (shiftX > snaps[0]) {
        shiftXCurrentRef.current = -contentSize + snaps[0];
        shiftX = shiftXCurrentRef.current + shiftXDeltaRef.current;
      }
      const lastPoint = slides[slides.length - 1].width + slides[slides.length - 1].coordX;
      if (shiftX <= -lastPoint) {
        shiftXCurrentRef.current = Math.abs(shiftXDeltaRef.current) + snaps[0];
      }
      transformCssStyles(shiftX, animation);
    });
  };
  const initializeSlides = () => {
    if (!rootRef.current || !viewportRef.current) {
      return;
    }
    let localSlides = React161.Children.map(children, (_item, i) => {
      const elem = slidesStore.current[i] || {
        offsetLeft: 0,
        offsetWidth: 0
      };
      return {
        coordX: elem.offsetLeft,
        width: elem.offsetWidth
      };
    }) || [];
    const containerWidth = rootRef.current.offsetWidth;
    const viewportOffsetWidth = viewportRef.current.offsetWidth;
    const layerWidth = localSlides.reduce((val, slide) => slide.width + val, 0);
    if (true) {
      let remainingWidth = containerWidth;
      let slideIndex2 = 0;
      while (remainingWidth > 0 && slideIndex2 < localSlides.length) {
        remainingWidth -= localSlides[slideIndex2].width;
        slideIndex2++;
      }
      if (remainingWidth <= 0 && slideIndex2 === localSlides.length) {
        warn15('Ширины слайдов недостаточно для корректной работы свойства "looped". Пожалуйста, сделайте её больше."');
      }
    }
    if (align === "center") {
      const firstSlideShift = (containerWidth - localSlides[0].width) / 2;
      localSlides = localSlides.map((item) => {
        return {
          width: item.width,
          coordX: item.coordX - firstSlideShift
        };
      });
    }
    slidesManager.current = _object_spread_props(_object_spread({}, slidesManager.current), {
      viewportOffsetWidth,
      slides: localSlides,
      isFullyVisible: layerWidth <= containerWidth
    });
    const snaps = localSlides.map((_, index2) => calculateIndent(index2, slidesManager.current, isCenterWithCustomWidth));
    let contentSize = -snaps[snaps.length - 1] + localSlides[localSlides.length - 1].width;
    if (align === "center") {
      contentSize += snaps[0];
    }
    slidesManager.current.snaps = snaps;
    slidesManager.current.contentSize = contentSize;
    slidesManager.current.loopPoints = getLoopPoints(slidesManager.current, containerWidth);
    setControlElementsState({
      canSlideLeft: !slidesManager.current.isFullyVisible,
      canSlideRight: !slidesManager.current.isFullyVisible,
      isDraggable: !(dragDisabled || slidesManager.current.isFullyVisible)
    });
    shiftXCurrentRef.current = snaps[slideIndex];
    initialized.current = true;
    requestTransform(shiftXCurrentRef.current);
  };
  const onResize = () => {
    if (initialized.current) {
      initializeSlides();
    }
  };
  useGlobalEventListener(window2, "resize", onResize);
  useIsomorphicLayoutEffect(function performSlideChange() {
    if (!initialized.current) {
      return;
    }
    const { snaps, slides } = slidesManager.current;
    const indent = snaps[slideIndex];
    let startPoint = shiftXCurrentRef.current;
    if (indent === snaps[0] && shiftXCurrentRef.current <= snaps[snaps.length - 1]) {
      const distance = Math.abs(snaps[snaps.length - 1]) + slides[slides.length - 1].width + startPoint;
      addToAnimationQueue(getAnimateFunction((progress) => {
        const shiftX = startPoint + progress * distance * -1;
        transformCssStyles(shiftX);
        if (shiftX <= snaps[snaps.length - 1] - slides[slides.length - 1].width) {
          requestAnimationFrame(() => {
            shiftXCurrentRef.current = indent;
            transformCssStyles(snaps[0]);
          });
        }
      }));
    } else if (indent === snaps[snaps.length - 1] && shiftXCurrentRef.current === snaps[0]) {
      startPoint = indent - slides[slides.length - 1].width;
      addToAnimationQueue(() => {
        requestAnimationFrame(() => {
          const shiftX = indent - slides[slides.length - 1].width;
          transformCssStyles(shiftX);
          getAnimateFunction((progress) => {
            transformCssStyles(startPoint + progress * slides[slides.length - 1].width);
          })();
        });
      });
    } else {
      addToAnimationQueue(() => {
        const distance = Math.abs(indent - startPoint);
        let direction = startPoint <= indent ? 1 : -1;
        getAnimateFunction((progress) => {
          const shiftX = startPoint + progress * distance * direction;
          transformCssStyles(shiftX);
        })();
      });
    }
    startAnimation();
    shiftXCurrentRef.current = indent;
  }, [
    slideIndex
  ]);
  useIsomorphicLayoutEffect(() => {
    initializeSlides();
  }, [
    children,
    align,
    slideWidth
  ]);
  const slideLeft = (event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange((slideIndex - 1 + slidesManager.current.slides.length) % slidesManager.current.slides.length);
    onPrevClick === null || onPrevClick === void 0 ? void 0 : onPrevClick(event);
  };
  const slideRight = (event) => {
    onChange === null || onChange === void 0 ? void 0 : onChange((slideIndex + 1) % slidesManager.current.slides.length);
    onNextClick === null || onNextClick === void 0 ? void 0 : onNextClick(event);
  };
  const onStart = (e) => {
    e.originalEvent.stopPropagation();
    if (controlElementsState.isDraggable) {
      onDragStart === null || onDragStart === void 0 ? void 0 : onDragStart(e);
      shiftXCurrentRef.current = slidesManager.current.snaps[slideIndex];
      shiftXDeltaRef.current = 0;
    }
  };
  const onMoveX = (e) => {
    if (controlElementsState.isDraggable) {
      e.originalEvent.preventDefault();
      if (e.isSlideX) {
        if (shiftXDeltaRef.current !== e.shiftX) {
          shiftXDeltaRef.current = e.shiftX;
          requestTransform(shiftXCurrentRef.current + shiftXDeltaRef.current);
        }
      }
    }
  };
  const onEnd = (e) => {
    if (controlElementsState.isDraggable) {
      let targetIndex = slideIndex;
      if (e.isSlide) {
        targetIndex = getTargetIndex(slidesManager.current.slides, slideIndex, shiftXCurrentRef.current, shiftXDeltaRef.current);
      }
      onDragEnd === null || onDragEnd === void 0 ? void 0 : onDragEnd(e, targetIndex);
      if (targetIndex !== slideIndex) {
        shiftXCurrentRef.current = shiftXCurrentRef.current + shiftXDeltaRef.current;
        onChange === null || onChange === void 0 ? void 0 : onChange(targetIndex);
      } else {
        const initialShiftX = slidesManager.current.snaps[targetIndex];
        requestTransform(initialShiftX, true);
      }
    }
  };
  const setSlideRef = (slideRef, slideIndex2) => {
    slidesStore.current[slideIndex2] = slideRef;
  };
  const { canSlideLeft, canSlideRight, isDraggable } = controlElementsState;
  return React161.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiBaseGallery", slideWidth === "custom" && "vkuiBaseGallery--custom-width", isDraggable && "vkuiBaseGallery--draggable"),
    getRootRef: rootRef
  }), React161.createElement(Touch, {
    className: "vkuiBaseGallery__viewport",
    onStartX: onStart,
    onMoveX,
    onEnd,
    style: {
      width: slideWidth === "custom" ? "100%" : slideWidth
    },
    getRootRef: viewportRef,
    noSlideClick: true
  }, React161.createElement("div", {
    className: "vkuiBaseGallery__layer",
    ref: layerRef
  }, React161.Children.map(children, (item, i) => React161.createElement("div", {
    className: "vkuiBaseGallery__slide",
    key: `slide-${i}`,
    ref: (el) => setSlideRef(el, i)
  }, item)))), bullets && React161.createElement("div", {
    "aria-hidden": true,
    className: classNames("vkuiBaseGallery__bullets", stylesBullets2[bullets])
  }, React161.Children.map(children, (_item, index2) => React161.createElement("div", {
    className: classNames("vkuiBaseGallery__bullet", index2 === slideIndex && "vkuiBaseGallery__bullet--active"),
    key: index2
  }))), showArrows && hasPointer && canSlideLeft && React161.createElement(ScrollArrow, {
    className: "vkuiBaseGallery__arrow",
    direction: "left",
    onClick: slideLeft,
    size: arrowSize
  }), showArrows && hasPointer && canSlideRight && React161.createElement(ScrollArrow, {
    className: "vkuiBaseGallery__arrow",
    direction: "right",
    onClick: slideRight,
    size: arrowSize
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Gallery/hooks.js
var React162 = __toESM(require_react());
function useAutoPlay(timeout, slideIndex, callbackFn) {
  const { clear: clearAutoPlay, set: setAutoPlay } = useTimeout(callbackFn, timeout);
  const { document: document2 } = useDOM();
  React162.useEffect(() => timeout ? setAutoPlay() : clearAutoPlay(), [
    timeout,
    slideIndex,
    clearAutoPlay,
    setAutoPlay
  ]);
  React162.useEffect(function preventSlideChange() {
    if (!document2 || !timeout) {
      return;
    }
    const changeAutoPlay = () => {
      if (document2.visibilityState === "visible") {
        clearAutoPlay();
        setAutoPlay();
      }
      if (document2.visibilityState === "hidden") {
        clearAutoPlay();
      }
    };
    document2.addEventListener("visibilitychange", changeAutoPlay);
    return () => {
      document2.removeEventListener("visibilitychange", changeAutoPlay);
    };
  }, [
    document2,
    timeout,
    clearAutoPlay,
    setAutoPlay
  ]);
}

// node_modules/@vkontakte/vkui/dist/components/Gallery/Gallery.js
var Gallery = (_param) => {
  var { initialSlideIndex = 0, children, timeout = 0, onChange, bullets, looped } = _param, props = _object_without_properties(_param, [
    "initialSlideIndex",
    "children",
    "timeout",
    "onChange",
    "bullets",
    "looped"
  ]);
  const [localSlideIndex, setSlideIndex] = React163.useState(initialSlideIndex);
  const isControlled = typeof props.slideIndex === "number";
  var _props_slideIndex;
  const slideIndex = isControlled ? (_props_slideIndex = props.slideIndex) !== null && _props_slideIndex !== void 0 ? _props_slideIndex : 0 : localSlideIndex;
  const slides = React163.useMemo(() => React163.Children.toArray(children).filter((item) => Boolean(item)), [
    children
  ]);
  const childCount = slides.length;
  const isClient = useIsClient();
  const handleChange = React163.useCallback((current) => {
    if (current === slideIndex) {
      return;
    }
    !isControlled && setSlideIndex(current);
    onChange && onChange(current);
  }, [
    isControlled,
    onChange,
    slideIndex
  ]);
  useAutoPlay(timeout, slideIndex, () => handleChange((slideIndex + 1) % childCount));
  const safeSlideIndex = childCount > 0 ? clamp2(slideIndex, 0, childCount - 1) : slideIndex;
  React163.useEffect(() => {
    if (onChange && safeSlideIndex !== slideIndex) {
      onChange(safeSlideIndex);
    }
    setSlideIndex(safeSlideIndex);
  }, [
    onChange,
    safeSlideIndex,
    slideIndex
  ]);
  if (!isClient) {
    return null;
  }
  const Component3 = looped ? CarouselBase : BaseGallery;
  return React163.createElement(Component3, _object_spread_props(_object_spread({
    dragDisabled: isControlled && !onChange
  }, props), {
    bullets: childCount > 0 && bullets,
    slideIndex: safeSlideIndex,
    onChange: handleChange
  }), slides);
};

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatar.js
var React165 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatarBadge/GridAvatarBadge.js
var React164 = __toESM(require_react());
var GridAvatarBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size4 } = React164.useContext(ImageBaseContext);
  return React164.createElement(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("vkuiGridAvatarBadge", size4 < 96 && "vkuiGridAvatarBadge--shifted", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/GridAvatar/GridAvatar.js
var GRID_AVATAR_DEFAULT_SIZE = 48;
var MAX_GRID_LENGTH = 4;
var warn16 = warnOnce("GridAvatar");
var GridAvatar = (_param) => {
  var { src = [], size: size4 = GRID_AVATAR_DEFAULT_SIZE, className, children } = _param, restProps = _object_without_properties(_param, [
    "src",
    "size",
    "className",
    "children"
  ]);
  if (true) {
    if (src.length > MAX_GRID_LENGTH) {
      warn16(`Длина массива src (${src.length}) больше максимальной (${MAX_GRID_LENGTH})`, "error");
    }
  }
  return React165.createElement(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    size: size4,
    className: classNames("vkuiGridAvatar", className)
  }), React165.createElement("div", {
    className: "vkuiGridAvatar__in",
    "aria-hidden": true
  }, src.map((url, index2) => index2 < MAX_GRID_LENGTH ? React165.createElement("div", {
    key: url,
    className: "vkuiGridAvatar__item",
    style: {
      backgroundImage: `url(${url})`
    }
  }) : null)), children);
};
GridAvatar.Badge = GridAvatarBadge;

// node_modules/@vkontakte/vkui/dist/components/Image/Image.js
var React167 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Image/ImageBadge/ImageBadge.js
var React166 = __toESM(require_react());
var ImageBadge = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  const { size: size4 } = React166.useContext(ImageBaseContext);
  return React166.createElement(ImageBase.Badge, _object_spread_props(_object_spread({}, restProps), {
    className: classNames("vkuiImageBadge", size4 < 96 && "vkuiImageBadge--shifted", className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Image/Image.js
var IMAGE_DEFAULT_SIZE = 48;
var getBorderRadiusBySize = (size4, borderRadius) => {
  switch (borderRadius) {
    case "s": {
      if (size4 <= 32) {
        return 2;
      }
      if (size4 <= 56) {
        return 3;
      }
      return 4;
    }
    case "m": {
      if (size4 <= 32) {
        return 3;
      }
      if (size4 <= 48) {
        return 4;
      }
      if (size4 <= 72) {
        return 6;
      }
      if (size4 <= 80) {
        return 8;
      }
      return 10;
    }
    case "l": {
      if (size4 <= 16) {
        return 4;
      }
      if (size4 <= 20) {
        return 5;
      }
      if (size4 <= 32) {
        return 6;
      }
      if (size4 <= 40) {
        return 8;
      }
      if (size4 <= 48) {
        return 10;
      }
      if (size4 <= 56) {
        return 12;
      }
      if (size4 <= 64) {
        return 14;
      }
      return 16;
    }
  }
};
var Image = (_param) => {
  var { size: size4 = IMAGE_DEFAULT_SIZE, borderRadius: borderRadiusProp = "m", style, className } = _param, restProps = _object_without_properties(_param, [
    "size",
    "borderRadius",
    "style",
    "className"
  ]);
  const borderRadius = React167.useMemo(() => getBorderRadiusBySize(size4, borderRadiusProp), [
    size4,
    borderRadiusProp
  ]);
  return React167.createElement(ImageBase, _object_spread_props(_object_spread({}, restProps), {
    size: size4,
    style: _object_spread_props(_object_spread({}, style), {
      borderRadius
    }),
    className
  }));
};
Image.Badge = ImageBadge;
Image.Overlay = ImageBase.Overlay;

// node_modules/@vkontakte/vkui/dist/components/Progress/Progress.js
var React168 = __toESM(require_react());
var stylesAppearance3 = {
  accent: "vkuiProgress--appearance-accent",
  positive: "vkuiProgress--appearance-positive",
  negative: "vkuiProgress--appearance-negative"
};
function progressCustomHeightStyle(height) {
  return height ? {
    height,
    borderRadius: height / 2
  } : void 0;
}
function progressStyle(height, styleProps) {
  const styleHeight = progressCustomHeightStyle(height);
  const style = styleHeight ? _object_spread({}, styleProps, styleHeight) : styleProps;
  return style;
}
var PROGRESS_MIN_VALUE = 0;
var PROGRESS_MAX_VALUE = 100;
var Progress = (_param) => {
  var { value = 0, appearance = "accent", height, style: styleProps } = _param, restProps = _object_without_properties(_param, [
    "value",
    "appearance",
    "height",
    "style"
  ]);
  const progress = clamp2(value, PROGRESS_MIN_VALUE, PROGRESS_MAX_VALUE);
  const title = `${progress} / ${PROGRESS_MAX_VALUE}`;
  const style = progressStyle(height, styleProps);
  return React168.createElement(RootComponent, _object_spread_props(_object_spread({
    "aria-valuenow": value,
    title,
    style
  }, restProps), {
    role: "progressbar",
    "aria-valuemin": PROGRESS_MIN_VALUE,
    "aria-valuemax": PROGRESS_MAX_VALUE,
    baseClassName: classNames("vkuiProgress", stylesAppearance3[appearance])
  }), React168.createElement("div", {
    className: "vkuiProgress__in",
    style: {
      width: `${progress}%`
    }
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Search/Search.js
var React170 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useBooleanState.js
var React169 = __toESM(require_react());
var useBooleanState = (defaultValue = false) => {
  const [value, setValue] = React169.useState(defaultValue);
  const setTrue = React169.useCallback(() => {
    setValue(true);
  }, []);
  const setFalse = React169.useCallback(() => {
    setValue(false);
  }, []);
  const toggle = React169.useCallback(() => {
    setValue(!value);
  }, [
    value
  ]);
  return {
    value,
    setTrue,
    setFalse,
    toggle
  };
};

// node_modules/@vkontakte/vkui/dist/components/Search/Search.js
var Search = (_param) => {
  var { id: idProp, before = React170.createElement(Icon16SearchOutline, null), className, placeholder = "Поиск", after = "Отмена", getRef, icon, onIconClick = noop, style, autoComplete = "off", onChange, iconLabel, clearLabel = "Очистить", noPadding, getRootRef, findButtonText = "Найти", onFindButtonClick } = _param, inputProps = _object_without_properties(_param, [
    "id",
    "before",
    "className",
    "placeholder",
    "after",
    "getRef",
    "icon",
    "onIconClick",
    "style",
    "autoComplete",
    "onChange",
    "iconLabel",
    "clearLabel",
    "noPadding",
    "getRootRef",
    "findButtonText",
    "onFindButtonClick"
  ]);
  const inputRef = useExternRef(getRef);
  const { value: isFocused, setTrue: setFocusedTrue, setFalse: setFocusedFalse } = useBooleanState(false);
  const generatedId = React170.useId();
  const inputId = idProp ? idProp : `search-${generatedId}`;
  const [hasValue, setHasValue] = React170.useState(() => Boolean(inputProps.value || inputProps.defaultValue));
  const checkHasValue = (e) => setHasValue(Boolean(e.currentTarget.value));
  const { sizeY = "none" } = useAdaptivity();
  const { sizeY: adaptiveSizeY } = useAdaptivityConditionalRender();
  const platform3 = usePlatform();
  const onFocus = (e) => {
    setFocusedTrue();
    inputProps.onFocus && inputProps.onFocus(e);
  };
  const onBlur = (e) => {
    setFocusedFalse();
    inputProps.onBlur && inputProps.onBlur(e);
  };
  const onCancel = React170.useCallback(() => {
    var _Object_getOwnPropertyDescriptor, _inputRef_current;
    const nativeInputValueSetter = (_Object_getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor(HTMLInputElement.prototype, "value")) === null || _Object_getOwnPropertyDescriptor === void 0 ? void 0 : _Object_getOwnPropertyDescriptor.set;
    nativeInputValueSetter === null || nativeInputValueSetter === void 0 ? void 0 : nativeInputValueSetter.call(inputRef.current, "");
    const ev2 = new Event("input", {
      bubbles: true
    });
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.dispatchEvent(ev2);
  }, [
    inputRef
  ]);
  const onIconClickStart = React170.useCallback((e) => onIconClick(e), [
    onIconClick
  ]);
  const onIconCancelClickStart = React170.useCallback((e) => {
    var _inputRef_current;
    e.preventDefault();
    (_inputRef_current = inputRef.current) === null || _inputRef_current === void 0 ? void 0 : _inputRef_current.focus();
    if (touchEnabled()) {
      onCancel();
    }
  }, [
    inputRef,
    onCancel
  ]);
  return React170.createElement("div", {
    className: classNames("vkuiInternalSearch", "vkuiSearch", sizeY === "none" && "vkuiSearch--sizeY-none", sizeY === "compact" && "vkuiSearch--sizeY-compact", isFocused && "vkuiSearch--focused", hasValue && "vkuiSearch--has-value", after && "vkuiSearch--has-after", icon && "vkuiSearch--has-icon", inputProps.disabled && "vkuiSearch--disabled", !noPadding && "vkuiSearch--withPadding", className),
    ref: getRootRef,
    style
  }, React170.createElement("div", {
    className: "vkuiSearch__field"
  }, React170.createElement("label", {
    htmlFor: inputId,
    className: "vkuiSearch__label"
  }, placeholder), React170.createElement("div", {
    className: "vkuiSearch__input"
  }, before, React170.createElement(Headline, _object_spread_props(_object_spread({
    Component: "input",
    type: "search",
    level: "1",
    weight: "3"
  }, inputProps), {
    id: inputId,
    placeholder,
    autoComplete,
    getRootRef: inputRef,
    className: "vkuiSearch__nativeInput",
    onFocus,
    onBlur,
    onChange: callMultiple(onChange, checkHasValue)
  }))), React170.createElement("div", {
    className: "vkuiSearch__controls"
  }, icon && React170.createElement(IconButton, {
    hoverMode: "opacity",
    onPointerDown: onIconClickStart,
    className: "vkuiSearch__icon",
    onFocus: setFocusedTrue,
    onBlur: setFocusedFalse,
    onClick: noop
  }, React170.createElement(VisuallyHidden, null, iconLabel), icon), React170.createElement(IconButton, {
    hoverMode: "opacity",
    onPointerDown: onIconCancelClickStart,
    onClick: onCancel,
    className: "vkuiSearch__icon",
    tabIndex: hasValue ? void 0 : -1
  }, React170.createElement(VisuallyHidden, null, clearLabel), platform3 === "ios" ? React170.createElement(Icon16Clear, null) : React170.createElement(Icon24Cancel, null)), adaptiveSizeY.compact && onFindButtonClick && React170.createElement(Button, {
    mode: "primary",
    size: "m",
    className: classNames("vkuiSearch__findButton", adaptiveSizeY.compact.className),
    focusVisibleMode: "inside",
    onClick: onFindButtonClick,
    tabIndex: hasValue ? void 0 : -1
  }, findButtonText))), platform3 === "ios" && after && React170.createElement(Button, {
    mode: "tertiary",
    size: "m",
    className: "vkuiSearch__after",
    focusVisibleMode: "inside",
    onClick: onCancel,
    onFocus: setFocusedTrue,
    onBlur: setFocusedFalse
  }, React170.createElement("span", {
    className: "vkuiSearch__afterText"
  }, after)));
};

// node_modules/@vkontakte/vkui/dist/components/Tabs/Tabs.js
var React171 = __toESM(require_react());
var TabsModeContext = React171.createContext({
  mode: "default",
  withGaps: false,
  layoutFillMode: "auto",
  withScrollToSelectedTab: false,
  scrollBehaviorToSelectedTab: "nearest"
});
var Tabs = (_param) => {
  var { children, mode = "default", role = "tablist", withScrollToSelectedTab, scrollBehaviorToSelectedTab = "nearest", layoutFillMode = "auto" } = _param, restProps = _object_without_properties(_param, [
    "children",
    "mode",
    "role",
    "withScrollToSelectedTab",
    "scrollBehaviorToSelectedTab",
    "layoutFillMode"
  ]);
  const platform3 = usePlatform();
  const { document: document2 } = useDOM();
  const isTabFlow = role === "tablist";
  const tabsRef = React171.useRef(null);
  const withGaps = mode === "accent" || mode === "secondary";
  const getTabEls = () => {
    if (!tabsRef.current) {
      return [];
    }
    return Array.from(
      // eslint-disable-next-line no-restricted-properties
      tabsRef.current.querySelectorAll("[role=tab]:not([disabled])")
    );
  };
  const handleDocumentKeydown = (event) => {
    if (!document2 || !tabsRef.current || !isTabFlow) {
      return;
    }
    const key = pressedKey(event);
    switch (key) {
      case "ArrowLeft":
      case "ArrowRight":
      case "End":
      case "Home": {
        const tabEls = getTabEls();
        const currentFocusedElIndex = tabEls.findIndex((el) => document2.activeElement === el);
        if (currentFocusedElIndex === -1) {
          return;
        }
        let nextIndex = 0;
        if (key === "Home") {
          nextIndex = 0;
        } else if (key === "End") {
          nextIndex = tabEls.length - 1;
        } else {
          const offset3 = key === "ArrowRight" ? 1 : -1;
          nextIndex = currentFocusedElIndex + offset3;
        }
        const nextTabEl = tabEls[nextIndex];
        if (nextTabEl) {
          event.preventDefault();
          nextTabEl.focus();
        }
        break;
      }
      case "ArrowDown": {
        const tabEls = getTabEls();
        const currentFocusedEl = tabEls.find((el) => document2.activeElement === el);
        if (!currentFocusedEl || currentFocusedEl.getAttribute("aria-selected") !== "true") {
          return;
        }
        const relatedContentElId = currentFocusedEl.getAttribute("aria-controls");
        if (!relatedContentElId) {
          return;
        }
        const relatedContentEl = document2.getElementById(relatedContentElId);
        if (!relatedContentEl) {
          return;
        }
        event.preventDefault();
        relatedContentEl.focus();
        break;
      }
      case "Space":
      case "Enter": {
        const tabEls = getTabEls();
        const currentFocusedEl = tabEls.find((el) => document2.activeElement === el);
        if (currentFocusedEl) {
          currentFocusedEl.click();
        }
      }
    }
  };
  useGlobalEventListener(document2, "keydown", handleDocumentKeydown, {
    capture: true
  });
  return React171.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiTabs", "vkuiInternalTabs", platform3 === "vkcom" && "vkuiInternalTabs--vkcom", withGaps && classNames("vkuiTabs--withGaps", "vkuiInternalTabs--withGaps"), mode === "default" && "vkuiTabs--mode-default"),
    role
  }), React171.createElement("div", {
    className: "vkuiTabs__in",
    ref: tabsRef
  }, React171.createElement(TabsModeContext.Provider, {
    value: {
      mode,
      withGaps,
      layoutFillMode,
      withScrollToSelectedTab,
      scrollBehaviorToSelectedTab
    }
  }, children)));
};

// node_modules/@vkontakte/vkui/dist/components/TabsItem/TabsItem.js
var React172 = __toESM(require_react());
var sizeYClassNames10 = {
  none: "vkuiTabsItem--sizeY-none",
  ["compact"]: "vkuiTabsItem--sizeY-compact"
};
var stylesMode6 = {
  default: "vkuiTabsItem--mode-default",
  accent: "vkuiTabsItem--mode-accent",
  secondary: "vkuiTabsItem--mode-secondary"
};
var fillModeClassNames = {
  stretched: "vkuiTabsItem--stretched",
  shrinked: "vkuiTabsItem--shrinked"
};
var warn17 = warnOnce("TabsItem");
var TabsItem = (_param) => {
  var { before, children, status, after, selected = false, className, role = "tab", tabIndex: tabIndexProp, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "before",
    "children",
    "status",
    "after",
    "selected",
    "className",
    "role",
    "tabIndex",
    "getRootRef"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const { mode, withGaps, layoutFillMode, scrollBehaviorToSelectedTab, withScrollToSelectedTab } = React172.useContext(TabsModeContext);
  let statusComponent = null;
  const isTabFlow = role === "tab";
  if (hasReactNode(status)) {
    statusComponent = typeof status === "number" ? React172.createElement(Subhead, {
      Component: "span",
      className: classNames("vkuiTabsItem__status", "vkuiTabsItem__status--count"),
      weight: "2"
    }, React172.createElement(VisuallyHidden, null, " "), status) : React172.createElement("span", {
      className: "vkuiTabsItem__status"
    }, React172.createElement(VisuallyHidden, null, " "), status);
  }
  if (isTabFlow) {
    if (!restProps["aria-controls"]) {
      warn17(`Передайте в "aria-controls" id контролируемого блока`, "warn");
    } else if (!restProps["id"]) {
      warn17(`Передайте "id" компоненту для использования в "aria-labelledby" контролируемого блока`, "warn");
    }
  }
  let tabIndex = tabIndexProp;
  if (isTabFlow && tabIndex === void 0) {
    tabIndex = selected ? 0 : -1;
  }
  const rootRef = useExternRef(getRootRef);
  const prevSelected = usePrevious(selected);
  const isInitialRender = prevSelected === void 0;
  const shouldScrollToSelected = withScrollToSelectedTab && !isInitialRender && prevSelected !== selected && selected;
  const { document: document2 } = useDOM();
  React172.useEffect(function scrollToSelectedItem() {
    if (!shouldScrollToSelected || !rootRef.current || !document2) {
      return;
    }
    const tabDOMRect = rootRef.current.getBoundingClientRect();
    const isTabVerticallyOutsideOfViewport = tabDOMRect.top < 0 || tabDOMRect.bottom > document2.documentElement.clientHeight;
    if (isTabVerticallyOutsideOfViewport) {
      return;
    }
    try {
      rootRef.current.scrollIntoView({
        inline: scrollBehaviorToSelectedTab,
        block: "nearest",
        behavior: "smooth"
      });
    } catch (e) {
    }
  }, [
    rootRef,
    document2,
    shouldScrollToSelected,
    scrollBehaviorToSelectedTab
  ]);
  return React172.createElement(Tappable, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: rootRef,
    className: classNames("vkuiTabsItem", mode && stylesMode6[mode], selected && "vkuiTabsItem--selected", sizeY !== "regular" && sizeYClassNames10[sizeY], withGaps && "vkuiTabsItem--withGaps", layoutFillMode !== "auto" && fillModeClassNames[layoutFillMode], className),
    hoverMode: "vkuiTabsItem--hover",
    activeMode: "",
    focusVisibleMode: "inside",
    hasActive: false,
    role,
    "aria-selected": selected,
    tabIndex
  }), before && React172.createElement("div", {
    className: "vkuiTabsItem__before"
  }, before), React172.createElement(Headline, {
    Component: "span",
    className: "vkuiTabsItem__label",
    level: mode === "default" ? "1" : "2",
    weight: "2"
  }, children), statusComponent, after && React172.createElement("div", {
    className: "vkuiTabsItem__after"
  }, after), mode === "default" && React172.createElement("div", {
    className: "vkuiTabsItem__underline",
    "aria-hidden": true,
    "data-selected": selected
  }));
};

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefresh.js
var React174 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefreshSpinner.js
var React173 = __toESM(require_react());
function calcStrokeDashOffset(value, radius) {
  const progress = value / 100;
  return 2 * Math.PI * radius * (1 - progress);
}
var PullToRefreshSpinner = (_param) => {
  var { on = true, size: size4 = 24, strokeWidth = 2.5, progress = 0, children = "Пожалуйста, подождите..." } = _param, restProps = _object_without_properties(_param, [
    "on",
    "size",
    "strokeWidth",
    "progress",
    "children"
  ]);
  const radius = 0.5 * size4 - 0.5 * strokeWidth;
  const dasharray = 2 * Math.PI * radius;
  const circleCenter = 0.5 * size4;
  const dashoffset = calcStrokeDashOffset(on ? 80 : progress, radius);
  return React173.createElement(RootComponent, _object_spread({
    baseClassName: classNames("vkuiPullToRefresh__spinner", on && "vkuiPullToRefresh__spinner--on")
  }, restProps), on && React173.createElement(VisuallyHidden, null, children), React173.createElement("svg", {
    role: "presentation",
    className: "vkuiPullToRefresh__spinner-self",
    style: {
      width: size4,
      height: size4
    },
    viewBox: `0 0 ${size4} ${size4}`,
    xmlns: "http://www.w3.org/2000/svg"
  }, React173.createElement("g", {
    style: {
      width: size4,
      height: size4,
      transformOrigin: `${circleCenter}px ${circleCenter}px`
    }
  }, React173.createElement("circle", {
    className: "vkuiPullToRefresh__spinner-path",
    fill: "none",
    strokeDasharray: dasharray,
    strokeDashoffset: dashoffset,
    strokeWidth,
    strokeLinecap: "round",
    cx: circleCenter,
    cy: circleCenter,
    r: radius
  }))));
};

// node_modules/@vkontakte/vkui/dist/components/PullToRefresh/PullToRefresh.js
var WAIT_FETCHING_TIMEOUT_MS = 1e3;
function cancelEvent(event) {
  if (!event) {
    return false;
  }
  if ("preventDefault" in event.originalEvent && event.originalEvent.cancelable) {
    event.originalEvent.preventDefault();
  }
  if ("stopPropagation" in event.originalEvent) {
    event.originalEvent.stopPropagation();
  }
  return false;
}
var PullToRefresh = (_param) => {
  var { children, isFetching, onRefresh, className } = _param, restProps = _object_without_properties(_param, [
    "children",
    "isFetching",
    "onRefresh",
    "className"
  ]);
  const platform3 = usePlatform();
  const scroll = useScroll();
  const { window: window2, document: document2 } = useDOM();
  const prevIsFetching = usePrevious(isFetching);
  const initParams = React174.useMemo(() => ({
    start: platform3 === "ios" ? -10 : -45,
    max: platform3 === "ios" ? 50 : 80,
    maxY: platform3 === "ios" ? 400 : 80,
    refreshing: platform3 === "ios" ? 36 : 50,
    positionMultiplier: platform3 === "ios" ? 0.21 : 1
  }), [
    platform3
  ]);
  const [spinnerY, setSpinnerY] = React174.useState(initParams.start);
  const [watching, setWatching] = React174.useState(false);
  const [refreshing, setRefreshing] = React174.useState(false);
  const [canRefresh, setCanRefresh] = React174.useState(false);
  const [touchDown, setTouchDown] = React174.useState(false);
  const prevTouchDown = usePrevious(touchDown);
  const touchY = React174.useRef(0);
  const [contentShift, setContentShift] = React174.useState(0);
  const [spinnerProgress, setSpinnerProgress] = React174.useState(0);
  const resetRefreshingState = React174.useCallback(() => {
    setWatching(false);
    setCanRefresh(false);
    setRefreshing(false);
    setSpinnerY(initParams.start);
    setSpinnerProgress(0);
    setContentShift(0);
  }, [
    initParams
  ]);
  const onRefreshingFinish = React174.useCallback(() => {
    if (!touchDown) {
      resetRefreshingState();
    }
  }, [
    touchDown,
    resetRefreshingState
  ]);
  const waitFetchingTimeoutId = React174.useRef();
  useIsomorphicLayoutEffect(() => {
    if (prevIsFetching !== void 0 && prevIsFetching && !isFetching) {
      onRefreshingFinish();
    }
  }, [
    prevIsFetching,
    isFetching,
    onRefreshingFinish
  ]);
  useIsomorphicLayoutEffect(() => {
    if (prevIsFetching !== void 0 && !prevIsFetching && isFetching) {
      clearTimeout(waitFetchingTimeoutId.current);
    }
  }, [
    isFetching,
    prevIsFetching
  ]);
  const runRefreshing = React174.useCallback(() => {
    if (!refreshing && onRefresh) {
      clearTimeout(waitFetchingTimeoutId.current);
      waitFetchingTimeoutId.current = setTimeout(onRefreshingFinish, WAIT_FETCHING_TIMEOUT_MS);
      setRefreshing(true);
      setSpinnerY((prevSpinnerY) => platform3 === "ios" ? prevSpinnerY : initParams.refreshing);
      onRefresh();
    }
  }, [
    refreshing,
    onRefresh,
    onRefreshingFinish,
    platform3,
    initParams.refreshing
  ]);
  useIsomorphicLayoutEffect(() => {
    if (prevTouchDown !== void 0 && prevTouchDown && !touchDown) {
      if (!refreshing && canRefresh) {
        runRefreshing();
      } else if (refreshing && !isFetching) {
        resetRefreshingState();
      } else {
        setSpinnerY(refreshing ? initParams.refreshing : initParams.start);
        setSpinnerProgress(0);
        setContentShift(0);
      }
    }
  }, [
    initParams,
    prevIsFetching,
    isFetching,
    onRefreshingFinish,
    prevTouchDown,
    touchDown,
    refreshing,
    canRefresh,
    runRefreshing
  ]);
  useIsomorphicLayoutEffect(function toggleBodyOverscrollBehavior() {
    if (!window2 || !document2) {
      return;
    }
    const handleWindowTouchMoveForPreventIOSViewportBounce = (event) => {
      event.preventDefault();
      event.stopPropagation();
    };
    if (watching || refreshing) {
      document2.documentElement.classList.add("vkui--disable-overscroll-behavior");
      window2.addEventListener("touchmove", handleWindowTouchMoveForPreventIOSViewportBounce, {
        passive: false
      });
    }
    return () => {
      document2.documentElement.classList.remove("vkui--disable-overscroll-behavior");
      window2.removeEventListener("touchmove", handleWindowTouchMoveForPreventIOSViewportBounce);
    };
  }, [
    window2,
    document2,
    watching,
    refreshing
  ]);
  const startYRef = React174.useRef(0);
  const onTouchStart = (event) => {
    if (refreshing) {
      cancelEvent(event);
      return;
    }
    setTouchDown(true);
    startYRef.current = event.startY;
  };
  const iosRefreshStartedRef = React174.useRef(false);
  const onTouchMove = (event) => {
    const { isY, shiftY } = event;
    const { start, max: max2 } = initParams;
    const pageYOffset = scroll === null || scroll === void 0 ? void 0 : scroll.getScroll().y;
    if (watching && touchDown) {
      cancelEvent(event);
      const { positionMultiplier, maxY } = initParams;
      const shift4 = Math.max(0, shiftY - touchY.current);
      const currentY = clamp2(start + shift4 * positionMultiplier, start, maxY);
      const progress = currentY > -10 ? Math.abs((currentY + 10) / max2) * 80 : 0;
      setSpinnerY(currentY);
      setSpinnerProgress(clamp2(progress, 0, 80));
      setCanRefresh(progress > 80);
      setContentShift((currentY + 10) * 2.3);
      const iosCanStartRefreshDuringGesture = platform3 === "ios" && progress > 85 && !refreshing && !iosRefreshStartedRef.current;
      if (iosCanStartRefreshDuringGesture) {
        iosRefreshStartedRef.current = true;
        runRefreshing();
      }
    } else if (isY && pageYOffset === 0 && shiftY > 0 && !refreshing && touchDown) {
      cancelEvent(event);
      touchY.current = shiftY;
      setWatching(true);
      setSpinnerY(start);
      setSpinnerProgress(0);
    }
  };
  const onTouchEnd = () => {
    setWatching(false);
    setTouchDown(false);
    iosRefreshStartedRef.current = false;
  };
  const spinnerTransform = `translate3d(0, ${spinnerY}px, 0)`;
  let contentTransform = "";
  if (platform3 === "ios" && refreshing && !touchDown) {
    contentTransform = "translate3d(0, 100px, 0)";
  } else if (platform3 === "ios" && (contentShift || refreshing)) {
    contentTransform = `translate3d(0, ${contentShift}px, 0)`;
  }
  return React174.createElement(TouchContext_default.Provider, {
    value: true
  }, React174.createElement(Touch, _object_spread_props(_object_spread({
    "aria-live": "polite",
    "aria-busy": !!isFetching
  }, restProps), {
    onStart: onTouchStart,
    onMove: onTouchMove,
    onEnd: onTouchEnd,
    className: classNames("vkuiPullToRefresh", platform3 === "ios" && "vkuiPullToRefresh--ios", watching && "vkuiPullToRefresh--watching", refreshing && "vkuiPullToRefresh--refreshing", className)
  }), React174.createElement(FixedLayout, {
    className: "vkuiPullToRefresh__controls",
    useParentWidth: true
  }, React174.createElement(PullToRefreshSpinner, {
    style: {
      transform: spinnerTransform,
      WebkitTransform: spinnerTransform,
      opacity: watching || refreshing || canRefresh ? 1 : 0
    },
    on: refreshing,
    progress: refreshing ? void 0 : spinnerProgress
  })), React174.createElement("div", {
    className: "vkuiPullToRefresh__content",
    style: {
      transform: contentTransform,
      WebkitTransform: contentTransform
    }
  }, children)));
};

// node_modules/@vkontakte/vkui/dist/components/Link/Link.js
var React175 = __toESM(require_react());
var Link = (_param) => {
  var { hasVisited, children, className, onClick = noop } = _param, restProps = _object_without_properties(_param, [
    "hasVisited",
    "children",
    "className",
    "onClick"
  ]);
  return React175.createElement(Tappable, _object_spread_props(_object_spread({
    Component: restProps.href ? "a" : "button",
    onClick
  }, restProps), {
    className: classNames("vkuiLink", hasVisited && "vkuiLink--has-visited", className),
    hasHover: false,
    activeMode: "opacity",
    focusVisibleMode: "outside"
  }), children);
};

// node_modules/@vkontakte/vkui/dist/components/OnboardingTooltip/OnboardingTooltip.js
var React176 = __toESM(require_react());
var warn18 = warnOnce("OnboardingTooltip");
var OnboardingTooltip = (_param) => {
  var { id: idProp, children, shown: shownProp = true, arrowPadding = DEFAULT_ARROW_PADDING, arrowHeight = DEFAULT_ARROW_HEIGHT, offsetByMainAxis = 0, offsetByCrossAxis = 0, arrowOffset = 0, isStaticArrowOffset = false, onClose, placement: placementProp = "bottom-start", maxWidth = TOOLTIP_MAX_WIDTH, style: styleProp, getRootRef, disableArrow = false, onPlacementChange } = _param, restProps = _object_without_properties(_param, [
    "id",
    "children",
    "shown",
    "arrowPadding",
    "arrowHeight",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "arrowOffset",
    "isStaticArrowOffset",
    "onClose",
    "placement",
    "maxWidth",
    "style",
    "getRootRef",
    "disableArrow",
    "onPlacementChange"
  ]);
  const generatedId = React176.useId();
  const tooltipId = idProp || generatedId;
  const { entering } = useNavTransition();
  const [arrowRef, setArrowRef] = React176.useState(null);
  const [tooltipContainer, setTooltipContainer] = React176.useState(null);
  const [positionStrategy, setPositionStrategy] = React176.useState("absolute");
  const shown = shownProp && tooltipContainer && !entering;
  const { middlewares, strictPlacement } = useFloatingMiddlewaresBootstrap({
    placement: placementProp,
    offsetByMainAxis,
    offsetByCrossAxis,
    arrowRef,
    arrow: !disableArrow,
    arrowHeight,
    arrowPadding
  });
  const { x: floatingDataX, y: floatingDataY, refs, placement: resolvedPlacement, middlewareData: { arrow: arrowCoords } } = useFloating({
    strategy: positionStrategy,
    placement: strictPlacement,
    middleware: middlewares,
    whileElementsMounted: autoUpdateFloatingElement
  });
  const tooltipRef = useExternRef(getRootRef, refs.setFloating);
  const [childRef, child] = usePatchChildren(children, {
    "aria-describedby": shown ? tooltipId : void 0
  });
  usePlacementChangeCallback(resolvedPlacement, onPlacementChange);
  let tooltip = null;
  if (shown) {
    const floatingStyle = convertFloatingDataToReactCSSProperties(positionStrategy, floatingDataX, floatingDataY);
    if (styleProp) {
      Object.assign(floatingStyle, styleProp);
    }
    tooltip = createPortal2(React176.createElement(React176.Fragment, null, React176.createElement(TooltipBase, _object_spread_props(_object_spread({}, restProps), {
      id: tooltipId,
      getRootRef: tooltipRef,
      style: floatingStyle,
      maxWidth,
      arrowProps: disableArrow ? void 0 : {
        offset: arrowOffset,
        isStaticOffset: isStaticArrowOffset,
        coords: arrowCoords,
        placement: resolvedPlacement,
        getRootRef: setArrowRef
      }
    })), React176.createElement("div", {
      className: "vkuiOnboardingTooltip__overlay",
      onClickCapture: onClose
    })), tooltipContainer);
  }
  useIsomorphicLayoutEffect(function initialize() {
    const referenceEl = childRef.current;
    if (referenceEl) {
      setTooltipContainer(referenceEl.closest(`[${onboardingTooltipContainerAttr}]`));
      setPositionStrategy(referenceEl.style.position === "fixed" ? "fixed" : "absolute");
      refs.setReference(referenceEl);
    }
  }, [
    childRef
  ]);
  if (true) {
    const multiChildren = React176.Children.count(children) > 1;
    const primitiveChild = hasReactNode(children) && typeof children !== "object";
    (multiChildren || primitiveChild) && warn18([
      "children должен быть одним React элементом, получено",
      multiChildren && "несколько",
      primitiveChild && JSON.stringify(children)
    ].filter(Boolean).join(" "), "error");
    if (refs.reference.current && !tooltipContainer) {
      throw new Error("Use TooltipContainer for Tooltip outside Panel (see docs)");
    }
  }
  return React176.createElement(React176.Fragment, null, child, tooltip);
};

// node_modules/@vkontakte/vkui/dist/components/Counter/Counter.js
var React177 = __toESM(require_react());
var modeClassNames = {
  secondary: "vkuiCounter--mode-secondary",
  primary: "vkuiCounter--mode-primary",
  prominent: "vkuiCounter--mode-prominent",
  contrast: "vkuiCounter--mode-contrast",
  inherit: "vkuiCounter--mode-inherit"
};
var sizeClassNames2 = {
  s: "vkuiCounter--size-s",
  m: "vkuiCounter--size-m"
};
var Counter = (_param) => {
  var { mode = "inherit", size: size4 = "m", children, className } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "size",
    "children",
    "className"
  ]);
  if (React177.Children.count(children) === 0) {
    return null;
  }
  const CounterTypography = size4 === "s" ? Caption : Headline;
  const counterLevel = size4 === "s" ? "1" : "2";
  return React177.createElement(CounterTypography, _object_spread_props(_object_spread({}, restProps), {
    Component: "span",
    className: classNames("vkuiInternalCounter", "vkuiCounter", modeClassNames[mode], sizeClassNames2[size4], className),
    level: counterLevel
  }), children);
};

// node_modules/@vkontakte/vkui/dist/components/UsersStack/UsersStack.js
var React178 = __toESM(require_react());
var stylesSize6 = {
  s: "vkuiUsersStack--size-s",
  m: "vkuiUsersStack--size-m",
  l: "vkuiUsersStack--size-l"
};
var stylesDirection2 = {
  "row": "vkuiUsersStack--direction-row",
  "row-reverse": "vkuiUsersStack--direction-row-reverse",
  "column": "vkuiUsersStack--direction-column"
};
function PathElement(_param) {
  var { photoSize, direction } = _param, props = _object_without_properties(_param, [
    "photoSize",
    "direction"
  ]);
  switch (direction) {
    case "circle":
      const radius = photoSize / 2;
      return React178.createElement("circle", _object_spread({
        cx: radius,
        cy: radius,
        r: radius
      }, props));
    case "right":
      switch (photoSize) {
        case 24:
          return React178.createElement("path", _object_spread({
            d: "M22,18.625A12 12 0 0 1 12 24A12 12 0 0 1 12 0A12 12 0 0 1 22 5.375A12 12 0 0 0 22,18.625"
          }, props));
        default:
          return React178.createElement("path", _object_spread({
            d: "M30,23.75A16 16 0 0 1 16 32A16 16 0 0 1 16 0A16 16 0 0 1 30 8.25A16 16 0 0 0 30,23.75"
          }, props));
      }
    default:
      switch (photoSize) {
        case 16:
          return React178.createElement("path", _object_spread({
            d: "M2,13.285A8 8 0 0 0 8 16A8 8 0 0 0 8 0A8 8 0 0 0 2 2.715A8 8 0 0 1 2,13.285"
          }, props));
        case 24:
          return React178.createElement("path", _object_spread({
            d: "M2,18.625A12 12 0 0 0 12 24A12 12 0 0 0 12 0A12 12 0 0 0 2 5.375A12 12 0 0 1 2,18.625"
          }, props));
        default:
          return React178.createElement("path", _object_spread({
            d: "M2,23.75A16 16 0 0 0 16 32A16 16 0 0 0 16 0A16 16 0 0 0 2 8.25A16 16 0 0 1 2,23.75"
          }, props));
      }
  }
}
var photoSizes = {
  s: 16,
  m: 24,
  l: 32
};
var UsersStack = (_param) => {
  var { photos = [], visibleCount = 3, count = Math.max(0, photos.length - visibleCount), size: size4 = "m", children, direction = "row" } = _param, restProps = _object_without_properties(_param, [
    "photos",
    "visibleCount",
    "count",
    "size",
    "children",
    "direction"
  ]);
  const cmpId = React178.useId();
  const canShowOthers = count > 0 && count < 100 && size4 !== "s";
  const CounterTypography = size4 === "l" ? Footnote : Caption;
  const photoSize = photoSizes[size4];
  const directionClip = canShowOthers ? "right" : "left";
  const photosElements = photos.slice(0, visibleCount).map((photo, i) => {
    const direction2 = i === 0 && !canShowOthers ? "circle" : directionClip;
    const id = `UsersStackDefs${cmpId}${i}`;
    const hrefID = `#${id}`;
    const maskID = `UsersStackMask${cmpId}${i}`;
    return React178.createElement("svg", {
      xmlns: "http://www.w3.org/2000/svg",
      className: "vkuiUsersStack__photo",
      key: i,
      "aria-hidden": true
    }, React178.createElement("defs", null, React178.createElement(PathElement, {
      id,
      direction: direction2,
      photoSize
    })), React178.createElement("clipPath", {
      id: maskID
    }, React178.createElement("use", {
      href: hrefID
    })), React178.createElement("g", {
      clipPath: `url(#${maskID})`
    }, React178.createElement("use", {
      href: hrefID,
      className: "vkuiUsersStack__fill"
    }), React178.createElement("image", {
      href: photo,
      width: photoSize,
      height: photoSize
    }), React178.createElement("use", {
      href: hrefID,
      fill: "none",
      stroke: "rgba(0, 0, 0, 0.08)"
    })));
  });
  const othersElement = canShowOthers ? React178.createElement(CounterTypography, {
    caps: true,
    weight: "1",
    className: classNames("vkuiUsersStack__photo", "vkuiUsersStack__photo--others")
  }, "+", count) : null;
  return React178.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiUsersStack", stylesSize6[size4], stylesDirection2[direction])
  }), (photosElements.length > 0 || othersElement) && React178.createElement("div", {
    className: "vkuiUsersStack__photos",
    "aria-hidden": true
  }, photosElements, othersElement), hasReactNode(children) && React178.createElement(Footnote, {
    className: "vkuiUsersStack__text"
  }, children));
};

// node_modules/@vkontakte/vkui/dist/components/Placeholder/Placeholder.js
var React179 = __toESM(require_react());
var PlaceholderContainer = (_param) => {
  var { stretched, noPadding = false } = _param, restProps = _object_without_properties(_param, [
    "stretched",
    "noPadding"
  ]);
  return React179.createElement(RootComponent, _object_spread({
    baseClassName: classNames("vkuiPlaceholder", stretched && "vkuiPlaceholder--stretched", !noPadding && "vkuiPlaceholder--withPadding")
  }, restProps));
};
var PlaceholderIcon = (props) => React179.createElement(RootComponent, _object_spread({
  baseClassName: "vkuiPlaceholder__icon"
}, props));
var PlaceholderHeader = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return React179.createElement(Title, _object_spread({
    level: "2",
    weight: "2",
    className: classNames(className, "vkuiPlaceholder__header")
  }, restProps));
};
var PlaceholderText = (_param) => {
  var { className } = _param, restProps = _object_without_properties(_param, [
    "className"
  ]);
  return React179.createElement(Headline, _object_spread({
    weight: "3",
    className: classNames(className, "vkuiPlaceholder__text")
  }, restProps));
};
var PlaceholderActions = (props) => React179.createElement(RootComponent, _object_spread({
  baseClassName: "vkuiPlaceholder__action"
}, props));
var Placeholder = (_param) => {
  var { icon, header, children, action, noPadding = false } = _param, restProps = _object_without_properties(_param, [
    "icon",
    "header",
    "children",
    "action",
    "noPadding"
  ]);
  return React179.createElement(PlaceholderContainer, _object_spread({
    noPadding
  }, restProps), hasReactNode(icon) && React179.createElement(PlaceholderIcon, null, icon), hasReactNode(header) && React179.createElement(PlaceholderHeader, null, header), hasReactNode(children) && React179.createElement(PlaceholderText, null, children), hasReactNode(action) && React179.createElement(PlaceholderActions, null, action));
};
Placeholder.Container = PlaceholderContainer;
Placeholder.Icon = PlaceholderIcon;
Placeholder.Header = PlaceholderHeader;
Placeholder.Text = PlaceholderText;
Placeholder.Actions = PlaceholderActions;

// node_modules/@vkontakte/vkui/dist/components/Banner/Banner.js
var React180 = __toESM(require_react());
var Banner = (_param) => {
  var { mode = "tint", imageTheme = "dark", size: size4 = "s", before, asideMode, header, subheader, text, children, background, actions, onDismiss, dismissLabel = "Скрыть" } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "imageTheme",
    "size",
    "before",
    "asideMode",
    "header",
    "subheader",
    "text",
    "children",
    "background",
    "actions",
    "onDismiss",
    "dismissLabel"
  ]);
  const platform3 = usePlatform();
  const HeaderTypography = size4 === "m" ? Title : Headline;
  const SubheaderTypography = size4 === "m" ? Text : Subhead;
  const IconDismissIOS = mode === "image" ? Icon24DismissDark : Icon24Dismiss;
  const content = React180.createElement(React180.Fragment, null, mode === "image" && background && React180.createElement("div", {
    "aria-hidden": true,
    className: "vkuiBanner__bg"
  }, background), before && React180.createElement("div", {
    className: "vkuiBanner__before"
  }, before), React180.createElement("div", {
    className: "vkuiBanner__content"
  }, hasReactNode(header) && React180.createElement(HeaderTypography, {
    Component: "div",
    weight: "2",
    level: size4 === "m" ? "2" : "1"
  }, header), hasReactNode(subheader) && React180.createElement(SubheaderTypography, {
    Component: "div",
    className: "vkuiBanner__subheader"
  }, subheader), hasReactNode(text) && React180.createElement(Text, {
    Component: "div",
    className: "vkuiBanner__text"
  }, text), hasReactNode(actions) && React180.Children.count(actions) > 0 && React180.createElement("div", {
    className: "vkuiBanner__actions"
  }, actions)));
  return React180.createElement(RootComponent, _object_spread_props(_object_spread({
    Component: "section"
  }, restProps), {
    baseClassName: classNames("vkuiBanner", platform3 === "ios" && "vkuiBanner--ios", mode === "image" && "vkuiBanner--mode-image", size4 === "m" && "vkuiBanner--size-m", mode === "image" && imageTheme === "dark" && "vkuiBanner--inverted")
  }), asideMode === "expand" ? React180.createElement(Tappable, {
    className: "vkuiBanner__in",
    activeMode: platform3 === "ios" ? "opacity" : "background",
    onClick: noop
  }, content, React180.createElement("div", {
    className: "vkuiBanner__aside"
  }, React180.createElement(Icon24Chevron, {
    className: "vkuiBanner__expand"
  }))) : React180.createElement("div", {
    className: "vkuiBanner__in"
  }, content, asideMode === "dismiss" && React180.createElement("div", {
    className: "vkuiBanner__aside"
  }, React180.createElement(IconButton, {
    label: dismissLabel,
    className: "vkuiBanner__dismiss",
    onClick: onDismiss,
    hoverMode: "opacity",
    hasActive: false
  }, platform3 === "ios" ? React180.createElement(IconDismissIOS, null) : React180.createElement(Icon24Cancel, null)))));
};

// node_modules/@vkontakte/vkui/dist/components/MiniInfoCell/MiniInfoCell.js
var React181 = __toESM(require_react());
var stylesMode7 = {
  add: "vkuiMiniInfoCell--mode-add",
  accent: "vkuiMiniInfoCell--mode-accent",
  more: "vkuiMiniInfoCell--mode-more"
};
var stylesTextWrap = {
  nowrap: "vkuiMiniInfoCell--textWrap-nowrap",
  full: "vkuiMiniInfoCell--textWrap-full",
  short: "vkuiMiniInfoCell--textWrap-short"
};
var MiniInfoCell = (_param) => {
  var { before, after, children, mode = "base", textWrap = "nowrap", expandable = false, className } = _param, restProps = _object_without_properties(_param, [
    "before",
    "after",
    "children",
    "mode",
    "textWrap",
    "expandable",
    "className"
  ]);
  const cellClasses = classNames("vkuiMiniInfoCell", stylesTextWrap[textWrap], mode !== "base" && stylesMode7[mode], className);
  const cellContent = React181.createElement(React181.Fragment, null, hasReactNode(before) && React181.createElement("span", {
    className: "vkuiMiniInfoCell__before"
  }, before), React181.createElement("div", {
    className: "vkuiMiniInfoCell__middle"
  }, React181.createElement(Paragraph, {
    className: "vkuiMiniInfoCell__content",
    weight: mode === "more" ? "2" : void 0
  }, children), expandable && React181.createElement(Icon16Chevron, null)), hasReactNode(after) && React181.createElement("span", {
    className: "vkuiMiniInfoCell__after"
  }, after));
  return restProps.onClick ? React181.createElement(Tappable, _object_spread_props(_object_spread({
    Component: "div",
    role: "button"
  }, restProps), {
    className: cellClasses
  }), cellContent) : React181.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: cellClasses
  }), cellContent);
};

// node_modules/@vkontakte/vkui/dist/components/WriteBar/WriteBar.js
var React182 = __toESM(require_react());
var WriteBarTypography = (props) => {
  const platform3 = usePlatform();
  if (platform3 === "ios") {
    return React182.createElement(Title, _object_spread_props(_object_spread({}, props), {
      level: "3",
      weight: "3"
    }));
  }
  return React182.createElement(Headline, props);
};
var WriteBar = (_param) => {
  var { className, style, before, inlineAfter, after, getRootRef, getRef, onHeightChange, shadow = false, onChange } = _param, restProps = _object_without_properties(_param, [
    "className",
    "style",
    "before",
    "inlineAfter",
    "after",
    "getRootRef",
    "getRef",
    "onHeightChange",
    "shadow",
    "onChange"
  ]);
  const platform3 = usePlatform();
  const textareaRef = useExternRef(getRef);
  const currentScrollHeight = React182.useRef();
  const resize = React182.useCallback(() => {
    const textareaEl = textareaRef.current;
    if (!textareaEl) {
      return;
    }
    if (textareaEl.offsetParent) {
      textareaEl.style.height = "";
      textareaEl.style.height = `${textareaEl.scrollHeight}px`;
      if (textareaEl.scrollHeight !== currentScrollHeight.current && onHeightChange) {
        onHeightChange();
        currentScrollHeight.current = textareaEl.scrollHeight;
      }
    }
  }, [
    onHeightChange,
    textareaRef
  ]);
  React182.useEffect(resize, [
    resize,
    platform3
  ]);
  return React182.createElement("div", {
    ref: getRootRef,
    className: classNames("vkuiWriteBar", platform3 === "ios" && "vkuiWriteBar--ios", shadow && "vkuiWriteBar--shadow", className),
    style
  }, React182.createElement("div", {
    className: "vkuiWriteBar__form"
  }, hasReactNode(before) && React182.createElement("div", {
    className: "vkuiWriteBar__before"
  }, before), React182.createElement("div", {
    className: "vkuiWriteBar__formIn"
  }, React182.createElement(WriteBarTypography, _object_spread_props(_object_spread({}, restProps), {
    Component: "textarea",
    className: "vkuiWriteBar__textarea",
    onChange: callMultiple(onChange, resize),
    getRootRef: textareaRef
  })), hasReactNode(inlineAfter) && React182.createElement("div", {
    className: "vkuiWriteBar__inlineAfter"
  }, inlineAfter)), hasReactNode(after) && React182.createElement("div", {
    className: "vkuiWriteBar__after"
  }, after)));
};

// node_modules/@vkontakte/vkui/dist/components/WriteBarIcon/WriteBarIcon.js
var React183 = __toESM(require_react());
var predefinedLabel = {
  attach: "Прикрепить файл",
  send: "Отправить",
  done: "Готово"
};
var warn19 = warnOnce("WriteBarIcon");
var WriteBarIcon = (_param) => {
  var { mode, children, count, className, label: labelProp } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "count",
    "className",
    "label"
  ]);
  const platform3 = usePlatform();
  let predefinedIcons;
  switch (mode) {
    case "attach":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon28AddCircleOutline : Icon24Attach,
        IconRegular: platform3 === "ios" ? Icon28AddCircleOutline : Icon28AttachOutline
      };
      break;
    case "send":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon48WritebarSend : Icon24Send,
        IconRegular: platform3 === "ios" ? Icon48WritebarSend : Icon28Send
      };
      break;
    case "done":
      predefinedIcons = {
        IconCompact: platform3 === "ios" ? Icon48WritebarDone : Icon24CheckCircleOutline,
        IconRegular: platform3 === "ios" ? Icon48WritebarDone : Icon28CheckCircleOutline
      };
      break;
    default:
      break;
  }
  const label = labelProp !== null && labelProp !== void 0 ? labelProp : mode && predefinedLabel[mode];
  if (true) {
    const isAccessible = hasAccessibleName(_object_spread({
      children: [
        children,
        label
      ]
    }, restProps));
    if (!isAccessible) {
      warn19(COMMON_WARNINGS.a11y["button-name"], "error");
    }
  }
  return React183.createElement(Tappable, _object_spread_props(_object_spread({}, restProps), {
    Component: "button",
    hasHover: false,
    activeMode: "vkuiWriteBarIcon__active",
    className: classNames("vkuiWriteBarIcon", platform3 === "ios" && "vkuiWriteBarIcon--ios", mode === "send" && "vkuiWriteBarIcon--mode-send", mode === "done" && "vkuiWriteBarIcon--mode-done", className)
  }), React183.createElement("span", {
    className: "vkuiWriteBarIcon__in"
  }, label && React183.createElement(VisuallyHidden, null, label), predefinedIcons ? React183.createElement(AdaptiveIconRenderer, predefinedIcons) : children), hasReactNode(count) && React183.createElement(Counter, {
    className: "vkuiWriteBarIcon__counter",
    size: "s"
  }, count));
};

// node_modules/@vkontakte/vkui/dist/components/SubnavigationBar/SubnavigationBar.js
var React184 = __toESM(require_react());
var defaultScrollToLeft = (x) => x - 240;
var defaultScrollToRight = (x) => x + 240;
var SubnavigationBar = (_param) => {
  var { mode = "overflow", children, showArrows = true, getScrollToLeft = defaultScrollToLeft, getScrollToRight = defaultScrollToRight, scrollAnimationDuration } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "showArrows",
    "getScrollToLeft",
    "getScrollToRight",
    "scrollAnimationDuration"
  ]);
  let ScrollWrapper;
  let scrollWrapperProps = {};
  if (mode === "fixed") {
    ScrollWrapper = "div";
  } else {
    ScrollWrapper = HorizontalScroll;
    scrollWrapperProps = {
      showArrows,
      getScrollToLeft,
      getScrollToRight,
      scrollAnimationDuration
    };
  }
  return React184.createElement(RootComponent, _object_spread({
    baseClassName: mode === "fixed" && "vkuiSubnavigationBar--mode-fixed"
  }, restProps), React184.createElement(ScrollWrapper, _object_spread({
    className: "vkuiSubnavigationBar__in"
  }, scrollWrapperProps), React184.createElement("ul", {
    className: "vkuiSubnavigationBar__scrollIn"
  }, React184.Children.map(children, (child, idx) => hasReactNode(child) ? React184.createElement("li", {
    key: idx,
    className: "vkuiSubnavigationBar__item"
  }, child) : null))));
};

// node_modules/@vkontakte/vkui/dist/components/SubnavigationButton/SubnavigationButton.js
var React185 = __toESM(require_react());
var appearanceStyles = {
  accent: "vkuiSubnavigationButton--appearance-accent",
  neutral: "vkuiSubnavigationButton--appearance-neutral"
};
var modeStyles = {
  primary: "vkuiSubnavigationButton--mode-primary",
  outline: "vkuiSubnavigationButton--mode-outline",
  tertiary: "vkuiSubnavigationButton--mode-tertiary"
};
var sizeStyles = {
  s: "vkuiSubnavigationButton--size-s",
  m: "vkuiSubnavigationButton--size-m",
  l: "vkuiSubnavigationButton--size-l"
};
var sizeYClassNames11 = {
  none: "vkuiSubnavigationButton--sizeY-none",
  ["compact"]: "vkuiSubnavigationButton--sizeY-compact"
};
var SubnavigationButtonTypography = (_param) => {
  var { textLevel } = _param, restProps = _object_without_properties(_param, [
    "textLevel"
  ]);
  if (textLevel === "1") {
    return React185.createElement(Subhead, restProps);
  }
  return React185.createElement(Caption, _object_spread({
    level: textLevel === "2" ? "1" : "2"
  }, restProps));
};
var SubnavigationButton = (_param) => {
  var { mode = "primary", appearance = "accent", size: size4 = "m", selected, textLevel = "1", before, after, expandable, children, className } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "appearance",
    "size",
    "selected",
    "textLevel",
    "before",
    "after",
    "expandable",
    "children",
    "className"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return React185.createElement(Tappable, _object_spread_props(_object_spread({}, restProps), {
    hasActive: false,
    focusVisibleMode: "outside",
    className: classNames("vkuiSubnavigationButton", sizeStyles[size4], modeStyles[mode], appearanceStyles[appearance], selected && "vkuiSubnavigationButton--selected", sizeY !== "regular" && sizeYClassNames11[sizeY], className)
  }), React185.createElement("span", {
    className: "vkuiSubnavigationButton__in"
  }, before && React185.createElement("span", {
    className: "vkuiSubnavigationButton__before"
  }, before), React185.createElement(SubnavigationButtonTypography, {
    textLevel,
    className: "vkuiSubnavigationButton__label",
    Component: "span"
  }, children), after && React185.createElement("span", {
    className: "vkuiSubnavigationButton__after"
  }, after), expandable && React185.createElement(Icon16Dropdown, {
    className: "vkuiSubnavigationButton__expandableIcon"
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/Pagination.js
var React189 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/usePagination.js
var React186 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/helpers/range.js
function range(from, to, step = 1) {
  const direction = from < to ? 1 : -1;
  const distance = Math.abs(from - to) + 1;
  const arrayLength = Math.ceil(distance / step);
  const arr = Array(arrayLength);
  for (let index2 = 0; index2 < arr.length; index2++) {
    arr[index2] = from + index2 * step * direction;
  }
  return arr;
}
function rangeIncrement(from, to, step = 1) {
  if (from > to) {
    return [];
  }
  return range(from, to, step);
}

// node_modules/@vkontakte/vkui/dist/hooks/usePagination.js
var usePagination = ({ currentPage = 1, siblingCount = 1, boundaryCount = 1, totalPages: endPage = 1 } = {}) => React186.useMemo(() => {
  const startPages = rangeIncrement(1, Math.min(boundaryCount, endPage));
  const endPages = rangeIncrement(Math.max(endPage - boundaryCount + 1, boundaryCount + 1), endPage);
  const lowerBoundaryWhenCurrentPageHigh = endPage - boundaryCount - 1 - 2 * siblingCount;
  const siblingsStart = clamp2(currentPage - siblingCount, boundaryCount + 2, lowerBoundaryWhenCurrentPageHigh);
  const upperBoundaryWhenCurrentPageLow = boundaryCount + 2 + 2 * siblingCount;
  const siblingsEnd = Math.min(Math.max(currentPage + siblingCount, upperBoundaryWhenCurrentPageLow), endPages.length > 0 ? endPages[0] - 2 : endPage - 1);
  const pages = startPages;
  if (siblingsStart > boundaryCount + 2) {
    pages.push("start-ellipsis");
  } else if (boundaryCount + 1 < endPage - boundaryCount) {
    pages.push(boundaryCount + 1);
  }
  pages.push(...rangeIncrement(siblingsStart, siblingsEnd));
  if (siblingsEnd < endPage - boundaryCount - 1) {
    pages.push("end-ellipsis");
  } else if (endPage - boundaryCount > boundaryCount) {
    pages.push(endPage - boundaryCount);
  }
  pages.push(...endPages);
  return pages;
}, [
  currentPage,
  endPage,
  siblingCount,
  boundaryCount
]);

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageButton.js
var React187 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Pagination/utils.js
function getPageLabelDefault(isCurrent) {
  return isCurrent ? `Cтраница` : `Перейти на страницу`;
}

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/usePaginationPageClasses.js
function usePaginationPageClassNames({ isCurrent, disabled }) {
  const { sizeY = "none" } = useAdaptivity();
  return classNames("vkuiPaginationPage", sizeY === "none" && "vkuiPaginationPage--sizeY-none", sizeY === "compact" && "vkuiPaginationPage--sizeY-compact", isCurrent && "vkuiPaginationPage--current", disabled && "vkuiPaginationPage--disabled");
}

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageButton.js
var PaginationPageButton = (_param) => {
  var { isCurrent = false, getPageLabel = getPageLabelDefault, children, className, disabled } = _param, restProps = _object_without_properties(_param, [
    "isCurrent",
    "getPageLabel",
    "children",
    "className",
    "disabled"
  ]);
  const paginationClassNames = usePaginationPageClassNames({
    isCurrent,
    disabled
  });
  return React187.createElement(Tappable, _object_spread({
    className: classNames(paginationClassNames, className),
    activeMode: "vkuiPaginationPage--state-active",
    hoverMode: "vkuiPaginationPage--state-hover",
    focusVisibleMode: "outside",
    "data-page": children,
    "aria-current": isCurrent ? true : void 0,
    disabled
  }, restProps), React187.createElement(Text, {
    normalize: false
  }, React187.createElement(VisuallyHidden, null, getPageLabel(isCurrent), " "), children));
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/PaginationPage/PaginationPageEllipsis.js
var React188 = __toESM(require_react());
var PaginationPageEllipsis = (_param) => {
  var { className, disabled } = _param, restProps = _object_without_properties(_param, [
    "className",
    "disabled"
  ]);
  const paginationClassNames = usePaginationPageClassNames({
    isCurrent: false,
    disabled
  });
  return React188.createElement(Text, _object_spread({
    className: classNames(paginationClassNames, "vkuiPaginationPage--type-ellipsis", className)
  }, restProps), "…");
};

// node_modules/@vkontakte/vkui/dist/components/Pagination/Pagination.js
var Pagination = (_param) => {
  var { currentPage = 1, siblingCount = 1, boundaryCount = 1, totalPages = 1, disabled, getPageLabel = getPageLabelDefault, navigationLabel = "Навигация по страницам", navigationLabelComponent = "h2", prevButtonLabel = "Перейти на предыдущую страницу", nextButtonLabel = "Перейти на следующую страницу", onChange } = _param, resetProps2 = _object_without_properties(_param, [
    "currentPage",
    "siblingCount",
    "boundaryCount",
    "totalPages",
    "disabled",
    "getPageLabel",
    "navigationLabel",
    "navigationLabelComponent",
    "prevButtonLabel",
    "nextButtonLabel",
    "onChange"
  ]);
  const pages = usePagination({
    currentPage,
    totalPages,
    siblingCount,
    boundaryCount
  });
  const isFirstPage = currentPage === 1;
  const isLastPage = currentPage === totalPages;
  const handlePrevClick = React189.useCallback(() => {
    if (onChange && !isFirstPage) {
      onChange(currentPage - 1);
    }
  }, [
    currentPage,
    isFirstPage,
    onChange
  ]);
  const handleClick = React189.useCallback((event) => {
    const page = event.currentTarget.dataset.page || "1";
    onChange === null || onChange === void 0 ? void 0 : onChange(Number(page));
  }, [
    onChange
  ]);
  const handleNextClick = React189.useCallback(() => {
    if (onChange && !isLastPage) {
      onChange(currentPage + 1);
    }
  }, [
    currentPage,
    isLastPage,
    onChange
  ]);
  const renderPages = React189.useCallback((page) => {
    switch (page) {
      case "start-ellipsis":
      case "end-ellipsis":
        return React189.createElement("li", {
          key: page
        }, React189.createElement(PaginationPageEllipsis, {
          disabled
        }));
      default: {
        const isCurrent = page === currentPage;
        return React189.createElement("li", {
          key: page
        }, React189.createElement(PaginationPageButton, {
          getPageLabel,
          isCurrent,
          onClick: handleClick,
          disabled
        }, page));
      }
    }
  }, [
    currentPage,
    disabled,
    getPageLabel,
    handleClick
  ]);
  return React189.createElement(RootComponent, _object_spread({
    Component: "nav",
    role: "navigation"
  }, resetProps2), React189.createElement(VisuallyHidden, {
    Component: navigationLabelComponent
  }, navigationLabel), React189.createElement("ul", {
    className: "vkuiPagination__list"
  }, React189.createElement("li", {
    className: "vkuiPagination__prevButtonContainer"
  }, React189.createElement(Button, {
    size: "l",
    before: React189.createElement(React189.Fragment, null, React189.createElement(VisuallyHidden, null, prevButtonLabel), " ", React189.createElement(Icon24ChevronCompactLeft, {
      width: 24
    })),
    appearance: "accent",
    mode: "tertiary",
    disabled: isFirstPage || disabled,
    onClick: handlePrevClick
  })), pages.map(renderPages), React189.createElement("li", {
    className: "vkuiPagination__nextButtonContainer"
  }, React189.createElement(Button, {
    size: "l",
    after: React189.createElement(React189.Fragment, null, React189.createElement(VisuallyHidden, null, nextButtonLabel), React189.createElement(Icon24ChevronCompactRight, {
      width: 24
    })),
    appearance: "accent",
    mode: "tertiary",
    disabled: isLastPage || disabled,
    onClick: handleNextClick
  }))));
};

// node_modules/@vkontakte/vkui/dist/components/Accordion/Accordion.js
var React193 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContent.js
var React191 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContext.js
var React190 = __toESM(require_react());
var AccordionContext = React190.createContext({
  labelId: "",
  contentId: "",
  expanded: false,
  onChange: noop
});

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionContent.js
function calcMaxHeight(expanded, el) {
  if (!expanded) {
    return "0px";
  }
  if (el === null) {
    return "inherit";
  }
  return `${el.scrollHeight}px`;
}
function useResizeContent(expanded, inRef) {
  const resize = () => {
    inRef.current.style.maxHeight = calcMaxHeight(expanded, inRef.current);
  };
  const { window: window2 } = useDOM();
  useGlobalEventListener(window2, "resize", resize);
  useIsomorphicLayoutEffect(resize, []);
}
function useAccordionContent(expanded, inRef) {
  const maxHeight = calcMaxHeight(expanded, inRef.current);
  useResizeContent(expanded, inRef);
  return {
    maxHeight
  };
}
var AccordionContent = (_param) => {
  var { getRootRef, getRef, className, children } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "getRef",
    "className",
    "children"
  ]);
  const inRef = useExternRef(getRef);
  const { expanded, labelId, contentId } = React191.useContext(AccordionContext);
  const inStyle = useAccordionContent(expanded, inRef);
  return React191.createElement("div", _object_spread({
    ref: getRootRef,
    id: contentId,
    role: "region",
    "aria-labelledby": labelId,
    "aria-hidden": !expanded,
    className: classNames("vkuiAccordionContent", className)
  }, restProps), React191.createElement("div", {
    ref: inRef,
    className: "vkuiAccordionContent__in",
    style: inStyle
  }, children));
};

// node_modules/@vkontakte/vkui/dist/components/Accordion/AccordionSummary.js
var React192 = __toESM(require_react());
var AccordionSummary = (_param) => {
  var { after, before, ExpandIcon = Icon24ChevronDown, CollapseIcon = Icon24ChevronUp, iconPosition = "after", onClick, children } = _param, restProps = _object_without_properties(_param, [
    "after",
    "before",
    "ExpandIcon",
    "CollapseIcon",
    "iconPosition",
    "onClick",
    "children"
  ]);
  const { expanded, labelId, contentId, onChange } = React192.useContext(AccordionContext);
  const Icon = expanded ? CollapseIcon : ExpandIcon;
  const icon = (
    // Обертка нужна для правильной работы с отступами в SimpleCell
    React192.createElement("span", {
      className: "vkuiIcon"
    }, React192.createElement(Icon, {
      className: "vkuiAccordionSummary__icon"
    }))
  );
  const toggle = () => onChange(!expanded);
  return React192.createElement(SimpleCell, _object_spread({
    id: labelId,
    "aria-expanded": expanded,
    "aria-controls": contentId,
    onClick: callMultiple(toggle, onClick),
    before: React192.createElement(React192.Fragment, null, iconPosition === "before" && icon, before),
    after: React192.createElement(React192.Fragment, null, after, iconPosition === "after" && icon)
  }, restProps), children);
};

// node_modules/@vkontakte/vkui/dist/components/Accordion/Accordion.js
function useAccordionId(id) {
  const generatedId = React193.useId();
  const labelId = id !== null && id !== void 0 ? id : `Accordion${generatedId}`;
  const contentId = `AccordionContent${id !== null && id !== void 0 ? id : generatedId}`;
  return {
    labelId,
    contentId
  };
}
var Accordion = (_param) => {
  var { id, expanded: expandedProp, defaultExpanded = false, onChange: onChangeProp, children } = _param, restProps = _object_without_properties(_param, [
    "id",
    "expanded",
    "defaultExpanded",
    "onChange",
    "children"
  ]);
  const { labelId, contentId } = useAccordionId(id);
  const [expanded, onChange] = useCustomEnsuredControl({
    value: expandedProp,
    defaultValue: defaultExpanded,
    onChange: onChangeProp,
    disabled: restProps.disabled
  });
  const context = useObjectMemo({
    labelId,
    contentId,
    expanded: expanded || false,
    onChange
  });
  return React193.createElement(AccordionContext.Provider, {
    value: context
  }, children);
};
Accordion.Summary = AccordionSummary;
Accordion.Content = AccordionContent;

// node_modules/@vkontakte/vkui/dist/components/FormItem/FormItem.js
var React194 = __toESM(require_react());
var sizeYClassNames12 = {
  none: classNames("vkuiFormItem--sizeY-none", "vkuiInternalFormItem--sizeY-none"),
  ["compact"]: classNames("vkuiFormItem--sizeY-compact", "vkuiInternalFormItem--sizeY-compact")
};
var stylesStatus = {
  error: classNames("vkuiFormItem--status-error", "vkuiInternalFormItem--status-error"),
  valid: classNames("vkuiFormItem--status-valid", "vkuiInternalFormItem--status-valid")
};
var FormItem = (_param) => {
  var { children, top, topComponent: topComponentProp, bottom, status = "default", removable, onRemove = noop, removePlaceholder = "Удалить", getRootRef, htmlFor, bottomId, noPadding } = _param, restProps = _object_without_properties(_param, [
    "children",
    "top",
    "topComponent",
    "bottom",
    "status",
    "removable",
    "onRemove",
    "removePlaceholder",
    "getRootRef",
    "htmlFor",
    "bottomId",
    "noPadding"
  ]);
  const rootEl = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const topComponent = topComponentProp || htmlFor && "label" || "span";
  const wrappedChildren = React194.createElement(React194.Fragment, null, hasReactNode(top) && React194.createElement(Subhead, {
    className: "vkuiFormItem__top",
    Component: topComponent,
    htmlFor
  }, top), children, hasReactNode(bottom) && React194.createElement(Footnote, {
    className: "vkuiFormItem__bottom",
    id: bottomId,
    role: status === "error" ? "alert" : void 0
  }, bottom));
  return React194.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    getRootRef: rootEl,
    baseClassName: classNames("vkuiFormItem", !noPadding && "vkuiFormItem--withPadding", "vkuiInternalFormItem", status !== "default" && stylesStatus[status], sizeY !== "regular" && sizeYClassNames12[sizeY], hasReactNode(top) && classNames("vkuiFormItem--withTop", "vkuiInternalFormItem--withTop"), removable && classNames("vkuiFormItem--removable", "vkuiInternalFormItem--removable"))
  }), removable ? React194.createElement(Removable, {
    align: "start",
    onRemove: (e) => {
      if (rootEl === null || rootEl === void 0 ? void 0 : rootEl.current) {
        onRemove(e, rootEl.current);
      }
    },
    removePlaceholder,
    indent: removable === "indent"
  }, React194.createElement("div", {
    className: classNames("vkuiFormItem__removable", "vkuiInternalFormItem__removable")
  }, wrappedChildren)) : wrappedChildren);
};

// node_modules/@vkontakte/vkui/dist/components/FormField/FormField.js
var React196 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useFocusWithin.js
var React195 = __toESM(require_react());
var isFocusWithin = (ref, document2) => ref.contains(document2.activeElement);
function useFocusWithin(ref) {
  const { document: document2 } = useDOM();
  const [focusWithin, setFocusWithin] = React195.useState(() => ref.current && document2 ? isFocusWithin(ref.current, document2) : false);
  useIsomorphicLayoutEffect(function handleAutoFocus() {
    if (!document2) {
      return;
    }
    const handleFocusOrBlurEvents = () => {
      if (ref.current) {
        setFocusWithin(isFocusWithin(ref.current, document2));
      }
    };
    void handleFocusOrBlurEvents();
    document2.addEventListener("focus", handleFocusOrBlurEvents, {
      capture: true
    });
    document2.addEventListener("blur", handleFocusOrBlurEvents, {
      capture: true
    });
    return () => {
      document2.removeEventListener("focus", handleFocusOrBlurEvents, {
        capture: true
      });
      document2.removeEventListener("blur", handleFocusOrBlurEvents, {
        capture: true
      });
    };
  }, []);
  return focusWithin;
}

// node_modules/@vkontakte/vkui/dist/components/FormField/FormField.js
var sizeYClassNames13 = {
  none: "vkuiFormField--sizeY-none",
  ["compact"]: "vkuiFormField--sizeY-compact"
};
var stylesStatus2 = {
  error: "vkuiFormField--status-error",
  valid: "vkuiFormField--status-valid"
};
var FormField = (_param) => {
  var { Component: Component3 = "span", status = "default", children, getRootRef, before, after, disabled, mode = "default", className } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "status",
    "children",
    "getRootRef",
    "before",
    "after",
    "disabled",
    "mode",
    "className"
  ]);
  const elRef = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const [hover, setHover] = React196.useState(false);
  const focusWithin = useFocusWithin(elRef);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible: focusWithin,
    mode: "vkuiFormField--focus-visible"
  });
  const handleMouseEnter = (e) => {
    e.stopPropagation();
    setHover(true);
  };
  const handleMouseLeave = (e) => {
    e.stopPropagation();
    setHover(false);
  };
  return React196.createElement(Component3, _object_spread_props(_object_spread({}, restProps), {
    ref: elRef,
    onMouseEnter: handleMouseEnter,
    onMouseLeave: handleMouseLeave,
    className: classNames("vkuiFormField", mode === "default" && "vkuiFormField--mode-default", status !== "default" && stylesStatus2[status], sizeY !== "regular" && sizeYClassNames13[sizeY], disabled && "vkuiFormField--disabled", !disabled && hover && "vkuiFormField--hover", focusVisibleClassNames, className)
  }), before && React196.createElement("span", {
    className: "vkuiFormField__before"
  }, before), children, after && React196.createElement("span", {
    className: classNames("vkuiFormField__after", "vkuiInternalFormField__after")
  }, after), React196.createElement("span", {
    "aria-hidden": true,
    className: "vkuiFormField__border"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/FormLayoutGroup/FormLayoutGroup.js
var React197 = __toESM(require_react());
var sizeYClassNames14 = {
  none: classNames("vkuiFormLayoutGroup--sizeY-none", "vkuiInternalFormLayoutGroup--sizeY-none"),
  ["compact"]: classNames("vkuiFormLayoutGroup--sizeY-compact", "vkuiInternalFormLayoutGroup--sizeY-compact")
};
var FormLayoutGroup = (_param) => {
  var { children, mode = "vertical", removable, segmented, removePlaceholder = "Удалить", onRemove = noop, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "children",
    "mode",
    "removable",
    "segmented",
    "removePlaceholder",
    "onRemove",
    "getRootRef"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const isRemovable = removable && mode === "horizontal";
  const rootEl = useExternRef(getRootRef);
  return React197.createElement(RootComponent, _object_spread({
    getRootRef: rootEl,
    baseClassName: classNames(sizeY !== "regular" && sizeYClassNames14[sizeY], mode === "horizontal" && classNames("vkuiFormLayoutGroup--mode-horizontal", "vkuiInternalFormLayoutGroup--mode-horizontal"), mode === "vertical" && classNames("vkuiFormLayoutGroup--mode-vertical", "vkuiInternalFormLayoutGroup--mode-vertical"), isRemovable && classNames("vkuiFormLayoutGroup--removable", "vkuiInternalFormLayoutGroup--removable"), segmented && classNames("vkuiFormLayoutGroup--segmented", "vkuiInternalFormLayoutGroup--segmented"))
  }, restProps), isRemovable ? React197.createElement(Removable, {
    className: "vkuiFormLayoutGroup__removable",
    align: "start",
    removePlaceholder,
    onRemove: (e) => {
      if (rootEl === null || rootEl === void 0 ? void 0 : rootEl.current) {
        onRemove(e, rootEl.current);
      }
    },
    indent: removable === "indent"
  }, children) : React197.createElement(React197.Fragment, null, children, React197.createElement("span", {
    className: "vkuiFormLayoutGroup__offset",
    "aria-hidden": true
  })));
};

// node_modules/@vkontakte/vkui/dist/components/FormStatus/FormStatus.js
var React198 = __toESM(require_react());
var FormStatus = (_param) => {
  var { mode, children, className, role = mode === "error" ? "alert" : "status" } = _param, restProps = _object_without_properties(_param, [
    "mode",
    "children",
    "className",
    "role"
  ]);
  return React198.createElement(Banner, _object_spread_props(_object_spread({}, restProps), {
    role,
    subheader: children,
    className: classNames("vkuiInternalFormStatus", mode === "error" && classNames("vkuiFormStatus--mode-error", "vkuiInternalFormStatus--mode-error"), className)
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Switch/Switch.js
var React199 = __toESM(require_react());
var sizeYClassNames15 = {
  none: "vkuiSwitch--sizeY-none",
  ["compact"]: "vkuiSwitch--sizeY-compact"
};
var Switch = (_param) => {
  var { style, className, getRootRef, getRef, checked: checkedProp } = _param, restProps = _object_without_properties(_param, [
    "style",
    "className",
    "getRootRef",
    "getRef",
    "checked"
  ]);
  const platform3 = usePlatform();
  const { sizeY = "none" } = useAdaptivity();
  const { focusVisible, onBlur, onFocus } = useFocusVisible();
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: "outside"
  });
  const [localUncontrolledChecked, setLocalUncontrolledChecked] = React199.useState(Boolean(restProps.defaultChecked));
  const isControlled = checkedProp !== void 0;
  const syncUncontrolledCheckedStateOnClick = React199.useCallback((e) => {
    if (isControlled) {
      return;
    }
    const switchTarget = e.target;
    setLocalUncontrolledChecked(switchTarget.checked);
  }, [
    isControlled
  ]);
  const ariaCheckedState = isControlled ? checkedProp : localUncontrolledChecked;
  return React199.createElement("label", {
    className: classNames("vkuiSwitch", platform3 === "ios" && "vkuiSwitch--ios", sizeY !== "regular" && sizeYClassNames15[sizeY], restProps.disabled && "vkuiSwitch--disabled", focusVisibleClassNames, className),
    style,
    ref: getRootRef,
    onBlur: callMultiple(onBlur, restProps.onBlur),
    onFocus: callMultiple(onFocus, restProps.onFocus)
  }, React199.createElement(VisuallyHidden, _object_spread_props(_object_spread({}, restProps, isControlled && {
    checked: checkedProp
  }), {
    Component: "input",
    getRootRef: getRef,
    onClick: callMultiple(syncUncontrolledCheckedStateOnClick, restProps.onClick),
    type: "checkbox",
    role: "switch",
    "aria-checked": ariaCheckedState ? "true" : "false",
    className: "vkuiSwitch__self"
  })), React199.createElement("span", {
    "aria-hidden": true,
    className: "vkuiSwitch__pseudo"
  }));
};

// node_modules/@vkontakte/vkui/dist/components/File/File.js
var React200 = __toESM(require_react());
var File = (_param) => {
  var { children = "Выберите файл", align = "left", size: size4, mode, stretched, before, after, loading, className, style, getRef, getRootRef, appearance } = _param, restProps = _object_without_properties(_param, [
    "children",
    "align",
    "size",
    "mode",
    "stretched",
    "before",
    "after",
    "loading",
    "className",
    "style",
    "getRef",
    "getRootRef",
    "appearance"
  ]);
  return React200.createElement(Button, {
    Component: "label",
    align,
    className,
    stretched,
    mode,
    appearance,
    size: size4,
    before,
    after,
    loading,
    style,
    getRootRef,
    disabled: restProps.disabled
  }, React200.createElement(VisuallyHidden, _object_spread_props(_object_spread({
    title: ""
  }, restProps), {
    Component: "input",
    type: "file",
    getRootRef: getRef
  })), children);
};

// node_modules/@vkontakte/vkui/dist/components/Input/Input.js
var React201 = __toESM(require_react());
var sizeYClassNames16 = {
  none: "vkuiInput--sizeY-none",
  ["compact"]: "vkuiInput--sizeY-compact"
};
var Input = (_param) => {
  var { type = "text", align = "left", getRef, className, getRootRef, style, before, after, status, mode } = _param, restProps = _object_without_properties(_param, [
    "type",
    "align",
    "getRef",
    "className",
    "getRootRef",
    "style",
    "before",
    "after",
    "status",
    "mode"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  return React201.createElement(FormField, {
    style,
    className: classNames("vkuiInput", align === "right" && "vkuiInput--align-right", align === "center" && "vkuiInput--align-center", sizeY !== "regular" && sizeYClassNames16[sizeY], before && "vkuiInput--hasBefore", after && "vkuiInput--hasAfter", className),
    getRootRef,
    before,
    after,
    disabled: restProps.disabled,
    mode,
    status
  }, React201.createElement(Text, _object_spread_props(_object_spread({}, restProps), {
    Component: "input",
    normalize: false,
    type,
    className: "vkuiInput__el",
    getRootRef: getRef
  })));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/Chip/Chip.js
var React202 = __toESM(require_react());
var sizeYClassNames17 = {
  none: "vkuiChip--sizeY-none",
  compact: "vkuiChip--sizeY-compact"
};
var Chip = (_param) => {
  var { Component: Component3 = "span", value = "", removable = true, onRemove = noop, removeLabel = "Удалить", before, after, disabled, readOnly, children, className, onFocus: onFocusProp, onBlur: onBlurProp } = _param, restProps = _object_without_properties(_param, [
    "Component",
    "value",
    "removable",
    "onRemove",
    "removeLabel",
    "before",
    "after",
    "disabled",
    "readOnly",
    "children",
    "className",
    "onFocus",
    "onBlur"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const { focusVisible, onFocus, onBlur } = useFocusVisible();
  const focusVisibleClassName = useFocusVisibleClassName({
    focusVisible
  });
  const handleFocus = (event) => {
    if (onFocusProp) {
      onFocusProp(event);
    }
    onFocus(event);
  };
  const handleBlur = (event) => {
    if (onBlurProp) {
      onBlurProp(event);
    }
    onBlur(event);
  };
  const onRemoveWrapper = React202.useCallback((event) => {
    onRemove(event, value);
  }, [
    onRemove,
    value
  ]);
  return React202.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    Component: Component3,
    className: classNames("vkuiChip", sizeY !== "regular" && sizeYClassNames17[sizeY], focusVisibleClassName, className),
    "aria-readonly": readOnly,
    "aria-disabled": disabled,
    onFocus: disabled ? void 0 : handleFocus,
    onBlur: disabled ? void 0 : handleBlur
  }), React202.createElement("div", {
    className: "vkuiChip__in"
  }, hasReactNode(before) && React202.createElement("div", {
    className: "vkuiChip__before"
  }, before), React202.createElement(Footnote, {
    className: "vkuiChip__content"
  }, children), hasReactNode(after) && React202.createElement("div", {
    className: "vkuiChip__after"
  }, after)), !readOnly && removable && React202.createElement("div", {
    className: "vkuiChip__removable"
  }, React202.createElement("button", {
    tabIndex: -1,
    disabled,
    className: "vkuiChip__remove",
    onClick: disabled ? void 0 : onRemoveWrapper
  }, React202.createElement(VisuallyHidden, null, "  ", removeLabel, " ", children), React202.createElement(Icon16Cancel, null))));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/ChipsInput.js
var React206 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/ChipsInputBase.js
var React204 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/constants.js
var React203 = __toESM(require_react());
var DEFAULT_VALUE = [];
var DEFAULT_INPUT_VALUE = "";
function getOptionValueDefault(option) {
  return option.value;
}
function getOptionLabelDefault(option) {
  return option.label;
}
function getNewOptionDataDefault(value, label) {
  return {
    value,
    label
  };
}
function renderChipDefault(props) {
  const { disabled, label } = props, rest = _object_without_properties(props, [
    "disabled",
    "label"
  ]);
  return React203.createElement(Chip, _object_spread({
    removable: !disabled
  }, rest), label);
}

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/helpers.js
var isValueLikeChipOptionObject = (v) => typeof v === "object" && "value" in v;
var isInputValueEmpty = (input) => input ? input.value === DEFAULT_INPUT_VALUE : true;
var getChipOptionIndexByValueProp = (optionProp, valueProp) => {
  const value = isValueLikeChipOptionObject(optionProp) ? optionProp.value : optionProp;
  return valueProp.findIndex((option) => option.value === value);
};
var getChipOptionIndexByHTMLElement = (el) => {
  const value = el && el.dataset.index;
  return typeof value === "string" ? Number(value) : -1;
};
var getChipOptionValueByHTMLElement = (el) => {
  const value = el && el.dataset.value;
  return typeof value === "string" ? value : -1;
};
var getNextChipOptionIndexByNavigateToProp = (currentIndex, navigateTo, length) => {
  const FIRST_INDEX = 0;
  const LAST_INDEX = length - 1;
  switch (navigateTo) {
    case "first":
      return FIRST_INDEX;
    case "prev":
      const prevIndex = currentIndex - 1;
      return prevIndex < 0 ? LAST_INDEX : prevIndex;
    case "next":
      const nextIndex = currentIndex + 1;
      return nextIndex > LAST_INDEX ? 0 : nextIndex;
    case "last":
      return LAST_INDEX;
    default:
      return -1;
  }
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInputBase/ChipsInputBase.js
var sizeYClassNames18 = {
  none: "vkuiChipsInputBase--sizeY-none",
  compact: "vkuiChipsInputBase--sizeY-compact"
};
var ChipsInputBase = (_param) => {
  var {
    // FormFieldProps
    getRootRef,
    style,
    className,
    before,
    after,
    status,
    mode,
    // option
    value = DEFAULT_VALUE,
    onAddChipOption,
    onRemoveChipOption: onRemoveChipOptionProp,
    renderChip = renderChipDefault,
    // input
    getRef,
    id: idProp,
    inputValue = DEFAULT_INPUT_VALUE,
    placeholder,
    disabled,
    readOnly,
    addOnBlur,
    onBlur,
    onInputChange
  } = _param, restProps = _object_without_properties(_param, [
    "getRootRef",
    "style",
    "className",
    "before",
    "after",
    "status",
    "mode",
    "value",
    "onAddChipOption",
    "onRemoveChipOption",
    "renderChip",
    "getRef",
    "id",
    "inputValue",
    "placeholder",
    "disabled",
    "readOnly",
    "addOnBlur",
    "onBlur",
    "onInputChange"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const idGenerated = React204.useId();
  const inputRef = useExternRef(getRef);
  const listboxRef = React204.useRef(null);
  const valueLength = value.length;
  const withPlaceholder = valueLength === 0;
  const [lastFocusedChipOptionIndex, setLastFocusedChipOptionIndex] = React204.useState(0);
  const resetChipOptionFocusToInputEl = (inputEl) => {
    setLastFocusedChipOptionIndex(0);
    inputEl.focus();
  };
  const moveFocusToChipOption = (currentIndex, navigateTo, listboxEl) => {
    const index2 = getNextChipOptionIndexByNavigateToProp(currentIndex, navigateTo, valueLength);
    const foundEl = listboxEl.querySelector(`[data-index="${index2}"]`);
    if (foundEl) {
      setLastFocusedChipOptionIndex(index2);
      foundEl.focus();
    }
  };
  const removeChipOption = (o, index2) => {
    if (!inputRef.current || !listboxRef.current) {
      return;
    }
    if (valueLength > 1) {
      if (index2 === valueLength - 1) {
        moveFocusToChipOption(index2, "prev", listboxRef.current);
      } else {
        moveFocusToChipOption(index2, "next", listboxRef.current);
      }
    } else {
      resetChipOptionFocusToInputEl(inputRef.current);
    }
    onRemoveChipOptionProp(o);
  };
  const handleListboxKeyDown = (event) => {
    const targetEl = event.target;
    if (event.defaultPrevented || !listboxRef.current || !isHTMLElement(targetEl)) {
      return;
    }
    switch (event.key) {
      case Keys.ENTER: {
        if (!readOnly && contains(targetEl, inputRef.current) && inputRef.current && !isInputValueEmpty(inputRef.current)) {
          event.preventDefault();
          onAddChipOption(inputRef.current.value);
        }
        break;
      }
      case Keys.DELETE:
      case Keys.BACKSPACE: {
        if (!readOnly && valueLength > 0) {
          if (!contains(targetEl, inputRef.current)) {
            event.preventDefault();
            removeChipOption(getChipOptionValueByHTMLElement(targetEl), getChipOptionIndexByHTMLElement(targetEl));
          } else if (event.key === Keys.BACKSPACE && isInputValueEmpty(inputRef.current)) {
            event.preventDefault();
            moveFocusToChipOption(getChipOptionIndexByHTMLElement(targetEl), "last", listboxRef.current);
          }
        }
        break;
      }
      case Keys.ARROW_UP:
      case Keys.ARROW_LEFT:
      case Keys.ARROW_DOWN:
      case Keys.ARROW_RIGHT: {
        if (valueLength !== 0 && !contains(targetEl, inputRef.current)) {
          event.preventDefault();
          moveFocusToChipOption(getChipOptionIndexByHTMLElement(targetEl), getHorizontalFocusGoTo(event.key), listboxRef.current);
        }
        break;
      }
    }
  };
  const handleInputBlur = (event) => {
    if (onBlur) {
      onBlur(event);
    }
    if (addOnBlur && !event.defaultPrevented && inputRef.current) {
      onAddChipOption(inputRef.current.value);
    }
  };
  const handleChipRemove = (event, v) => {
    event.preventDefault();
    event.stopPropagation();
    removeChipOption(v, getChipOptionIndexByValueProp(v, value));
  };
  const handleRootClick = (event) => {
    if (contains(event.currentTarget, getActiveElementByAnotherElement(event.currentTarget))) {
      return;
    }
    if (valueLength > 0 && listboxRef.current) {
      moveFocusToChipOption(0, "first", listboxRef.current);
    } else if (inputRef.current) {
      inputRef.current.focus();
    }
  };
  return React204.createElement(FormField, {
    Component: "div",
    getRootRef,
    style,
    disabled,
    before,
    after,
    status,
    mode,
    className,
    onClick: disabled ? void 0 : handleRootClick
  }, React204.createElement("div", {
    className: classNames("vkuiChipsInputBase", sizeY !== "regular" && sizeYClassNames18[sizeY], withPlaceholder && "vkuiChipsInputBase--hasPlaceholder"),
    // для a11y
    ref: listboxRef,
    role: "listbox",
    "aria-orientation": "horizontal",
    "aria-disabled": disabled,
    "aria-readonly": readOnly,
    onKeyDown: disabled ? void 0 : handleListboxKeyDown
  }, value.map((option, index2) => React204.createElement(React204.Fragment, {
    key: `${typeof option.value}-${option.label}`
  }, renderChip({
    "Component": "div",
    "value": option.value,
    "label": option.label,
    "disabled": disabled,
    "readOnly": readOnly,
    "className": "vkuiChipsInputBase__chip",
    "onRemove": handleChipRemove,
    // чтобы можно было легче найти этот чип в DOM
    "data-index": index2,
    "data-value": option.value,
    // для a11y
    "tabIndex": lastFocusedChipOptionIndex === index2 ? 0 : -1,
    "role": "option",
    "aria-selected": true,
    "aria-posinset": index2 + 1,
    "aria-setsize": valueLength
  }, option))), React204.createElement(Text, _object_spread_props(_object_spread({
    autoCapitalize: "none",
    autoComplete: "off",
    autoCorrect: "off",
    spellCheck: false
  }, restProps), {
    Component: "input",
    type: "text",
    id: idProp || `chips-input-base-generated-id-${idGenerated}`,
    getRootRef: inputRef,
    className: "vkuiChipsInputBase__el",
    disabled,
    readOnly,
    placeholder: withPlaceholder ? placeholder : void 0,
    value: inputValue,
    onChange: onInputChange,
    onBlur: handleInputBlur
  }))));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/useChipsInput.js
var React205 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/react/simulateReactInput.js
var simulateReactInput = (target, nextValue = "") => {
  try {
    const prevValue = target.value;
    target.value = nextValue;
    const tracker = target._valueTracker;
    if (tracker) {
      tracker.setValue(prevValue);
    }
    const event = new Event("input", {
      bubbles: true
    });
    target.dispatchEvent(event);
  } catch (error) {
    if (true) {
      throw error;
    }
  }
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/useChipsInput.js
var transformValue = (value, getOptionValue, getOptionLabel) => value.map((option) => _object_spread_props(_object_spread({}, option), {
  label: getOptionLabel(option),
  value: getOptionValue(option)
}));
var useChipsInput = ({
  // option
  value: valueProp,
  defaultValue = DEFAULT_VALUE,
  onChange,
  getOptionLabel = getOptionLabelDefault,
  getOptionValue = getOptionValueDefault,
  getNewOptionData = getNewOptionDataDefault,
  // input
  inputValue: inputValueProp,
  defaultInputValue = DEFAULT_INPUT_VALUE,
  onInputChange,
  // other
  disabled
}) => {
  const [value, setValue] = useCustomEnsuredControl({
    disabled,
    value: valueProp ? transformValue(valueProp, getOptionValue, getOptionLabel) : void 0,
    defaultValue: transformValue(defaultValue, getOptionValue, getOptionLabel),
    onChange
  });
  const inputRef = React205.useRef(null);
  const [inputValue, setInputChange] = useEnsuredControl({
    disabled,
    value: inputValueProp,
    defaultValue: defaultInputValue,
    onChange: onInputChange
  });
  const toggleOption = React205.useCallback((nextValueProp, isNewValue) => {
    setValue((prevValue) => {
      const isLikeObjectOption = isValueLikeChipOptionObject(nextValueProp);
      const resolvedOption = isLikeObjectOption ? getNewOptionData(nextValueProp.value, nextValueProp.label) : getNewOptionData(nextValueProp, typeof nextValueProp === "string" ? nextValueProp : "");
      const nextValue = prevValue.filter((option) => resolvedOption.value !== option.value);
      if (isNewValue === true) {
        nextValue.push(isLikeObjectOption ? _object_spread({}, nextValueProp, resolvedOption) : resolvedOption);
      }
      return nextValue;
    });
  }, [
    setValue,
    getNewOptionData
  ]);
  const clearInput = React205.useCallback(() => {
    if (!inputRef.current) {
      return;
    }
    simulateReactInput(inputRef.current, "");
  }, [
    inputRef
  ]);
  const addOption = React205.useCallback((newValue) => toggleOption(newValue, true), [
    toggleOption
  ]);
  const removeOption = React205.useCallback((newValue) => toggleOption(newValue, false), [
    toggleOption
  ]);
  const addOptionFromInput = React205.useCallback((inputValue2) => {
    const label = inputValue2.trim();
    if (label) {
      addOption(label);
      clearInput();
    }
  }, [
    addOption,
    clearInput
  ]);
  return {
    value,
    addOption,
    addOptionFromInput,
    removeOption,
    inputRef,
    inputValue,
    onInputChange: setInputChange,
    clearInput
  };
};

// node_modules/@vkontakte/vkui/dist/components/ChipsInput/ChipsInput.js
var ChipsInput = (_param) => {
  var {
    // option
    value: valueProp,
    defaultValue,
    onChange,
    // input
    getRef,
    inputValue: inputValueProp,
    defaultInputValue: inputDefaultValueProp,
    onInputChange: onInputChangeProp,
    getOptionValue = getOptionValueDefault,
    getOptionLabel = getOptionLabelDefault,
    getNewOptionData = getNewOptionDataDefault,
    // other
    disabled
  } = _param, restProps = _object_without_properties(_param, [
    "value",
    "defaultValue",
    "onChange",
    "getRef",
    "inputValue",
    "defaultInputValue",
    "onInputChange",
    "getOptionValue",
    "getOptionLabel",
    "getNewOptionData",
    "disabled"
  ]);
  const {
    value,
    addOptionFromInput,
    removeOption,
    // input
    inputRef: inputRefHook,
    inputValue,
    onInputChange
  } = useChipsInput({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionLabel,
    getOptionValue,
    getNewOptionData,
    // input
    inputValue: inputValueProp,
    defaultInputValue: inputDefaultValueProp,
    onInputChange: onInputChangeProp,
    // other
    disabled
  });
  const inputRef = useExternRef(getRef, inputRefHook);
  return React206.createElement(ChipsInputBase, _object_spread_props(_object_spread({}, restProps), {
    disabled,
    value,
    onAddChipOption: addOptionFromInput,
    onRemoveChipOption: removeOption,
    getRef: inputRef,
    inputValue,
    onInputChange
  }));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/ChipsSelect.js
var React215 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/select.js
var React207 = __toESM(require_react());
function getOptionLabelDefault2(option) {
  return option.label;
}
function defaultFilterFn(...args) {
  const [rawSearchQuery = "", option, getOptionLabel] = args;
  const foundRawLabel = getOptionLabel ? getOptionLabel(option) : getOptionLabelDefault2(option);
  if (foundRawLabel === void 0) {
    return false;
  }
  const searchQuery = rawSearchQuery.toLocaleLowerCase();
  const label = getTextFromChildren(foundRawLabel).toLocaleLowerCase();
  if (label.startsWith(searchQuery)) {
    return true;
  }
  const findAllIncludes = (target = "", search = "") => {
    const includes2 = [];
    let i = target.indexOf(search);
    while (i !== -1) {
      includes2.push(i);
      i = target.indexOf(search, i + 1);
    }
    return includes2;
  };
  const includes = findAllIncludes(label, searchQuery);
  if (includes.length) {
    const letterRegexp = new RegExp("\\p{L}", "u");
    for (const index2 of includes) {
      if (!letterRegexp.test(label[index2 - 1])) {
        return true;
      }
    }
  }
  return false;
}
var getFormFieldModeFromSelectType = (selectType = "default") => {
  return selectType === "default" ? "default" : "plain";
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelectDropdown/CustomSelectDropdown.js
var React210 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/CustomScrollView.js
var React209 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/useTrackerVisibility.js
var React208 = __toESM(require_react());
var useTrackerVisibility = (autoHideScrollbar = false, autoHideScrollbarDelay = 500) => {
  const [trackerVisible, setTrackerVisible] = React208.useState(!autoHideScrollbar);
  const isMouseOver = React208.useRef(false);
  const isTrackerDragging = React208.useRef(false);
  const { set: setVisibilityTimeout, clear: clearVisibilityTimeout } = useTimeout(() => setTrackerVisible(false), autoHideScrollbarDelay);
  const onTrackerDragStart = React208.useCallback(() => {
    clearVisibilityTimeout();
    setTrackerVisible(true);
    isTrackerDragging.current = true;
  }, [
    clearVisibilityTimeout
  ]);
  const onTrackerDragStop = React208.useCallback(() => {
    isTrackerDragging.current = false;
    if (!isMouseOver.current) {
      setVisibilityTimeout();
    }
  }, [
    setVisibilityTimeout,
    isMouseOver
  ]);
  const queueTrackerVisibility = React208.useCallback(() => {
    if (isTrackerDragging.current) {
      return;
    }
    setTrackerVisible(true);
    setVisibilityTimeout();
  }, [
    setVisibilityTimeout
  ]);
  const onTrackerMouseEnter = React208.useCallback(() => {
    clearVisibilityTimeout();
    isMouseOver.current = true;
    setTrackerVisible(true);
  }, [
    clearVisibilityTimeout
  ]);
  const onTrackerMouseLeave = React208.useCallback(() => {
    queueTrackerVisibility();
    isMouseOver.current = false;
  }, [
    queueTrackerVisibility
  ]);
  const onTargetScroll = React208.useCallback(() => {
    queueTrackerVisibility();
  }, [
    queueTrackerVisibility
  ]);
  return {
    trackerVisible,
    onTrackerDragStart,
    onTrackerDragStop,
    onTrackerMouseEnter,
    onTrackerMouseLeave,
    onTargetScroll
  };
};

// node_modules/@vkontakte/vkui/dist/components/CustomScrollView/CustomScrollView.js
function hasPointerClassName2(hasPointer) {
  switch (hasPointer) {
    case true:
      return "vkuiCustomScrollView--hasPointer-true";
    case false:
      return "vkuiCustomScrollView--hasPointer-false";
    case void 0:
    default:
      return "vkuiCustomScrollView--hasPointer-none";
  }
}
var CustomScrollView = (_param) => {
  var { className, children, boxRef: externalBoxRef, windowResize, autoHideScrollbar = false, autoHideScrollbarDelay, onScroll, getRootRef } = _param, restProps = _object_without_properties(_param, [
    "className",
    "children",
    "boxRef",
    "windowResize",
    "autoHideScrollbar",
    "autoHideScrollbarDelay",
    "onScroll",
    "getRootRef"
  ]);
  const { document: document2, window: window2 } = useDOM();
  const { hasPointer } = useAdaptivity();
  const ratio = React209.useRef(NaN);
  const lastTrackerTop = React209.useRef(0);
  const clientHeight = React209.useRef(0);
  const trackerHeight = React209.useRef(0);
  const scrollHeight = React209.useRef(0);
  const transformProp = React209.useRef("");
  const startY = React209.useRef(0);
  const trackerTop = React209.useRef(0);
  const boxRef = useExternRef(externalBoxRef);
  const barY = React209.useRef(null);
  const trackerY = React209.useRef(null);
  const setTrackerPosition = (scrollTop) => {
    lastTrackerTop.current = scrollTop;
    if (trackerY.current !== null) {
      trackerY.current.style[transformProp.current] = `translate(0, ${scrollTop}px)`;
    }
  };
  const setTrackerPositionFromScroll = (scrollTop) => {
    const progress = scrollTop / (scrollHeight.current - clientHeight.current);
    setTrackerPosition((clientHeight.current - trackerHeight.current) * progress);
  };
  const resize = () => {
    if (!boxRef.current || !barY.current || !trackerY.current) {
      return;
    }
    const localClientHeight = boxRef.current.clientHeight;
    const localScrollHeight = boxRef.current.scrollHeight;
    const localRatio = localClientHeight / localScrollHeight;
    const localTrackerHeight = Math.max(localClientHeight * localRatio, 40);
    ratio.current = localRatio;
    clientHeight.current = localClientHeight;
    scrollHeight.current = localScrollHeight;
    trackerHeight.current = localTrackerHeight;
    if (localRatio >= 1) {
      barY.current.style.display = "none";
    } else {
      barY.current.style.display = "";
      trackerY.current.style.height = `${localTrackerHeight}px`;
      setTrackerPositionFromScroll(boxRef.current.scrollTop);
    }
  };
  const resizeHandler = useEventListener("resize", resize);
  useIsomorphicLayoutEffect(() => {
    if (windowResize && window2) {
      resizeHandler.add(window2);
    }
  }, [
    windowResize,
    window2
  ]);
  useIsomorphicLayoutEffect(() => {
    var _trackerY_current;
    let style = (_trackerY_current = trackerY.current) === null || _trackerY_current === void 0 ? void 0 : _trackerY_current.style;
    let prop = "";
    if (style !== void 0) {
      if ("transform" in style) {
        prop = "transform";
      } else if ("webkitTransform" in style) {
        prop = "webkitTransform";
      }
    }
    transformProp.current = prop;
  }, []);
  useIsomorphicLayoutEffect(resize);
  const setScrollPositionFromTracker = (trackerTop2) => {
    const progress = trackerTop2 / (clientHeight.current - trackerHeight.current);
    if (boxRef.current !== null) {
      boxRef.current.scrollTop = (scrollHeight.current - clientHeight.current) * progress;
    }
  };
  const onMove = (e) => {
    e.preventDefault();
    const diff = e.clientY - startY.current;
    const position = Math.min(Math.max(trackerTop.current + diff, 0), clientHeight.current - trackerHeight.current);
    setScrollPositionFromTracker(position);
  };
  const { trackerVisible, onTargetScroll, onTrackerDragStart, onTrackerDragStop, onTrackerMouseEnter, onTrackerMouseLeave } = useTrackerVisibility(autoHideScrollbar, autoHideScrollbarDelay);
  const onUp = (e) => {
    e.preventDefault();
    if (autoHideScrollbar) {
      onTrackerDragStop();
    }
    unsubscribe();
  };
  const scroll = (event) => {
    if (ratio.current >= 1 || !boxRef.current) {
      return;
    }
    if (autoHideScrollbar) {
      onTargetScroll();
    }
    setTrackerPositionFromScroll(boxRef.current.scrollTop);
    onScroll === null || onScroll === void 0 ? void 0 : onScroll(event);
  };
  const listeners = [
    useEventListener("mousemove", onMove),
    useEventListener("mouseup", onUp)
  ];
  function subscribe(el) {
    if (el) {
      listeners.forEach((l) => l.add(el));
    }
  }
  function unsubscribe() {
    listeners.forEach((l) => l.remove());
  }
  const onDragStart = (e) => {
    e.preventDefault();
    startY.current = e.clientY;
    trackerTop.current = lastTrackerTop.current;
    if (autoHideScrollbar) {
      onTrackerDragStart();
    }
    subscribe(document2);
  };
  return React209.createElement("div", _object_spread({
    className: classNames(className, "vkuiCustomScrollView", hasPointerClassName2(hasPointer)),
    ref: getRootRef
  }, restProps), React209.createElement("div", {
    className: "vkuiCustomScrollView__box",
    tabIndex: -1,
    ref: boxRef,
    onScroll: scroll
  }, children), React209.createElement("div", {
    className: "vkuiCustomScrollView__barY",
    ref: barY,
    onClick: stopPropagation
  }, React209.createElement("div", {
    className: classNames("vkuiCustomScrollView__trackerY", !trackerVisible && "vkuiCustomScrollView__trackerY--hidden"),
    onMouseEnter: autoHideScrollbar ? onTrackerMouseEnter : void 0,
    onMouseLeave: autoHideScrollbar ? onTrackerMouseLeave : void 0,
    ref: trackerY,
    onMouseDown: onDragStart
  })));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelectDropdown/CustomSelectDropdown.js
var calcIsTop = (placement) => placement.startsWith("top");
var CustomSelectDropdown = (_param) => {
  var { children, targetRef, scrollBoxRef, placement = "bottom", fetching, onPlacementChange: parentOnPlacementChange, offsetDistance = 0, autoWidth = false, forcePortal = true, autoHideScrollbar, autoHideScrollbarDelay, className, noMaxHeight = false } = _param, restProps = _object_without_properties(_param, [
    "children",
    "targetRef",
    "scrollBoxRef",
    "placement",
    "fetching",
    "onPlacementChange",
    "offsetDistance",
    "autoWidth",
    "forcePortal",
    "autoHideScrollbar",
    "autoHideScrollbarDelay",
    "className",
    "noMaxHeight"
  ]);
  const [isTop, setIsTop] = React210.useState(() => calcIsTop(placement));
  const onPlacementChange = React210.useCallback((placement2) => {
    setIsTop(calcIsTop(placement2));
    if (parentOnPlacementChange) {
      parentOnPlacementChange(placement2);
    }
  }, [
    parentOnPlacementChange
  ]);
  return React210.createElement(Popper, _object_spread({
    targetRef,
    offsetByMainAxis: offsetDistance,
    sameWidth: !autoWidth,
    onPlacementChange,
    placement,
    className: classNames("vkuiCustomSelectDropdown", "vkuiInternalCustomSelectDropdown", offsetDistance === 0 && (isTop ? "vkuiCustomSelectDropdown--top" : "vkuiCustomSelectDropdown--bottom"), autoWidth && classNames("vkuiCustomSelectDropdown--wide", "vkuiInternalCustomSelectDropdown--wide"), className),
    usePortal: forcePortal,
    autoUpdateOnTargetResize: true
  }, restProps), React210.createElement(CustomScrollView, {
    boxRef: scrollBoxRef,
    className: noMaxHeight ? void 0 : "vkuiCustomSelectDropdown__in--withMaxHeight",
    autoHideScrollbar,
    autoHideScrollbarDelay
  }, fetching ? React210.createElement("div", {
    className: "vkuiCustomSelectDropdown__fetching"
  }, React210.createElement(Spinner, {
    size: "small"
  })) : children));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelectOption/CustomSelectOption.js
var React211 = __toESM(require_react());
var sizeYClassNames19 = {
  none: "vkuiCustomSelectOption--sizeY-none",
  ["regular"]: "vkuiCustomSelectOption--sizeY-regular"
};
var CustomSelectOption = (_param) => {
  var { children, hierarchy = 0, hovered: hoveredProp, selected, before, after, description, disabled, style: styleProp, className, onClick } = _param, restProps = _object_without_properties(_param, [
    "children",
    "hierarchy",
    "hovered",
    "selected",
    "before",
    "after",
    "description",
    "disabled",
    "style",
    "className",
    "onClick"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const style = React211.useMemo(() => hierarchy > 0 ? _object_spread({
    "--vkui_internal--custom_select_option_hierarchy_level": hierarchy
  }, styleProp) : styleProp, [
    hierarchy,
    styleProp
  ]);
  const hovered = hoveredProp && !disabled ? true : false;
  return React211.createElement(Paragraph, _object_spread_props(_object_spread({}, restProps), {
    onClick: disabled ? void 0 : onClick,
    Component: "div",
    role: "option",
    "aria-disabled": disabled,
    "aria-selected": selected,
    "data-hovered": hovered,
    className: classNames("vkuiCustomSelectOption", sizeY !== "compact" && sizeYClassNames19[sizeY], hovered && "vkuiCustomSelectOption--hover", disabled && "vkuiCustomSelectOption--disabled", hierarchy > 0 && "vkuiCustomSelectOption--hierarchy", className),
    style
  }), hasReactNode(before) && React211.createElement("div", {
    className: "vkuiCustomSelectOption__before"
  }, before), React211.createElement("div", {
    className: "vkuiCustomSelectOption__main"
  }, React211.createElement("div", {
    className: "vkuiCustomSelectOption__children"
  }, children), hasReactNode(description) && React211.createElement(Footnote, {
    className: "vkuiCustomSelectOption__description"
  }, React211.createElement(VisuallyHidden, null, " "), description)), React211.createElement("div", {
    className: "vkuiCustomSelectOption__after"
  }, hasReactNode(after) && React211.createElement("div", null, after), selected && React211.createElement(Icon16Done, {
    className: "vkuiCustomSelectOption__selectedIcon"
  })));
};

// node_modules/@vkontakte/vkui/dist/components/DropdownIcon/DropdownIcon.js
var React212 = __toESM(require_react());
var DropdownIcon = (_param) => {
  var { opened = false, className } = _param, restProps = _object_without_properties(_param, [
    "opened",
    "className"
  ]);
  const { sizeY } = useAdaptivityConditionalRender();
  const IconCompact = opened ? Icon20ChevronUp : Icon20Dropdown;
  const IconRegular = opened ? Icon24ChevronUp : Icon24ChevronDown;
  return React212.createElement(React212.Fragment, null, sizeY.compact && React212.createElement(IconCompact, _object_spread({
    className: classNames(sizeY.compact.className, className)
  }, restProps)), sizeY.regular && React212.createElement(IconRegular, _object_spread({
    className: classNames(sizeY.regular.className, className)
  }, restProps)));
};

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/constants.js
var React213 = __toESM(require_react());
var DEFAULT_SELECTED_BEHAVIOR = "highlight";
var DEFAULT_EMPTY_TEXT = "Ничего не найдено";
var FOCUS_ACTION_NEXT = "next";
var FOCUS_ACTION_PREV = "prev";
var renderOptionDefault = (props) => React213.createElement(CustomSelectOption, props);
var isCreateNewOptionPreset = (option) => option && "actionText" in option;
var isEmptyOptionPreset = (option) => option && "placeholder" in option;
var isNotServicePreset = (option) => !isCreateNewOptionPreset(option) && !isEmptyOptionPreset(option);

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/useChipsSelect.js
var React214 = __toESM(require_react());
var useChipsSelect = ({
  // common
  disabled,
  // option
  value: valueProp,
  defaultValue,
  onChange,
  getOptionLabel = getOptionLabelDefault,
  getOptionValue = getOptionValueDefault,
  getNewOptionData = getNewOptionDataDefault,
  // input
  inputValue: inputValueProp,
  defaultInputValue = DEFAULT_INPUT_VALUE,
  onInputChange: onInputChangeProp,
  // dropdown
  creatable = false,
  emptyText = DEFAULT_EMPTY_TEXT,
  filterFn = defaultFilterFn,
  selectedBehavior = DEFAULT_SELECTED_BEHAVIOR,
  options: optionsProp = DEFAULT_VALUE
}) => {
  const _useChipsInput = useChipsInput({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionValue,
    getOptionLabel,
    getNewOptionData,
    // input
    inputValue: inputValueProp,
    defaultInputValue,
    onInputChange: onInputChangeProp,
    // other
    disabled
  }), { value, inputValue, onInputChange } = _useChipsInput, restChipsInputProps = _object_without_properties(_useChipsInput, [
    "value",
    "inputValue",
    "onInputChange"
  ]);
  const [opened, setOpened] = React214.useState(false);
  const [options, setOptions] = React214.useState(() => opened ? transformOptions({
    value,
    getOptionValue,
    getOptionLabel,
    inputValue,
    emptyText,
    creatable,
    filterFn,
    options: optionsProp,
    selectedBehavior
  }) : []);
  const [focusedOptionIndex, setFocusedOptionIndex] = React214.useState(0);
  const [focusedOption, setFocusedOption] = React214.useState(null);
  const handleInputChange = React214.useCallback((event) => {
    onInputChange(event);
    if (!opened) {
      setOpened(true);
      setFocusedOptionIndex(0);
    }
  }, [
    onInputChange,
    opened
  ]);
  useIsomorphicLayoutEffect(function handleDropdownOpen() {
    if (!opened) {
      return;
    }
    setOptions((prevOptions) => {
      const nextOptions = transformOptions({
        value,
        getOptionValue,
        getOptionLabel,
        inputValue,
        emptyText,
        creatable,
        filterFn,
        options: optionsProp,
        selectedBehavior
      });
      if (isEqual(prevOptions, nextOptions)) {
        return prevOptions;
      }
      return nextOptions;
    });
  }, [
    opened,
    value,
    getOptionLabel,
    getOptionValue,
    inputValue,
    optionsProp,
    creatable,
    selectedBehavior,
    filterFn
  ]);
  return _object_spread_props(_object_spread({}, restChipsInputProps), {
    // options
    value,
    // input
    inputValue,
    onInputChange: handleInputChange,
    // dropdown states
    options,
    opened,
    setOpened,
    focusedOption,
    focusedOptionIndex,
    setFocusedOption,
    setFocusedOptionIndex
  });
};
function transformOptions({ value, getOptionValue = getOptionValueDefault, getOptionLabel = getOptionLabelDefault, inputValue = DEFAULT_INPUT_VALUE, emptyText = DEFAULT_EMPTY_TEXT, creatable = false, filterFn = defaultFilterFn, options: optionsProp = DEFAULT_VALUE, selectedBehavior = DEFAULT_SELECTED_BEHAVIOR }) {
  const filteredOptionsProp = filterFn ? optionsProp.filter((option) => filterFn(inputValue, option, getOptionLabel)) : optionsProp;
  if (filteredOptionsProp.length === 0) {
    if (inputValue !== DEFAULT_INPUT_VALUE && typeof creatable === "string") {
      return [
        {
          actionText: creatable
        }
      ];
    }
    return [
      {
        placeholder: emptyText
      }
    ];
  }
  const parsedOptions = transformValue(filteredOptionsProp, getOptionValue, getOptionLabel);
  if (selectedBehavior === "hide") {
    const selected = value.map((item) => item.value);
    return parsedOptions.filter((item) => isNotServicePreset(item) ? !selected.includes(item.value) : false);
  }
  return parsedOptions;
}

// node_modules/@vkontakte/vkui/dist/components/ChipsSelect/ChipsSelect.js
var stylesDropdownVerticalPlacement = {
  top: "vkuiChipsSelect--pop-up",
  bottom: "vkuiChipsSelect--pop-down"
};
var findIndexAfter = (options = [], startIndex = -1) => {
  if (startIndex >= options.length - 1) {
    return -1;
  }
  return options.findIndex((option, i) => i > startIndex && (!isNotServicePreset(option) || !option.disabled));
};
var findIndexBefore = (options = [], endIndex = options.length) => {
  let result = -1;
  if (endIndex <= 0) {
    return result;
  }
  for (let i = endIndex - 1; i >= 0; i--) {
    let option = options[i];
    if (!isNotServicePreset(option) || !option.disabled) {
      result = i;
      break;
    }
  }
  return result;
};
var ChipsSelect = (_param) => {
  var {
    // FormFieldProps
    id: labelledbyId,
    getRootRef,
    className,
    status = "default",
    icon: dropdownIconProp,
    onChangeStart,
    // CustomSelectDropdownProps
    options: optionsProp,
    placement: placementProp = "bottom",
    closeAfterSelect = true,
    selectedBehavior = DEFAULT_SELECTED_BEHAVIOR,
    emptyText = DEFAULT_EMPTY_TEXT,
    creatable = false,
    fetching = false,
    dropdownAutoWidth,
    forceDropdownPortal,
    noMaxHeight = false,
    filterFn = defaultFilterFn,
    dropdownTestId,
    // ChipsInputProps
    getRef,
    value: valueProp,
    defaultValue,
    inputValue: inputValueProp,
    defaultInputValue,
    disabled,
    readOnly,
    getOptionValue = getOptionValueDefault,
    getOptionLabel = getOptionLabelDefault,
    getNewOptionData = getNewOptionDataDefault,
    renderChip = renderChipDefault,
    renderOption = renderOptionDefault,
    onChange,
    onFocus: onFocusProp,
    onInputChange: onInputChangeProp,
    onBlur: onBlurProp,
    onKeyDown: onKeyDownProp
  } = _param, restProps = _object_without_properties(_param, [
    "id",
    "getRootRef",
    "className",
    "status",
    "icon",
    "onChangeStart",
    "options",
    "placement",
    "closeAfterSelect",
    "selectedBehavior",
    "emptyText",
    "creatable",
    "fetching",
    "dropdownAutoWidth",
    "forceDropdownPortal",
    "noMaxHeight",
    "filterFn",
    "dropdownTestId",
    "getRef",
    "value",
    "defaultValue",
    "inputValue",
    "defaultInputValue",
    "disabled",
    "readOnly",
    "getOptionValue",
    "getOptionLabel",
    "getNewOptionData",
    "renderChip",
    "renderOption",
    "onChange",
    "onFocus",
    "onInputChange",
    "onBlur",
    "onKeyDown"
  ]);
  const {
    // Связано с ChipsInputProps
    // option
    value,
    addOptionFromInput,
    addOption,
    removeOption,
    // input
    inputRef: inputRefHook,
    inputValue,
    clearInput,
    onInputChange,
    // Связано с CustomSelectDropdownProps
    options,
    opened,
    setOpened,
    focusedOption,
    focusedOptionIndex,
    setFocusedOption,
    setFocusedOptionIndex
  } = useChipsSelect({
    // option
    value: valueProp,
    defaultValue,
    onChange,
    getOptionValue,
    getOptionLabel,
    getNewOptionData,
    // input
    inputValue: inputValueProp,
    defaultInputValue,
    onInputChange: onInputChangeProp,
    // dropdown
    options: optionsProp,
    emptyText,
    creatable,
    filterFn,
    selectedBehavior,
    // other
    disabled
  });
  const rootRef = useExternRef(getRootRef);
  const inputRef = useExternRef(getRef, inputRefHook);
  const [dropdownVerticalPlacement, setDropdownVerticalPlacement] = React215.useState(placementProp);
  const dropdownId = React215.useId();
  const dropdownCurrentItemId = focusedOptionIndex !== null ? `${dropdownId}-${focusedOptionIndex}` : void 0;
  const dropdownScrollBoxRef = React215.useRef(null);
  const handleFocus = (event) => {
    if (onFocusProp) {
      onFocusProp(event);
    }
    if (!readOnly) {
      setOpened(true);
      setFocusedOptionIndex(null);
    }
  };
  const handleBlur = (event) => {
    if (onBlurProp) {
      onBlurProp(event);
    }
    if (!readOnly && !event.defaultPrevented && !creatable) {
      event.preventDefault();
    }
  };
  const chipsSelectOptions = React215.useRef([]).current;
  const scrollToElement = (index2, center = false) => {
    const dropdown = dropdownScrollBoxRef.current;
    const item = chipsSelectOptions[index2];
    if (!item || !dropdown) {
      return;
    }
    const dropdownHeight = dropdown.offsetHeight;
    const scrollTop = dropdown.scrollTop;
    const itemTop = item.offsetTop;
    const itemHeight = item.offsetHeight;
    if (center) {
      dropdown.scrollTop = itemTop - dropdownHeight / 2 + itemHeight / 2;
    } else if (itemTop + itemHeight > dropdownHeight + scrollTop) {
      dropdown.scrollTop = itemTop - dropdownHeight + itemHeight;
    } else if (itemTop < scrollTop) {
      dropdown.scrollTop = itemTop;
    }
  };
  const focusOptionByIndex = (index2, oldIndex) => {
    const length = options.length;
    if (index2 < 0) {
      index2 = length - 1;
    } else if (index2 >= length) {
      index2 = 0;
    }
    if (index2 === oldIndex) {
      return;
    }
    const option = options[index2];
    if (isNotServicePreset(option) && option.disabled) {
      return;
    }
    scrollToElement(index2);
    setFocusedOptionIndex(index2);
  };
  const focusOption = (nextIndex, type) => {
    let index2 = nextIndex === null ? -1 : nextIndex;
    if (type === FOCUS_ACTION_NEXT) {
      const nextIndex2 = findIndexAfter(options, index2);
      index2 = nextIndex2 === -1 ? findIndexAfter(options) : nextIndex2;
    } else if (type === FOCUS_ACTION_PREV) {
      const beforeIndex = findIndexBefore(options, index2);
      index2 = beforeIndex === -1 ? findIndexBefore(options) : beforeIndex;
    }
    focusOptionByIndex(index2, focusedOptionIndex);
  };
  const handleKeyDown = (event) => {
    if (onKeyDownProp) {
      onKeyDownProp(event);
    }
    if (event.defaultPrevented || readOnly) {
      return;
    }
    switch (event.key) {
      case Keys.ARROW_UP:
      case Keys.ARROW_DOWN:
        event.preventDefault();
        if (!opened) {
          setOpened(true);
          focusOption(null, FOCUS_ACTION_NEXT);
        } else {
          focusOption(focusedOptionIndex, event.key === Keys.ARROW_UP ? FOCUS_ACTION_PREV : FOCUS_ACTION_NEXT);
        }
        break;
      case Keys.ENTER: {
        if (!opened) {
          break;
        }
        if (focusedOptionIndex != null) {
          const foundOption = options[focusedOptionIndex];
          if (foundOption && isNotServicePreset(foundOption)) {
            event.preventDefault();
            if (onChangeStart) {
              onChangeStart(event, foundOption);
            }
            addOption(foundOption);
            setFocusedOptionIndex(null);
            clearInput();
            if (closeAfterSelect) {
              setOpened(false);
            }
            break;
          }
        }
        if (!creatable) {
          event.preventDefault();
        }
        break;
      }
      case Keys.ESCAPE:
      case Keys.TAB:
        if (opened) {
          setOpened(false);
        }
    }
  };
  React215.useEffect(() => {
    if (focusedOptionIndex === null) {
      setFocusedOption(null);
    } else {
      const foundFocusedOptionIndex = options[focusedOptionIndex];
      if (foundFocusedOptionIndex && isNotServicePreset(foundFocusedOptionIndex)) {
        setFocusedOption(foundFocusedOptionIndex);
      }
    }
  }, [
    options,
    focusedOptionIndex,
    setFocusedOption
  ]);
  const onDropdownPlacementChange = React215.useCallback((placement) => {
    if (placement.startsWith("top")) {
      setDropdownVerticalPlacement("top");
    } else if (placement.startsWith("bottom")) {
      setDropdownVerticalPlacement("bottom");
    }
  }, []);
  const onDropdownMouseLeave = React215.useCallback(() => {
    setFocusedOptionIndex(null);
  }, [
    setFocusedOptionIndex
  ]);
  const handleClickOutside = React215.useCallback(() => {
    setOpened(false);
  }, [
    setOpened
  ]);
  useGlobalOnClickOutside(handleClickOutside, opened ? rootRef : null, opened ? dropdownScrollBoxRef : null);
  return React215.createElement(React215.Fragment, null, React215.createElement(ChipsInputBase, _object_spread_props(_object_spread({}, restProps), {
    disabled,
    readOnly,
    // FormFieldProps
    id: labelledbyId,
    getRootRef: rootRef,
    className: classNames("vkuiChipsSelect", opened && dropdownVerticalPlacement && stylesDropdownVerticalPlacement[dropdownVerticalPlacement], className),
    status,
    after: dropdownIconProp || React215.createElement(DropdownIcon, {
      opened
    }),
    // option
    value,
    onAddChipOption: addOptionFromInput,
    onRemoveChipOption: removeOption,
    renderChip,
    // input
    getRef: inputRef,
    inputValue,
    onInputChange,
    onFocus: handleFocus,
    onBlur: handleBlur,
    onKeyDown: handleKeyDown,
    // a11y
    role: "combobox",
    "aria-expanded": opened,
    "aria-autocomplete": "list",
    "aria-controls": opened ? dropdownId : void 0,
    "aria-activedescendant": opened ? dropdownCurrentItemId : void 0,
    "aria-haspopup": "listbox"
  })), opened && React215.createElement(CustomSelectDropdown, {
    "data-testid": dropdownTestId,
    targetRef: rootRef,
    placement: placementProp,
    scrollBoxRef: dropdownScrollBoxRef,
    onPlacementChange: onDropdownPlacementChange,
    onMouseLeave: onDropdownMouseLeave,
    fetching,
    autoWidth: dropdownAutoWidth,
    forcePortal: forceDropdownPortal,
    noMaxHeight,
    // a11y
    id: dropdownId,
    role: "listbox",
    "aria-labelledby": labelledbyId
  }, options.map((option, index2) => {
    const dropdownItemId = `${dropdownId}-${index2}`;
    if (isEmptyOptionPreset(option)) {
      return React215.createElement(Footnote, {
        key: "empty-text",
        className: "vkuiChipsSelect__empty"
      }, option.placeholder);
    }
    if (isCreateNewOptionPreset(option)) {
      return React215.createElement(CustomSelectOption, {
        key: "create-new-option",
        id: dropdownItemId,
        hovered: focusedOptionIndex === index2,
        onMouseDown: () => addOptionFromInput(inputValue),
        onMouseEnter: () => setFocusedOptionIndex(index2)
      }, option.actionText);
    }
    return React215.createElement(React215.Fragment, {
      key: `${typeof option.value}-${option.label}`
    }, renderOption({
      id: dropdownItemId,
      disabled: option.disabled,
      hovered: focusedOption ? getOptionValue(option) === getOptionValue(focusedOption) : false,
      children: option.label,
      selected: !!value.find((selectedOption) => getOptionValue(selectedOption) === getOptionValue(option)),
      getRootRef(node) {
        if (node) {
          chipsSelectOptions[index2] = node;
        }
      },
      onMouseDown(event) {
        if (option.disabled) {
          return;
        }
        if (onChangeStart) {
          onChangeStart(event, option);
        }
        if (!event.defaultPrevented) {
          closeAfterSelect && setOpened(false);
          addOption(option);
          clearInput();
        }
      },
      onMouseEnter() {
        setFocusedOptionIndex(index2);
      }
    }, option));
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Slider/Slider.js
var React218 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/Slider/SliderThumb/SliderThumb.js
var React216 = __toESM(require_react());
var SliderThumb = (_param) => {
  var { className, getRootRef, inputProps, withTooltip } = _param, restProps = _object_without_properties(_param, [
    "className",
    "getRootRef",
    "inputProps",
    "withTooltip"
  ]);
  const { focusVisible, onBlur, onFocus } = useFocusVisible(false);
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible,
    mode: "vkuiSliderThumb--focus-visible"
  });
  const [arrowRef, setArrowRef] = React216.useState(null);
  const memoizedMiddlewares = React216.useMemo(() => {
    return [
      offset({
        crossAxis: 0,
        mainAxis: 15
      }),
      flip3(),
      shift3({
        padding: 8
      }),
      arrow3({
        element: arrowRef
      })
    ];
  }, [
    arrowRef
  ]);
  const { x: floatingDataX, y: floatingDataY, placement: resolvedPlacement, refs, strategy: floatingPositionStrategy, middlewareData: { arrow: arrowCoords }, update: updateTooltipPosition } = useFloating({
    placement: "top",
    middleware: memoizedMiddlewares
  });
  const { value: isHovered, setTrue: setHoveredTrue, setFalse: setHoveredFalse } = useBooleanState(false);
  const handleRootRef = useExternRef(getRootRef, refs.setReference);
  const shouldShowTooltip = withTooltip && (focusVisible || isHovered);
  const inputValue = inputProps && inputProps.value;
  React216.useEffect(function udpateTooltipPositionOnValueChange() {
    if (shouldShowTooltip && inputValue !== "undefined") {
      updateTooltipPosition();
    }
  }, [
    inputValue,
    updateTooltipPosition,
    shouldShowTooltip
  ]);
  return React216.createElement(React216.Fragment, null, React216.createElement("span", _object_spread_props(_object_spread({}, restProps), {
    ref: handleRootRef,
    onMouseEnter: setHoveredTrue,
    onMouseLeave: setHoveredFalse,
    className: classNames("vkuiSliderThumb", focusVisibleClassNames, className)
  }), React216.createElement("input", _object_spread_props(_object_spread({}, inputProps), {
    type: "range",
    className: "vkuiSliderThumb__nativeInput",
    "aria-orientation": "horizontal",
    onBlur,
    onFocus
  }))), shouldShowTooltip && React216.createElement(TooltipBase, {
    appearance: "neutral",
    getRootRef: refs.setFloating,
    style: convertFloatingDataToReactCSSProperties(floatingPositionStrategy, floatingDataX, floatingDataY),
    arrowProps: {
      coords: arrowCoords,
      placement: resolvedPlacement,
      getRootRef: setArrowRef
    },
    text: inputValue
  }));
};

// node_modules/@vkontakte/vkui/dist/components/Slider/helpers.js
var React217 = __toESM(require_react());
var toPercent = (v, min2, max2) => (v - min2) / (max2 - min2) * 100;
var offsetToValue = (startX, width, min2, max2, step) => {
  return rescale(startX, [
    0,
    width
  ], [
    min2,
    max2
  ], {
    step
  });
};
var restrictValueByMinMax = (value, min2, max2) => {
  if (value < min2) {
    return min2;
  }
  if (value > max2) {
    return max2;
  }
  return value;
};
var updateInternalStateValue = (prevValue, nextValue, min2, max2, dragging) => {
  const [prevStartValue, prevEndValue] = prevValue;
  if (prevEndValue === null) {
    return [
      restrictValueByMinMax(nextValue, min2, max2),
      null
    ];
  }
  switch (dragging) {
    case "start":
      return nextValue > prevEndValue ? [
        prevEndValue,
        prevEndValue
      ] : [
        restrictValueByMinMax(nextValue, min2, max2),
        prevEndValue
      ];
    case "end":
      return nextValue < prevStartValue ? [
        prevStartValue,
        prevStartValue
      ] : [
        prevStartValue,
        restrictValueByMinMax(nextValue, min2, max2)
      ];
    case null:
    default:
      return prevValue;
  }
};
var updateInternalStateValueByNativeChange = (prevValue, nextValue, dragging) => {
  const [prevStartValue, prevEndValue] = prevValue;
  switch (dragging) {
    case "start":
      return [
        nextValue,
        prevEndValue
      ];
    case "end":
      return [
        prevStartValue,
        nextValue
      ];
    case null:
    default:
      return prevValue;
  }
};
function isMultipleValues(value) {
  return value[1] !== null;
}
var snapDirection = (prevValue, nextValue, type) => {
  if (type === "start") {
    return "start";
  }
  if (type === "end") {
    return "end";
  }
  const [startRaw, endRaw] = prevValue;
  const FORCE_DIFF_VALUE = 0.1;
  const start = endRaw !== null ? startRaw - FORCE_DIFF_VALUE : startRaw;
  const end = endRaw !== null ? endRaw + FORCE_DIFF_VALUE : 0;
  return Math.abs(start - nextValue) <= Math.abs(end - nextValue) ? "start" : "end";
};
var getDraggingTypeByTargetDataset = (target) => {
  if (target) {
    if (target.dataset.type === "start") {
      return "start";
    }
    if (target.dataset.type === "end") {
      return "end";
    }
  }
  return null;
};
var resetProps = {
  "aria-label": void 0,
  "aria-valuetext": void 0,
  "aria-labelledby": void 0
};
var extractSliderAriaAttributesFromRestProps = (restProps) => {
  const ariaLabel = restProps["aria-label"];
  const ariaValueText = restProps["aria-valuetext"];
  const ariaLabelledBy = restProps["aria-labelledby"];
  return _object_spread_props(_object_spread({}, restProps, resetProps), {
    ariaLabel,
    ariaValueText,
    ariaLabelledBy
  });
};

// node_modules/@vkontakte/vkui/dist/components/Slider/Slider.js
var sizeYClassNames20 = {
  none: "vkuiSlider--sizeY-none",
  ["compact"]: "vkuiSlider--sizeY-compact"
};
var Slider = (_param) => {
  var { step = 1, min: min2 = 0, max: max2 = 100, value: valueProp, multiple: multipleProp, defaultValue = multipleProp ? [
    min2,
    max2
  ] : min2, disabled, className, getRootRef, getAriaLabel, getAriaValueText, onChange, withTooltip } = _param, restProps = _object_without_properties(_param, [
    "step",
    "min",
    "max",
    "value",
    "multiple",
    "defaultValue",
    "disabled",
    "className",
    "getRootRef",
    "getAriaLabel",
    "getAriaValueText",
    "onChange",
    "withTooltip"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const isControlled = valueProp !== void 0;
  const [localValue, setValue] = React218.useState(defaultValue);
  const value = React218.useMemo(() => {
    const resolvedValue = isControlled ? valueProp : localValue;
    return Array.isArray(resolvedValue) ? [
      clamp2(resolvedValue[0], min2, max2),
      clamp2(resolvedValue[1], min2, max2)
    ] : [
      clamp2(resolvedValue, min2, max2),
      null
    ];
  }, [
    isControlled,
    valueProp,
    localValue,
    min2,
    max2
  ]);
  const [startValue, endValue] = value;
  const multiple = multipleProp && endValue !== null;
  const startValueInPercent = toPercent(startValue, min2, max2);
  const endReversedValueInPercent = multiple ? toPercent(endValue, min2, max2) : 0;
  const gesture = React218.useRef({
    dragging: null,
    startX: 0,
    containerWidth: 0
  }).current;
  const thumbsContainerRef = useExternRef(getRootRef);
  const thumbStartInputRef = React218.useRef(null);
  const thumbEndInputRef = React218.useRef(null);
  const _extractSliderAriaAttributesFromRestProps = extractSliderAriaAttributesFromRestProps(restProps), { ariaLabel, ariaValueText, ariaLabelledBy } = _extractSliderAriaAttributesFromRestProps, restPropsWithoutAriaAttributes = _object_without_properties(_extractSliderAriaAttributesFromRestProps, [
    "ariaLabel",
    "ariaValueText",
    "ariaLabelledBy"
  ]);
  const changeValue = (nextValue, event) => {
    if (disabled || value[0] === nextValue[0] && value[1] === nextValue[1]) {
      return;
    }
    if (multipleProp) {
      if (isMultipleValues(nextValue)) {
        !isControlled && setValue(nextValue);
        onChange && onChange(nextValue, event);
      }
    } else {
      !isControlled && setValue(nextValue[0]);
      onChange && onChange(nextValue[0], event);
    }
  };
  const handlePointerStart = (event) => {
    if (!thumbsContainerRef.current) {
      return;
    }
    const { left: nextContainerX, width: nextContainerWidth } = thumbsContainerRef.current.getBoundingClientRect();
    const foundDraggingType = getDraggingTypeByTargetDataset(event.originalEvent.target);
    const nextStartX = event.startX - nextContainerX;
    const nextValue = offsetToValue(nextStartX, nextContainerWidth, min2, max2, step);
    const nextDragging = snapDirection(value, nextValue, foundDraggingType);
    gesture.dragging = nextDragging;
    gesture.containerWidth = nextContainerWidth;
    gesture.startX = nextStartX;
    const updatedInternalStateValue = updateInternalStateValue(value, nextValue, min2, max2, nextDragging);
    const [nextStartValue, nextEndValue] = updatedInternalStateValue;
    if (thumbStartInputRef.current && (foundDraggingType === "start" || nextStartValue !== startValue && nextEndValue === endValue)) {
      thumbStartInputRef.current.focus();
      event.originalEvent.preventDefault();
    } else if (thumbEndInputRef.current && (foundDraggingType === "end" || nextEndValue !== endValue && nextStartValue === startValue)) {
      thumbEndInputRef.current.focus();
      event.originalEvent.preventDefault();
    }
    changeValue(updatedInternalStateValue, event);
    event.originalEvent.stopPropagation();
  };
  const handlePointerMove = (event) => {
    const { startX, containerWidth, dragging } = gesture;
    const { shiftX = 0 } = event;
    const nextStartX = startX + shiftX;
    const nextValue = offsetToValue(nextStartX, containerWidth, min2, max2, step);
    changeValue(updateInternalStateValue(value, nextValue, min2, max2, dragging), event);
    event.originalEvent.stopPropagation();
    event.originalEvent.preventDefault();
  };
  const handlePointerEnd = (event) => {
    gesture.dragging = null;
    event.originalEvent.stopPropagation();
  };
  const handleChangeByNativeInput = (event) => {
    changeValue(updateInternalStateValueByNativeChange(value, Number(event.target.value), getDraggingTypeByTargetDataset(event.target)), event);
  };
  return React218.createElement(Touch, _object_spread_props(_object_spread({
    "data-value": multiple ? `${startValue},${endValue}` : startValue
  }, restPropsWithoutAriaAttributes), {
    className: classNames("vkuiSlider", disabled && "vkuiSlider--disabled", sizeY !== "regular" && sizeYClassNames20[sizeY], className),
    onStart: disabled ? void 0 : handlePointerStart,
    onMove: disabled ? void 0 : handlePointerMove,
    onEnd: disabled ? void 0 : handlePointerEnd
  }), React218.createElement("div", {
    className: "vkuiSlider__track"
  }), React218.createElement("div", {
    className: "vkuiSlider__track-fill",
    style: multiple ? {
      left: `${startValueInPercent}%`,
      right: `${100 - endReversedValueInPercent}%`
    } : {
      width: `${startValueInPercent}%`
    }
  }), React218.createElement("div", {
    ref: thumbsContainerRef,
    className: "vkuiSlider__thumbs"
  }, React218.createElement(SliderThumb, {
    "data-type": "start",
    className: "vkuiSlider__thumb",
    style: {
      left: `${startValueInPercent}%`,
      // Меняем местами порядок слоёв, иначе, при достижении `start` и `end` 100%, `end` будет перекрывать `start`.
      zIndex: multiple && startValueInPercent >= 50 ? 2 : void 0
    },
    withTooltip,
    inputProps: {
      "data-type": "start",
      "ref": thumbStartInputRef,
      "step": step,
      "min": min2,
      "value": startValue,
      "max": multiple ? endValue : max2,
      "disabled": disabled,
      "aria-label": getAriaLabel ? getAriaLabel(0) : ariaLabel,
      "aria-valuetext": getAriaValueText ? getAriaValueText(startValue, 0) : ariaValueText,
      "aria-labelledby": ariaLabelledBy,
      "onChange": handleChangeByNativeInput
    }
  }), multiple && React218.createElement(SliderThumb, {
    "data-type": "end",
    className: "vkuiSlider__thumb",
    style: {
      left: `${endReversedValueInPercent}%`
    },
    withTooltip,
    inputProps: {
      "data-type": "end",
      "ref": thumbEndInputRef,
      "step": step,
      "min": startValue,
      "value": endValue,
      "max": max2,
      "disabled": disabled,
      "aria-label": getAriaLabel ? getAriaLabel(1) : ariaLabel,
      "aria-valuetext": getAriaValueText ? getAriaValueText(endValue, 1) : ariaValueText,
      "aria-labelledby": ariaLabelledBy,
      "onChange": handleChangeByNativeInput
    }
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Textarea/Textarea.js
var React219 = __toESM(require_react());
var sizeYClassNames21 = {
  none: "vkuiTextarea--sizeY-none",
  ["compact"]: "vkuiTextarea--sizeY-compact"
};
var Textarea = (_param) => {
  var { grow = true, style, onResize, className, getRootRef, getRef, rows = 2, maxHeight, status, onChange } = _param, restProps = _object_without_properties(_param, [
    "grow",
    "style",
    "onResize",
    "className",
    "getRootRef",
    "getRef",
    "rows",
    "maxHeight",
    "status",
    "onChange"
  ]);
  const currentScrollHeight = React219.useRef();
  const elementRef = useExternRef(getRef);
  const { sizeY = "none" } = useAdaptivity();
  const autosizeInput = () => {
    const el = elementRef.current;
    if (grow && (el === null || el === void 0 ? void 0 : el.offsetParent)) {
      el.style.height = "";
      el.style.height = `${el.scrollHeight}px`;
      if (el.scrollHeight !== currentScrollHeight.current && onResize) {
        onResize(el);
        currentScrollHeight.current = el.scrollHeight;
      }
    }
  };
  React219.useEffect(autosizeInput, [
    grow,
    sizeY,
    elementRef,
    onResize
  ]);
  return React219.createElement(FormField, {
    className: classNames("vkuiTextarea", sizeY !== "regular" && sizeYClassNames21[sizeY], className),
    style,
    getRootRef,
    disabled: restProps.disabled,
    status
  }, React219.createElement(Text, _object_spread_props(_object_spread({}, restProps), {
    Component: "textarea",
    normalize: false,
    style: {
      maxHeight
    },
    rows,
    className: "vkuiTextarea__el",
    onChange: callMultiple(onChange, autosizeInput),
    getRootRef: elementRef
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Radio/Radio.js
var React220 = __toESM(require_react());
var sizeYClassNames22 = {
  none: "vkuiRadio--sizeY-none",
  ["compact"]: "vkuiRadio--sizeY-compact"
};
var RadioIcon = (props) => {
  return React220.createElement("svg", _object_spread({
    xmlns: "http://www.w3.org/2000/svg",
    viewBox: "0 0 24 24",
    "aria-hidden": true
  }, props), React220.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "11",
    stroke: "currentColor",
    strokeWidth: "2",
    fill: "none"
  }), React220.createElement("circle", {
    cx: "12",
    cy: "12",
    r: "7.5",
    className: "vkuiRadio__pin",
    fill: "currentColor"
  }));
};
var Radio2 = (_param) => {
  var { children, description, style, className, getRootRef, titleAfter, getRef, labelProps } = _param, restProps = _object_without_properties(_param, [
    "children",
    "description",
    "style",
    "className",
    "getRootRef",
    "titleAfter",
    "getRef",
    "labelProps"
  ]);
  const platform3 = usePlatform();
  const { sizeY = "none" } = useAdaptivity();
  return React220.createElement(Tappable, _object_spread({
    Component: "label",
    style,
    className: classNames("vkuiRadio", sizeY !== "regular" && sizeYClassNames22[sizeY], className),
    activeEffectDelay: platform3 === "ios" ? 100 : DEFAULT_ACTIVE_EFFECT_DELAY,
    disabled: restProps.disabled,
    getRootRef
  }, labelProps), React220.createElement(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
    Component: "input",
    type: "radio",
    getRootRef: getRef,
    className: "vkuiRadio__input"
  })), React220.createElement("div", {
    className: "vkuiRadio__container"
  }, React220.createElement(RadioIcon, {
    className: "vkuiRadio__icon"
  }), React220.createElement("div", {
    className: "vkuiRadio__content"
  }, React220.createElement("div", {
    className: "vkuiRadio__title"
  }, React220.createElement(Text, null, children), React220.createElement("div", {
    className: "vkuiRadio__titleAfter"
  }, titleAfter)), hasReactNode(description) && React220.createElement(Footnote, {
    className: "vkuiRadio__description"
  }, description))));
};

// node_modules/@vkontakte/vkui/dist/components/RadioGroup/RadioGroup.js
var React221 = __toESM(require_react());
var RadioGroup = (_param) => {
  var { mode = "vertical" } = _param, restProps = _object_without_properties(_param, [
    "mode"
  ]);
  return React221.createElement(RootComponent, _object_spread({
    baseClassName: classNames("vkuiRadioGroup", "vkuiInternalRadioGroup", mode === "horizontal" && "vkuiRadioGroup--mode-horizontal")
  }, restProps));
};

// node_modules/@vkontakte/vkui/dist/components/Checkbox/Checkbox.js
var React222 = __toESM(require_react());
var sizeYClassNames23 = {
  none: "vkuiCheckbox--sizeY-none",
  ["compact"]: "vkuiCheckbox--sizeY-compact"
};
var warn20 = warnOnce("Checkbox");
var Checkbox = (_param) => {
  var { children, className, style, getRootRef, getRef, description, indeterminate, defaultIndeterminate, hoverMode, activeMode, hasHover: hasHover2, hasActive, focusVisibleMode, onChange, titleAfter } = _param, restProps = _object_without_properties(_param, [
    "children",
    "className",
    "style",
    "getRootRef",
    "getRef",
    "description",
    "indeterminate",
    "defaultIndeterminate",
    "hoverMode",
    "activeMode",
    "hasHover",
    "hasActive",
    "focusVisibleMode",
    "onChange",
    "titleAfter"
  ]);
  const inputRef = useExternRef(getRef);
  const platform3 = usePlatform();
  const { sizeY = "none" } = useAdaptivity();
  const { sizeY: adaptiveSizeY } = useAdaptivityConditionalRender();
  React222.useEffect(() => {
    const indeterminateValue = indeterminate === void 0 ? defaultIndeterminate : indeterminate;
    if (inputRef.current) {
      inputRef.current.indeterminate = Boolean(indeterminateValue);
    }
  }, [
    defaultIndeterminate,
    indeterminate,
    inputRef
  ]);
  const handleChange = React222.useCallback((event) => {
    if (defaultIndeterminate !== void 0 && indeterminate === void 0 && restProps.checked === void 0 && inputRef.current) {
      inputRef.current.indeterminate = false;
    }
    if (indeterminate !== void 0 && inputRef.current) {
      inputRef.current.indeterminate = indeterminate;
    }
    onChange && onChange(event);
  }, [
    defaultIndeterminate,
    indeterminate,
    restProps.checked,
    onChange,
    inputRef
  ]);
  if (true) {
    if (defaultIndeterminate && restProps.defaultChecked) {
      warn20("defaultIndeterminate и defaultChecked не могут быть true одновременно", "error");
    }
    if (indeterminate && restProps.checked) {
      warn20("indeterminate и checked не могут быть true одновременно", "error");
    }
    if (restProps.defaultChecked && restProps.checked) {
      warn20("defaultChecked и checked не могут быть true одновременно", "error");
    }
  }
  return React222.createElement(Tappable, {
    Component: "label",
    className: classNames("vkuiCheckbox", sizeY !== "regular" && sizeYClassNames23[sizeY], !(hasReactNode(children) || hasReactNode(description)) && "vkuiCheckbox--simple", className),
    style,
    disabled: restProps.disabled,
    activeEffectDelay: platform3 === "ios" ? 100 : DEFAULT_ACTIVE_EFFECT_DELAY,
    getRootRef,
    hoverMode,
    activeMode,
    hasHover: hasHover2,
    hasActive,
    focusVisibleMode
  }, React222.createElement(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
    Component: "input",
    type: "checkbox",
    onChange: handleChange,
    className: "vkuiCheckbox__input",
    getRootRef: inputRef
  })), React222.createElement("div", {
    className: classNames("vkuiCheckbox__icon", "vkuiCheckbox__icon--on")
  }, platform3 === "vkcom" ? React222.createElement(Icon20CheckBoxOn, null) : React222.createElement(React222.Fragment, null, adaptiveSizeY.compact && React222.createElement(Icon20CheckBoxOn, {
    className: adaptiveSizeY.compact.className
  }), adaptiveSizeY.regular && React222.createElement(Icon24CheckBoxOn, {
    className: adaptiveSizeY.regular.className
  }))), React222.createElement("div", {
    className: classNames("vkuiCheckbox__icon", "vkuiCheckbox__icon--off")
  }, platform3 === "vkcom" ? React222.createElement(Icon20CheckBoxOff, null) : React222.createElement(React222.Fragment, null, adaptiveSizeY.compact && React222.createElement(Icon20CheckBoxOff, {
    className: adaptiveSizeY.compact.className
  }), adaptiveSizeY.regular && React222.createElement(Icon24CheckBoxOff, {
    className: adaptiveSizeY.regular.className
  }))), React222.createElement("div", {
    className: classNames("vkuiCheckbox__icon", "vkuiCheckbox__icon--indeterminate")
  }, platform3 === "vkcom" ? React222.createElement(Icon20CheckBoxIndetermanate, {
    width: 20,
    height: 20
  }) : React222.createElement(React222.Fragment, null, adaptiveSizeY.compact && React222.createElement(Icon20CheckBoxIndetermanate, {
    className: adaptiveSizeY.compact.className,
    width: 20,
    height: 20
  }), adaptiveSizeY.regular && React222.createElement(Icon20CheckBoxIndetermanate, {
    className: adaptiveSizeY.regular.className,
    width: 24,
    height: 24
  }))), React222.createElement("div", {
    className: "vkuiCheckbox__content"
  }, React222.createElement("div", {
    className: "vkuiCheckbox__title"
  }, React222.createElement(Text, {
    className: "vkuiCheckbox__titleBefore"
  }, children), React222.createElement("div", {
    className: "vkuiCheckbox__titleAfter"
  }, titleAfter)), hasReactNode(description) && React222.createElement(Footnote, {
    className: "vkuiCheckbox__description"
  }, description)));
};

// node_modules/@vkontakte/vkui/dist/components/Select/Select.js
var React228 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelect.js
var React226 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelectClearButton.js
var React223 = __toESM(require_react());
var CustomSelectClearButton = (_param) => {
  var { className, onClick } = _param, restProps = _object_without_properties(_param, [
    "className",
    "onClick"
  ]);
  return React223.createElement(IconButton, _object_spread_props(_object_spread({
    Component: "button",
    label: "Очистить поле",
    onKeyDown: stopPropagation,
    type: "button",
    activeMode: "opacity",
    hoverMode: "opacity"
  }, restProps), {
    className,
    onClick: (e) => {
      stopPropagation(e);
      e.preventDefault();
      onClick();
    }
  }), React223.createElement(Icon16Cancel, null));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelectInput.js
var React225 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/SelectTypography/SelectTypography.js
var React224 = __toESM(require_react());
var SelectTypography = (_param) => {
  var { selectType = "default", children } = _param, restProps = _object_without_properties(_param, [
    "selectType",
    "children"
  ]);
  return React224.createElement(Text, _object_spread({
    weight: selectType === "accent" ? "2" : "3"
  }, restProps), children);
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelectInput.js
var sizeYClassNames24 = {
  none: "vkuiCustomSelectInput--sizeY-none",
  compact: "vkuiCustomSelectInput--sizeY-compact"
};
var CustomSelectInput = (_param) => {
  var { align = "left", getRef, className, getRootRef, style, before, after, status, children, placeholder, selectType = "default", multiline, disabled, fetching, labelTextTestId } = _param, restProps = _object_without_properties(_param, [
    "align",
    "getRef",
    "className",
    "getRootRef",
    "style",
    "before",
    "after",
    "status",
    "children",
    "placeholder",
    "selectType",
    "multiline",
    "disabled",
    "fetching",
    "labelTextTestId"
  ]);
  const { sizeY = "none" } = useAdaptivity();
  const title = children || placeholder;
  const showLabelOrPlaceholder = !Boolean(restProps.value);
  const handleRootRef = useExternRef(getRootRef);
  const focusWithin = useFocusWithin(handleRootRef);
  const input = React225.createElement(Text, _object_spread_props(_object_spread({
    type: "text"
  }, restProps), {
    disabled: disabled && !fetching,
    readOnly: restProps.readOnly || disabled && fetching,
    Component: "input",
    normalize: false,
    className: classNames("vkuiCustomSelectInput__el", (restProps.readOnly || showLabelOrPlaceholder && !focusWithin) && "vkuiCustomSelectInput__el--cursor-pointer"),
    getRootRef: getRef,
    placeholder: children ? "" : placeholder
  }));
  const platform3 = usePlatform();
  return React225.createElement(FormField, {
    Component: "div",
    style,
    className: classNames("vkuiCustomSelectInput", align === "right" && "vkuiCustomSelectInput--align-right", align === "center" && "vkuiCustomSelectInput--align-center", !children && "vkuiCustomSelectInput--empty", multiline && "vkuiCustomSelectInput--multiline", sizeY !== "regular" && sizeYClassNames24[sizeY], before && "vkuiCustomSelectInput--hasBefore", after && "vkuiCustomSelectInput--hasAfter", className),
    getRootRef: handleRootRef,
    before,
    after,
    disabled,
    mode: getFormFieldModeFromSelectType(selectType),
    status
  }, React225.createElement("div", {
    className: "vkuiCustomSelectInput__input-group"
  }, React225.createElement("div", {
    className: classNames("vkuiCustomSelectInput__container", className),
    tabIndex: -1,
    "aria-hidden": true,
    "data-testid": labelTextTestId
  }, React225.createElement(SelectTypography, {
    selectType,
    className: "vkuiCustomSelectInput__title"
  }, showLabelOrPlaceholder && title)), restProps.readOnly && platform3 === "ios" ? React225.createElement(VisuallyHidden, null, input) : input));
};

// node_modules/@vkontakte/vkui/dist/components/CustomSelect/CustomSelect.js
var sizeYClassNames25 = {
  none: "vkuiCustomSelect--sizeY-none",
  ["compact"]: "vkuiCustomSelect--sizeY-compact"
};
var findIndexAfter2 = (options = [], startIndex = -1) => {
  if (startIndex >= options.length - 1) {
    return -1;
  }
  return options.findIndex((option, i) => i > startIndex && !option.disabled);
};
var findIndexBefore2 = (options = [], endIndex = options.length) => {
  let result = -1;
  if (endIndex <= 0) {
    return result;
  }
  for (let i = endIndex - 1; i >= 0; i--) {
    let option = options[i];
    if (!option.disabled) {
      result = i;
      break;
    }
  }
  return result;
};
var warn21 = warnOnce("CustomSelect");
var checkOptionsValueType = (options) => {
  if (new Set(options.map((item) => typeof item.value)).size > 1) {
    warn21("Некоторые значения ваших опций имеют разные типы. onChange всегда возвращает строковый тип.", "error");
  }
};
function defaultRenderOptionFn(_param) {
  var { option } = _param, props = _object_without_properties(_param, [
    "option"
  ]);
  return React226.createElement(CustomSelectOption, props);
}
var handleOptionDown = (e) => {
  e.preventDefault();
};
function findSelectedIndex(options = [], value, withClear) {
  if (withClear && value === "") {
    return -1;
  }
  var _options_findIndex;
  return (_options_findIndex = options.findIndex((item) => {
    value = typeof item.value === "number" ? Number(value) : value;
    return item.value === value;
  })) !== null && _options_findIndex !== void 0 ? _options_findIndex : -1;
}
var filter = (options, inputValue, filterFn) => {
  return typeof filterFn === "function" ? options.filter((option) => filterFn(inputValue, option)) : options;
};
var defaultOptions2 = [];
function CustomSelect(props) {
  const [opened, setOpened] = React226.useState(false);
  const { before, name, className, getRef, getRootRef, popupDirection, style, onChange, children, onInputChange: onInputChangeProp, renderDropdown, onOpen, onClose, fetching, forceDropdownPortal, selectType = "default", autoHideScrollbar, autoHideScrollbarDelay, searchable = false, renderOption: renderOptionProp = defaultRenderOptionFn, options: optionsProp = defaultOptions2, emptyText = "Ничего не найдено", filterFn = defaultFilterFn, icon: iconProp, ClearButton = CustomSelectClearButton, allowClearButton = false, dropdownOffsetDistance = 0, dropdownAutoWidth = false, noMaxHeight = false, ["aria-labelledby"]: ariaLabelledBy, clearButtonTestId, nativeSelectTestId, defaultValue, required } = props, restProps = _object_without_properties(props, [
    "before",
    "name",
    "className",
    "getRef",
    "getRootRef",
    "popupDirection",
    "style",
    "onChange",
    "children",
    "onInputChange",
    "renderDropdown",
    "onOpen",
    "onClose",
    "fetching",
    "forceDropdownPortal",
    "selectType",
    "autoHideScrollbar",
    "autoHideScrollbarDelay",
    "searchable",
    "renderOption",
    "options",
    "emptyText",
    "filterFn",
    "icon",
    "ClearButton",
    "allowClearButton",
    "dropdownOffsetDistance",
    "dropdownAutoWidth",
    "noMaxHeight",
    "aria-labelledby",
    "clearButtonTestId",
    "nativeSelectTestId",
    "defaultValue",
    "required"
  ]);
  if (true) {
    checkOptionsValueType(optionsProp);
  }
  const { sizeY = "none" } = useAdaptivity();
  const containerRef = React226.useRef(null);
  const handleRootRef = useExternRef(containerRef, getRootRef);
  const scrollBoxRef = React226.useRef(null);
  const selectElRef = useExternRef(getRef);
  const [focusedOptionIndex, setFocusedOptionIndex] = React226.useState(-1);
  const [isControlledOutside, setIsControlledOutside] = React226.useState(props.value !== void 0);
  const [inputValue, setInputValue] = React226.useState("");
  const [nativeSelectValue, setNativeSelectValue] = React226.useState(() => {
    var _props_value2, _ref;
    return (_ref = (_props_value2 = props.value) !== null && _props_value2 !== void 0 ? _props_value2 : defaultValue) !== null && _ref !== void 0 ? _ref : allowClearButton ? "" : void 0;
  });
  const [popperPlacement, setPopperPlacement] = React226.useState(void 0);
  const [options, setOptions] = React226.useState(optionsProp);
  var _props_value;
  const [selectedOptionIndex, setSelectedOptionIndex] = React226.useState(findSelectedIndex(optionsProp, (_props_value = props.value) !== null && _props_value !== void 0 ? _props_value : defaultValue, allowClearButton));
  React226.useEffect(() => {
    setIsControlledOutside(props.value !== void 0);
    setNativeSelectValue((nativeSelectValue2) => {
      var _props_value2;
      return (_props_value2 = props.value) !== null && _props_value2 !== void 0 ? _props_value2 : nativeSelectValue2;
    });
  }, [
    props.value
  ]);
  useIsomorphicLayoutEffect(() => {
    if (options.some(({ value }) => nativeSelectValue === value) || allowClearButton && nativeSelectValue === "") {
      var _selectElRef_current;
      const event = new Event("change", {
        bubbles: true
      });
      (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
    }
  }, [
    nativeSelectValue
  ]);
  const selected = React226.useMemo(() => {
    if (!options.length) {
      return null;
    }
    return selectedOptionIndex !== void 0 ? options[selectedOptionIndex] : void 0;
  }, [
    options,
    selectedOptionIndex
  ]);
  const openedClassNames = React226.useMemo(() => opened && dropdownOffsetDistance === 0 && ((popperPlacement === null || popperPlacement === void 0 ? void 0 : popperPlacement.includes("top")) ? "vkuiCustomSelect--pop-up" : "vkuiCustomSelect--pop-down") || void 0, [
    dropdownOffsetDistance,
    opened,
    popperPlacement
  ]);
  const scrollToElement = React226.useCallback((index2, center = false) => {
    const dropdown = scrollBoxRef.current;
    const item = dropdown ? dropdown.children[index2] : null;
    if (!item || !dropdown) {
      return;
    }
    const dropdownHeight = dropdown.offsetHeight;
    const scrollTop = dropdown.scrollTop;
    const itemTop = item.offsetTop;
    const itemHeight = item.offsetHeight;
    if (center) {
      dropdown.scrollTop = itemTop - dropdownHeight / 2 + itemHeight / 2;
    } else if (itemTop + itemHeight > dropdownHeight + scrollTop) {
      dropdown.scrollTop = itemTop - dropdownHeight + itemHeight;
    } else if (itemTop < scrollTop) {
      dropdown.scrollTop = itemTop;
    }
  }, []);
  const focusOptionByIndex = React226.useCallback((index2, scrollTo = true) => {
    var _options_length;
    if (index2 === void 0 || index2 < 0 || index2 > ((_options_length = options.length) !== null && _options_length !== void 0 ? _options_length : 0) - 1) {
      return;
    }
    const option = options[index2];
    if (option === null || option === void 0 ? void 0 : option.disabled) {
      return;
    }
    if (scrollTo) {
      scrollToElement(index2);
    }
    setFocusedOptionIndex((focusedOptionIndex2) => focusedOptionIndex2 !== index2 ? index2 : focusedOptionIndex2);
  }, [
    options,
    scrollToElement
  ]);
  const isValidIndex = React226.useCallback((index2) => {
    var _options_length;
    return index2 >= 0 && index2 < ((_options_length = options.length) !== null && _options_length !== void 0 ? _options_length : 0);
  }, [
    options.length
  ]);
  const setScrollBoxRef = React226.useCallback((ref) => {
    scrollBoxRef.current = ref;
    if (ref && selectedOptionIndex !== void 0 && isValidIndex(selectedOptionIndex)) {
      {
        scrollToElement(selectedOptionIndex, true);
      }
    }
  }, [
    isValidIndex,
    scrollToElement,
    selectedOptionIndex
  ]);
  const [keyboardInput, setKeyboardInput] = React226.useState("");
  const resetKeyboardInput = React226.useCallback(() => {
    setKeyboardInput("");
  }, []);
  const resetFocusedOption = React226.useCallback(() => {
    setFocusedOptionIndex(-1);
  }, []);
  const onKeyboardInput = React226.useCallback((key) => {
    if (!opened) {
      setOpened(true);
    }
    resetFocusedOption();
    const fullInput = keyboardInput + key;
    setKeyboardInput(fullInput);
  }, [
    keyboardInput,
    opened,
    resetFocusedOption
  ]);
  const close = React226.useCallback(() => {
    resetKeyboardInput();
    setInputValue("");
    setOpened(false);
    resetFocusedOption();
    onClose === null || onClose === void 0 ? void 0 : onClose();
  }, [
    onClose,
    resetKeyboardInput,
    resetFocusedOption
  ]);
  const selectOption = React226.useCallback((index2) => {
    const item = options[index2];
    setNativeSelectValue(item === null || item === void 0 ? void 0 : item.value);
    close();
    const shouldTriggerOnChangeWhenControlledAndInnerValueIsOutOfSync = isControlledOutside && props.value !== nativeSelectValue && nativeSelectValue === (item === null || item === void 0 ? void 0 : item.value);
    if (shouldTriggerOnChangeWhenControlledAndInnerValueIsOutOfSync) {
      var _selectElRef_current;
      const event = new Event("change", {
        bubbles: true
      });
      (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
    }
  }, [
    close,
    options,
    selectElRef,
    isControlledOutside,
    props.value,
    nativeSelectValue
  ]);
  const selectFocused = React226.useCallback(() => {
    if (focusedOptionIndex === void 0 || !isValidIndex(focusedOptionIndex)) {
      return;
    }
    selectOption(focusedOptionIndex);
  }, [
    focusedOptionIndex,
    isValidIndex,
    selectOption
  ]);
  const open = React226.useCallback(() => {
    setOpened(true);
    setFocusedOptionIndex(selectedOptionIndex);
    if (typeof onOpen === "function") {
      onOpen();
    }
  }, [
    onOpen,
    selectedOptionIndex
  ]);
  const onBlur = React226.useCallback(() => {
    var _selectElRef_current;
    close();
    const event = new Event("focusout", {
      bubbles: true
    });
    (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
  }, [
    close,
    selectElRef
  ]);
  const onFocus = React226.useCallback(() => {
    var _selectElRef_current;
    const event = new Event("focusin", {
      bubbles: true
    });
    (_selectElRef_current = selectElRef.current) === null || _selectElRef_current === void 0 ? void 0 : _selectElRef_current.dispatchEvent(event);
  }, [
    selectElRef
  ]);
  const onClick = React226.useCallback(() => {
    if (opened) {
      close();
    } else {
      open();
    }
  }, [
    close,
    open,
    opened
  ]);
  const handleKeyUp = React226.useMemo(() => debounce2(resetKeyboardInput, 1e3), [
    resetKeyboardInput
  ]);
  const focusOption = React226.useCallback((type) => {
    let index2 = focusedOptionIndex;
    if (type === "next") {
      const nextIndex = findIndexAfter2(options, index2);
      index2 = nextIndex === -1 ? findIndexAfter2(options) : nextIndex;
    } else if (type === "prev") {
      const beforeIndex = findIndexBefore2(options, index2);
      index2 = beforeIndex === -1 ? findIndexBefore2(options) : beforeIndex;
    }
    focusOptionByIndex(index2);
  }, [
    focusOptionByIndex,
    focusedOptionIndex,
    options
  ]);
  React226.useEffect(function updateOptionsAndSelectedOptionIndex() {
    var _props_value2, _ref;
    const value = (_ref = (_props_value2 = props.value) !== null && _props_value2 !== void 0 ? _props_value2 : nativeSelectValue) !== null && _ref !== void 0 ? _ref : defaultValue;
    const options2 = searchable && inputValue !== void 0 ? filter(optionsProp, inputValue, filterFn) : optionsProp;
    setOptions(options2);
    setSelectedOptionIndex(findSelectedIndex(options2, value, allowClearButton));
  }, [
    filterFn,
    inputValue,
    nativeSelectValue,
    optionsProp,
    defaultValue,
    props.value,
    searchable,
    allowClearButton
  ]);
  const onNativeSelectChange = (e) => {
    const newSelectedOptionIndex = findSelectedIndex(options, e.currentTarget.value, allowClearButton);
    if (selectedOptionIndex !== newSelectedOptionIndex) {
      if (!isControlledOutside) {
        setSelectedOptionIndex(newSelectedOptionIndex);
      }
      onChange === null || onChange === void 0 ? void 0 : onChange(e);
    }
  };
  const onInputChange = React226.useCallback((e) => {
    onInputChangeProp && onInputChangeProp(e);
    const options2 = filter(optionsProp, e.target.value, filterFn);
    setOptions(options2);
    setSelectedOptionIndex(findSelectedIndex(options2, nativeSelectValue, allowClearButton));
    setInputValue(e.target.value);
  }, [
    filterFn,
    nativeSelectValue,
    onInputChangeProp,
    optionsProp,
    allowClearButton
  ]);
  const areOptionsShown = React226.useCallback(() => {
    return scrollBoxRef.current !== null;
  }, []);
  const handleKeyDownSelect = React226.useCallback((event) => {
    if (event.key.length === 1 && event.key !== " ") {
      onKeyboardInput(event.key);
      return;
    }
    [
      "ArrowUp",
      "ArrowDown",
      "Escape",
      "Enter"
    ].includes(event.key) && areOptionsShown() && event.preventDefault();
    switch (event.key) {
      case "ArrowUp":
        if (opened) {
          areOptionsShown() && focusOption("prev");
        } else {
          open();
        }
        break;
      case "ArrowDown":
        if (opened) {
          areOptionsShown() && focusOption("next");
        } else {
          open();
        }
        break;
      case "Escape":
        close();
        break;
      case "Backspace":
      case "Delete": {
        if (!opened) {
          setOpened(true);
        }
        resetFocusedOption();
        break;
      }
      case "Enter":
      case "Spacebar":
      case " ":
        if (opened) {
          areOptionsShown() && selectFocused();
        } else {
          open();
        }
        break;
    }
  }, [
    areOptionsShown,
    close,
    focusOption,
    onKeyboardInput,
    open,
    opened,
    selectFocused,
    resetFocusedOption
  ]);
  const handleOptionClick = React226.useCallback((e) => {
    var _e_currentTarget_parentNode;
    const index2 = Array.prototype.indexOf.call((_e_currentTarget_parentNode = e.currentTarget.parentNode) === null || _e_currentTarget_parentNode === void 0 ? void 0 : _e_currentTarget_parentNode.children, e.currentTarget);
    const option = options[index2];
    if (option && !option.disabled) {
      selectOption(index2);
    }
  }, [
    options,
    selectOption
  ]);
  const prevMousePositionRef = React226.useRef({
    x: 0,
    y: 0
  });
  const focusOptionOnMouseMove = React226.useCallback((e) => {
    const isMouseChangedPosition = Math.abs(prevMousePositionRef.current.x - e.clientX) >= 1 || Math.abs(prevMousePositionRef.current.y - e.clientY) >= 1;
    if (isMouseChangedPosition) {
      var _e_currentTarget_parentNode;
      focusOptionByIndex(Array.prototype.indexOf.call((_e_currentTarget_parentNode = e.currentTarget.parentNode) === null || _e_currentTarget_parentNode === void 0 ? void 0 : _e_currentTarget_parentNode.children, e.currentTarget), false);
    }
    prevMousePositionRef.current = {
      x: e.clientX,
      y: e.clientY
    };
  }, [
    focusOptionByIndex
  ]);
  const popupAriaId = React226.useId();
  const renderOption = React226.useCallback((option, index2) => {
    const hovered = index2 === focusedOptionIndex;
    const selected2 = index2 === selectedOptionIndex;
    return React226.createElement(React226.Fragment, {
      key: `${option.value}`
    }, renderOptionProp({
      option,
      hovered,
      children: option.label,
      selected: selected2,
      disabled: option.disabled,
      onClick: handleOptionClick,
      onMouseDown: handleOptionDown,
      // Используем `onMouseMove` вместо `onMouseEnter/onMouseOver`.
      // Потому что если при навигации с клавиатуры курсор наведён на
      // список, то при первом автоматическом скролле списка вызывается событие MouseOver/MouseEnter
      // обработчик которого фокусирует опцию под курсором, хотя при навигация с клавиатуры пользователь мог уйти дальше по списку, это путает.
      // Причём координаты события меняются на пару пикселей по сравнению с прошлым вызовом,
      // а значит нельзя на них опираться, чтобы запретить обработку такого события.
      // C mousemove такой проблемы нет, что позволяет реализовать поведение при наведении с клавиатуры и при наведении мышью идентично `<select>`.
      onMouseMove: focusOptionOnMouseMove,
      id: `${popupAriaId}-${option.value}`
    }));
  }, [
    focusedOptionIndex,
    handleOptionClick,
    focusOptionOnMouseMove,
    renderOptionProp,
    selectedOptionIndex,
    popupAriaId
  ]);
  const resolvedContent = React226.useMemo(() => {
    const defaultDropdownContent = (options === null || options === void 0 ? void 0 : options.length) > 0 ? options.map(renderOption) : React226.createElement(Footnote, {
      className: "vkuiCustomSelect__empty"
    }, emptyText);
    if (typeof renderDropdown === "function") {
      return renderDropdown({
        defaultDropdownContent
      });
    } else {
      return defaultDropdownContent;
    }
  }, [
    emptyText,
    options,
    renderDropdown,
    renderOption
  ]);
  const selectInputRef = React226.useRef(null);
  const focusOnInputTimerRef = React226.useRef();
  const focusOnInput = React226.useCallback(() => {
    clearTimeout(focusOnInputTimerRef.current);
    focusOnInputTimerRef.current = setTimeout(() => {
      selectInputRef.current && selectInputRef.current.focus();
    }, 0);
  }, []);
  useIsomorphicLayoutEffect(function clearFocusOnInputTimer() {
    return () => {
      clearTimeout(focusOnInputTimerRef.current);
    };
  }, []);
  const controlledValueSet = isControlledOutside && props.value !== "";
  const uncontrolledValueSet = !isControlledOutside && nativeSelectValue !== "";
  const clearButtonShown = allowClearButton && !opened && (controlledValueSet || uncontrolledValueSet);
  const clearButton = React226.useMemo(() => {
    if (!clearButtonShown) {
      return null;
    }
    return React226.createElement(ClearButton, {
      className: iconProp === void 0 ? "vkuiCustomSelect--clear-icon" : void 0,
      onClick: function clearSelectState() {
        setNativeSelectValue("");
        setInputValue("");
        focusOnInput();
      },
      disabled: restProps.disabled,
      "data-testid": clearButtonTestId
    });
  }, [
    clearButtonShown,
    ClearButton,
    iconProp,
    restProps.disabled,
    clearButtonTestId,
    focusOnInput
  ]);
  const icon = React226.useMemo(() => {
    if (iconProp !== void 0) {
      return iconProp;
    }
    return React226.createElement(DropdownIcon, {
      className: clearButtonShown ? "vkuiCustomSelect__dropdown-icon" : void 0,
      opened
    });
  }, [
    clearButtonShown,
    iconProp,
    opened
  ]);
  const afterIcons = (icon || clearButtonShown) && React226.createElement(React226.Fragment, null, clearButton, icon);
  const { document: document2 } = useDOM();
  const passClickAndFocusToInputOnClick = React226.useCallback((e) => {
    if (!selectInputRef.current || !document2) {
      return;
    }
    const clickTargetIsNotAnInput = e.target !== selectInputRef.current;
    if (clickTargetIsNotAnInput) {
      selectInputRef.current.click();
      const inputIsNotFocused = document2.activeElement !== selectInputRef.current;
      if (inputIsNotFocused) {
        focusOnInput();
      }
    }
  }, [
    document2,
    focusOnInput
  ]);
  const preventInputBlurWhenClickInsideFocusedSelectArea = (e) => {
    const isInputFocused = document2 && document2.activeElement === selectInputRef.current;
    if (isInputFocused) {
      e.preventDefault();
    }
  };
  const ariaActiveDescendantOptionIndex = focusedOptionIndex !== -1 ? focusedOptionIndex : void 0;
  const ariaActiveDescendantId = ariaActiveDescendantOptionIndex !== void 0 ? options[ariaActiveDescendantOptionIndex] && options[ariaActiveDescendantOptionIndex].value : null;
  const selectInputAriaProps = {
    "role": "combobox",
    "aria-controls": popupAriaId,
    "aria-owns": popupAriaId,
    "aria-expanded": opened,
    ["aria-activedescendant"]: ariaActiveDescendantId && opened ? `${popupAriaId}-${ariaActiveDescendantId}` : void 0,
    "aria-labelledby": ariaLabelledBy,
    "aria-haspopup": "listbox",
    "aria-autocomplete": "none"
  };
  const focusWithin = useFocusWithin(handleRootRef);
  return React226.createElement("div", {
    className: classNames("vkuiCustomSelect", sizeY !== "regular" && sizeYClassNames25[sizeY], className),
    style,
    ref: handleRootRef,
    onClick: passClickAndFocusToInputOnClick,
    onMouseDown: preventInputBlurWhenClickInsideFocusedSelectArea
  }, focusWithin && selected && !opened && React226.createElement(VisuallyHidden, {
    "aria-live": "polite"
  }, selected.label), React226.createElement(CustomSelectInput, _object_spread_props(_object_spread({
    autoComplete: "off",
    autoCapitalize: "none",
    autoCorrect: "off",
    spellCheck: "false"
  }, restProps, selectInputAriaProps), {
    getRef: selectInputRef,
    onFocus,
    onBlur,
    className: openedClassNames,
    readOnly: !searchable,
    fetching,
    value: inputValue,
    onKeyUp: handleKeyUp,
    onKeyDown: handleKeyDownSelect,
    onChange: onInputChange,
    onClick,
    before,
    after: afterIcons,
    selectType
  }), selected === null || selected === void 0 ? void 0 : selected.label), React226.createElement("select", {
    ref: selectElRef,
    name,
    onChange: onNativeSelectChange,
    onBlur: props.onBlur,
    onFocus: props.onFocus,
    onClick: props.onClick,
    value: nativeSelectValue,
    "aria-hidden": true,
    className: "vkuiCustomSelect__control",
    "data-testid": nativeSelectTestId,
    required
  }, allowClearButton && React226.createElement("option", {
    key: "",
    value: ""
  }), optionsProp.map((item) => React226.createElement("option", {
    key: `${item.value}`,
    value: item.value
  }))), opened && React226.createElement(CustomSelectDropdown, {
    targetRef: containerRef,
    placement: popupDirection,
    scrollBoxRef: setScrollBoxRef,
    onPlacementChange: setPopperPlacement,
    onMouseLeave: resetFocusedOption,
    fetching,
    offsetDistance: dropdownOffsetDistance,
    autoWidth: dropdownAutoWidth,
    forcePortal: forceDropdownPortal,
    autoHideScrollbar,
    autoHideScrollbarDelay,
    noMaxHeight,
    role: "listbox",
    id: popupAriaId,
    "aria-labelledby": ariaLabelledBy,
    tabIndex: -1
  }, resolvedContent));
}

// node_modules/@vkontakte/vkui/dist/components/NativeSelect/NativeSelect.js
var React227 = __toESM(require_react());
var sizeYClassNames26 = {
  none: "vkuiSelect--sizeY-none",
  ["compact"]: "vkuiSelect--sizeY-compact"
};
var NativeSelect = (_param) => {
  var { style, align, placeholder, children, className, getRef, getRootRef, disabled, multiline, selectType = "default", status, icon = React227.createElement(DropdownIcon, null), before, onChange } = _param, restProps = _object_without_properties(_param, [
    "style",
    "align",
    "placeholder",
    "children",
    "className",
    "getRef",
    "getRootRef",
    "disabled",
    "multiline",
    "selectType",
    "status",
    "icon",
    "before",
    "onChange"
  ]);
  const [title, setTitle] = React227.useState("");
  const [empty, setEmpty] = React227.useState(false);
  const selectRef = useExternRef(getRef);
  const { sizeY = "none" } = useAdaptivity();
  const checkSelectedOption = () => {
    var _selectRef_current;
    const selectedOption = (_selectRef_current = selectRef.current) === null || _selectRef_current === void 0 ? void 0 : _selectRef_current.options[selectRef.current.selectedIndex];
    if (selectedOption) {
      setTitle(selectedOption.text);
      setEmpty(selectedOption.value === "" && placeholder != null);
    }
  };
  useIsomorphicLayoutEffect(checkSelectedOption, [
    children
  ]);
  return React227.createElement(FormField, {
    Component: "div",
    className: classNames("vkuiSelect", "vkuiInternalNativeSelect", before && "vkuiSelect--hasBefore", empty && "vkuiSelect--empty", multiline && "vkuiSelect--multiline", align === "center" && "vkuiSelect--align-center", align === "right" && "vkuiSelect--align-right", sizeY !== "regular" && sizeYClassNames26[sizeY], className),
    style,
    getRootRef,
    disabled,
    before,
    after: icon,
    status,
    mode: getFormFieldModeFromSelectType(selectType)
  }, React227.createElement("select", _object_spread_props(_object_spread({}, restProps), {
    disabled,
    className: "vkuiSelect__el",
    onChange: callMultiple(onChange, checkSelectedOption),
    ref: selectRef
  }), placeholder && React227.createElement("option", {
    value: ""
  }, placeholder), children), React227.createElement("div", {
    className: "vkuiSelect__container",
    "aria-hidden": true
  }, React227.createElement(SelectTypography, {
    className: "vkuiSelect__title",
    selectType
  }, title)));
};

// node_modules/@vkontakte/vkui/dist/components/Select/Select.js
var Select = (_param) => {
  var { children } = _param, props = _object_without_properties(_param, [
    "children"
  ]);
  const { options = [], searchable, emptyText, onInputChange, filterFn, popupDirection, renderOption, renderDropdown, fetching, onClose, onOpen, icon, ClearButton, allowClearButton, clearButtonTestId, dropdownOffsetDistance, dropdownAutoWidth, forceDropdownPortal, noMaxHeight, autoHideScrollbar, autoHideScrollbarDelay, labelTextTestId, nativeSelectTestId, after, mode } = props, restProps = _object_without_properties(props, [
    "options",
    "searchable",
    "emptyText",
    "onInputChange",
    "filterFn",
    "popupDirection",
    "renderOption",
    "renderDropdown",
    "fetching",
    "onClose",
    "onOpen",
    "icon",
    "ClearButton",
    "allowClearButton",
    "clearButtonTestId",
    "dropdownOffsetDistance",
    "dropdownAutoWidth",
    "forceDropdownPortal",
    "noMaxHeight",
    "autoHideScrollbar",
    "autoHideScrollbarDelay",
    "labelTextTestId",
    "nativeSelectTestId",
    "after",
    "mode"
  ]);
  const hasPointer = useAdaptivityHasPointer();
  const nativeProps = restProps;
  return React228.createElement(React228.Fragment, null, (hasPointer === void 0 || hasPointer) && React228.createElement(CustomSelect, props), (hasPointer === void 0 || !hasPointer) && React228.createElement(NativeSelect, nativeProps, options.map(({ label, value }) => React228.createElement("option", {
    value,
    key: `${value}`
  }, label))));
};

// node_modules/@vkontakte/vkui/dist/components/SelectMimicry/SelectMimicry.js
var React230 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAutoFocus.js
var React229 = __toESM(require_react());
function useAutoFocus(ref, autoFocus) {
  useIsomorphicLayoutEffect(() => {
    if (!autoFocus || !ref.current) {
      return;
    }
    ref.current.focus();
  }, []);
}

// node_modules/@vkontakte/vkui/dist/components/SelectMimicry/SelectMimicry.js
var sizeYClassNames27 = {
  none: "vkuiSelect--sizeY-none",
  ["compact"]: "vkuiSelect--sizeY-compact"
};
var SelectMimicry = (_param) => {
  var { tabIndex = 0, placeholder, children, align, getRootRef, multiline, disabled, onClick, before, after = React230.createElement(DropdownIcon, null), selectType = "default", status, className, autoFocus } = _param, restProps = _object_without_properties(_param, [
    "tabIndex",
    "placeholder",
    "children",
    "align",
    "getRootRef",
    "multiline",
    "disabled",
    "onClick",
    "before",
    "after",
    "selectType",
    "status",
    "className",
    "autoFocus"
  ]);
  const rootRef = useExternRef(getRootRef);
  const { sizeY = "none" } = useAdaptivity();
  const title = children || placeholder;
  useAutoFocus(rootRef, autoFocus);
  return React230.createElement(FormField, _object_spread_props(_object_spread({}, restProps), {
    tabIndex: disabled ? void 0 : tabIndex,
    className: classNames("vkuiSelect", sizeY !== "regular" && sizeYClassNames27[sizeY], !children && "vkuiSelect--empty", multiline && "vkuiSelect--multiline", align === "center" && "vkuiSelect--align-center", align === "right" && "vkuiSelect--align-right", before && "vkuiSelect--hasBefore", className),
    getRootRef: rootRef,
    onClick: disabled ? void 0 : onClick,
    disabled,
    before,
    after,
    mode: getFormFieldModeFromSelectType(selectType),
    status
  }), React230.createElement("div", {
    className: "vkuiSelect__container"
  }, React230.createElement(SelectTypography, {
    selectType,
    className: "vkuiSelect__title"
  }, title)));
};

// node_modules/@vkontakte/vkui/dist/components/DatePicker/DatePicker.js
var React231 = __toESM(require_react());
var DefaultMonths = [
  "Января",
  "Февраля",
  "Марта",
  "Апреля",
  "Мая",
  "Июня",
  "Июля",
  "Августа",
  "Сентября",
  "Октября",
  "Ноября",
  "Декабря"
];
function convertToInputFormat({ day = 0, month = 0, year = 0 }) {
  return `${year}-${leadingZero(month)}-${leadingZero(day)}`;
}
function parseInputDate(date) {
  const splited = date.split("-");
  return {
    day: Number(splited[2]),
    month: Number(splited[1]),
    year: Number(splited[0])
  };
}
function getMonthMaxDay(month, year) {
  return month ? new Date(year || 2016, month, 0).getDate() : 31;
}
var DatePickerCustom = (_param) => {
  var { name, min: min2 = {
    day: 0,
    month: 0,
    year: 0
  }, max: max2 = {
    day: 31,
    month: 12,
    year: 2100
  }, dayPlaceholder, monthPlaceholder, yearPlaceholder, popupDirection, defaultValue, monthNames, day = 0, month = 0, year = 0, onDateChange, disabled } = _param, restProps = _object_without_properties(_param, [
    "name",
    "min",
    "max",
    "dayPlaceholder",
    "monthPlaceholder",
    "yearPlaceholder",
    "popupDirection",
    "defaultValue",
    "monthNames",
    "day",
    "month",
    "year",
    "onDateChange",
    "disabled"
  ]);
  const onSelectChange = (e) => {
    onDateChange === null || onDateChange === void 0 ? void 0 : onDateChange({
      day,
      month,
      year,
      [e.target.name]: Number(e.target.value)
    });
  };
  const dayOptions = range(1, getMonthMaxDay(month, year)).map((value) => ({
    label: String(value),
    value
  }));
  const monthOptions = (monthNames || DefaultMonths).map((name2, index2) => ({
    label: name2,
    value: index2 + 1
  }));
  const yearOptions = range(max2.year, min2.year).map((value) => ({
    label: String(value),
    value
  }));
  return React231.createElement(RootComponent, _object_spread({
    baseClassName: "vkuiDatePicker"
  }, restProps), React231.createElement("div", {
    className: "vkuiDatePicker__container"
  }, React231.createElement("div", {
    className: "vkuiDatePicker__day"
  }, React231.createElement(CustomSelect, {
    name: "day",
    value: day,
    options: dayOptions,
    placeholder: dayPlaceholder,
    popupDirection,
    onChange: onSelectChange,
    disabled
  })), React231.createElement("div", {
    className: "vkuiDatePicker__month"
  }, React231.createElement(CustomSelect, {
    className: "vkuiDatePicker__monthSelect",
    name: "month",
    value: month,
    options: monthOptions,
    placeholder: monthPlaceholder,
    popupDirection,
    onChange: onSelectChange,
    disabled
  })), React231.createElement("div", {
    className: "vkuiDatePicker__year"
  }, React231.createElement(CustomSelect, {
    name: "year",
    value: year,
    options: yearOptions,
    placeholder: yearPlaceholder,
    popupDirection,
    onChange: onSelectChange,
    disabled
  }))), React231.createElement("input", {
    type: "hidden",
    name,
    value: convertToInputFormat({
      day,
      month,
      year
    })
  }));
};
var DatePickerNative = (_param) => {
  var { min: min2 = {
    day: 0,
    month: 0,
    year: 0
  }, max: max2 = {
    day: 31,
    month: 12,
    year: 2100
  }, monthNames, popupDirection, dayPlaceholder, monthPlaceholder, yearPlaceholder, defaultValue, day, month, year, onDateChange } = _param, restProps = _object_without_properties(_param, [
    "min",
    "max",
    "monthNames",
    "popupDirection",
    "dayPlaceholder",
    "monthPlaceholder",
    "yearPlaceholder",
    "defaultValue",
    "day",
    "month",
    "year",
    "onDateChange"
  ]);
  const defProps = day && month && year ? {
    defaultValue: convertToInputFormat({
      day,
      month,
      year
    })
  } : {};
  const onStringChange = React231.useCallback((e) => {
    onDateChange === null || onDateChange === void 0 ? void 0 : onDateChange(parseInputDate(e.currentTarget.value));
  }, [
    onDateChange
  ]);
  const inputProps = restProps;
  return React231.createElement(Input, _object_spread(_object_spread_props(_object_spread({}, inputProps), {
    type: "date",
    onChange: onStringChange,
    min: convertToInputFormat(min2),
    max: convertToInputFormat(max2)
  }), defProps));
};
var DatePicker = (_param) => {
  var { defaultValue } = _param, props = _object_without_properties(_param, [
    "defaultValue"
  ]);
  const hasPointer = useAdaptivityHasPointer();
  const [value, setValue] = React231.useState(() => ({
    day: (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.day) || 0,
    month: (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.month) || 0,
    year: (defaultValue === null || defaultValue === void 0 ? void 0 : defaultValue.year) || 0
  }));
  const onDateChange = React231.useCallback((update) => {
    setValue(update);
    props.onDateChange && props.onDateChange(_object_spread({}, update));
  }, [
    props
  ]);
  const Cmp = hasPointer ? DatePickerCustom : DatePickerNative;
  return React231.createElement(Cmp, _object_spread_props(_object_spread({}, props, value), {
    onDateChange
  }));
};

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControl.js
var React233 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControlOption/SegmentedControlOption.js
var React232 = __toESM(require_react());
var SegmentedControlOption = (_param) => {
  var { getRef, className, style, children, getRootRef, before } = _param, restProps = _object_without_properties(_param, [
    "getRef",
    "className",
    "style",
    "children",
    "getRootRef",
    "before"
  ]);
  const { focusVisible, onBlur, onFocus } = useFocusVisible();
  const focusVisibleClassNames = useFocusVisibleClassName({
    focusVisible
  });
  return React232.createElement("label", {
    className: classNames("vkuiSegmentedControlOption", restProps.checked && "vkuiSegmentedControlOption--checked", focusVisibleClassNames, className),
    ref: getRootRef,
    style
  }, React232.createElement(VisuallyHidden, _object_spread_props(_object_spread({}, restProps), {
    Component: "input",
    getRootRef: getRef,
    type: "radio",
    onBlur: callMultiple(onBlur, restProps.onBlur),
    onFocus: callMultiple(onFocus, restProps.onFocus)
  })), hasReactNode(before) && React232.createElement("div", {
    className: "vkuiSegmentedControlOption__before"
  }, before), React232.createElement(Headline, {
    level: "2",
    weight: "2"
  }, children));
};

// node_modules/@vkontakte/vkui/dist/components/SegmentedControl/SegmentedControl.js
var _options_;
var sizeYClassNames28 = {
  none: "vkuiSegmentedControl--sizeY-none",
  ["regular"]: "vkuiSegmentedControl--sizeY-regular"
};
var warn22 = warnOnce("SegmentedControl");
var SegmentedControl = (_param) => {
  var { size: size4 = "l", name, options, defaultValue = (_options_ = options[0]) === null || _options_ === void 0 ? void 0 : _options_.value, children, onChange: onChangeProp, value: valueProp } = _param, restProps = _object_without_properties(_param, [
    "size",
    "name",
    "options",
    "defaultValue",
    "children",
    "onChange",
    "value"
  ]);
  const id = React233.useId();
  const [value, onChange] = useCustomEnsuredControl({
    onChange: onChangeProp,
    value: valueProp,
    defaultValue
  });
  const { sizeY = "none" } = useAdaptivity();
  const actualIndex = options.findIndex((option) => option.value === value);
  useIsomorphicLayoutEffect(() => {
    if (actualIndex === -1 && true) {
      warn22("defaultValue: такого значения нет среди опций!", "error");
    }
  }, [
    actualIndex
  ]);
  const translateX = `translateX(${100 * actualIndex}%)`;
  return React233.createElement(RootComponent, _object_spread_props(_object_spread({}, restProps), {
    baseClassName: classNames("vkuiSegmentedControl", sizeY !== "compact" && sizeYClassNames28[sizeY], size4 === "l" && "vkuiSegmentedControl--size-l")
  }), React233.createElement("div", {
    role: "radiogroup",
    className: "vkuiSegmentedControl__in"
  }, actualIndex > -1 && React233.createElement("div", {
    "aria-hidden": true,
    className: "vkuiSegmentedControl__slider",
    style: {
      width: `${100 / options.length}%`,
      transform: translateX,
      WebkitTransform: translateX
    }
  }), options.map((_param2) => {
    var { label } = _param2, optionProps = _object_without_properties(_param2, [
      "label"
    ]);
    return React233.createElement(SegmentedControlOption, _object_spread_props(_object_spread({
      key: `${optionProps.value}`
    }, optionProps), {
      name: name !== null && name !== void 0 ? name : id,
      checked: value === optionProps.value,
      onChange: () => onChange(optionProps.value)
    }), label);
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Calendar/Calendar.js
var React241 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useCalendar.js
var React234 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/lib/date.js
var import_dayjs = __toESM(require_dayjs_min());
function startOfDay(date) {
  return (0, import_dayjs.default)(date).startOf("day").toDate();
}
function endOfDay(date) {
  return (0, import_dayjs.default)(date).endOf("day").toDate();
}
function startOfWeek(date, weekStart = 0) {
  weekStart = weekStart % 7;
  const day = (0, import_dayjs.default)(date);
  const weekDay = day.day();
  const diff = (weekDay < weekStart ? 7 : 0) + weekDay - weekStart;
  return day.date(day.date() - diff).toDate();
}
function endOfWeek(date, weekStart = 0) {
  const day = (0, import_dayjs.default)(startOfWeek(date, weekStart));
  return day.date(day.date() + 6).toDate();
}
function startOfMonth(date) {
  return (0, import_dayjs.default)(date).startOf("month").toDate();
}
function endOfMonth(date) {
  return (0, import_dayjs.default)(date).endOf("month").toDate();
}
function isFirstDayOfMonth(date) {
  return (0, import_dayjs.default)(date).date() === 1;
}
function isLastDayOfMonth(date) {
  return (0, import_dayjs.default)(date).endOf("day").isSame((0, import_dayjs.default)(date).endOf("month"));
}
function format(date, format2) {
  return (0, import_dayjs.default)(date).format(format2);
}
function isBefore(date1, date2) {
  return (0, import_dayjs.default)(date1) < (0, import_dayjs.default)(date2);
}
function isAfter(date1, date2) {
  return (0, import_dayjs.default)(date1) > (0, import_dayjs.default)(date2);
}
function isSameDay(date1, date2) {
  return (0, import_dayjs.default)(date1).isSame(date2, "day");
}
function isSameMonth(date1, date2) {
  return (0, import_dayjs.default)(date1).isSame(date2, "month");
}
function isWithinInterval(date, start, end) {
  const day = (0, import_dayjs.default)(date);
  return day >= (0, import_dayjs.default)(start) && day <= (0, import_dayjs.default)(end);
}
function setMinutes(date, minute) {
  return (0, import_dayjs.default)(date).set("minute", minute).toDate();
}
function setHours(date, hour) {
  return (0, import_dayjs.default)(date).set("hour", hour).toDate();
}
function setMonth(date, month) {
  return (0, import_dayjs.default)(date).set("month", month).toDate();
}
function setYear(date, year) {
  return (0, import_dayjs.default)(date).set("year", year).toDate();
}
function addDays2(date, day) {
  return (0, import_dayjs.default)(date).add(day, "day").toDate();
}
function subDays(date, day) {
  return (0, import_dayjs.default)(date).subtract(day, "day").toDate();
}
function addWeeks(date, week) {
  return (0, import_dayjs.default)(date).add(week, "week").toDate();
}
function subWeeks(date, week) {
  return (0, import_dayjs.default)(date).subtract(week, "week").toDate();
}
function addMonths(date, month) {
  return (0, import_dayjs.default)(date).add(month, "month").toDate();
}
function subMonths(date, month) {
  return (0, import_dayjs.default)(date).subtract(month, "month").toDate();
}
function eachDayOfInterval(start, end) {
  const dates = [];
  const startDate = (0, import_dayjs.default)(start).toDate();
  const endDate = (0, import_dayjs.default)(end).toDate();
  const endTime = endDate.getTime();
  const currentDate = startDate;
  currentDate.setHours(0, 0, 0, 0);
  while (currentDate.getTime() <= endTime) {
    dates.push(new Date(currentDate.getTime()));
    currentDate.setDate(currentDate.getDate() + 1);
    currentDate.setHours(0, 0, 0, 0);
  }
  return dates;
}
function parse(input, format2, referenceDate = /* @__PURE__ */ new Date()) {
  const match2 = /^\d\d/;
  const match4 = /^\d{4}/;
  const entries = [
    [
      "YYYY",
      match4,
      (val) => [
        "Y",
        +val,
        true
      ]
    ],
    [
      "MM",
      match2,
      (val) => {
        const numVal = +val;
        const okay = numVal > 0 && numVal <= 12;
        return [
          "M",
          numVal - 1,
          okay
        ];
      }
    ],
    [
      "DD",
      match2,
      (val) => [
        "D",
        +val,
        true
      ]
    ],
    [
      "HH",
      match2,
      (val) => {
        const numVal = parseInt(val, 10);
        const okay = numVal >= 0 && numVal < 24;
        return [
          "h",
          numVal,
          okay
        ];
      }
    ],
    [
      "mm",
      match2,
      (val) => {
        const numVal = parseInt(val, 10);
        const okay = numVal >= 0 && numVal < 60;
        return [
          "m",
          numVal,
          okay
        ];
      }
    ]
  ];
  const superRegExp = new RegExp(entries.map((item) => item[0]).join("|"), "g");
  const store = {
    Y: referenceDate.getFullYear(),
    M: referenceDate.getMonth(),
    D: referenceDate.getDate(),
    h: referenceDate.getHours(),
    m: referenceDate.getMinutes(),
    s: referenceDate.getSeconds(),
    ms: referenceDate.getMilliseconds()
  };
  let prevInputIndex = 0;
  let lastNonFormatting = "";
  let lastFormatIndex = 0;
  let found = false;
  while (true) {
    const match = superRegExp.exec(format2);
    if (!match) {
      break;
    }
    const length = match[0].length;
    const atIndex = superRegExp.lastIndex - length;
    const item = entries.find((item2) => item2[0] === match[0]);
    lastNonFormatting = format2.slice(lastFormatIndex, atIndex);
    lastFormatIndex = superRegExp.lastIndex;
    if (input.slice(prevInputIndex, prevInputIndex + lastNonFormatting.length) !== lastNonFormatting) {
      return /* @__PURE__ */ new Date("");
    }
    const value = input.slice(prevInputIndex + lastNonFormatting.length).match(item[1]);
    if (!value) {
      return /* @__PURE__ */ new Date("");
    }
    prevInputIndex = prevInputIndex + lastNonFormatting.length + value[0].length;
    const [key, newValue, okay] = item[2](value[0]);
    if (!okay) {
      return /* @__PURE__ */ new Date("");
    }
    store[key] = newValue;
    found = true;
  }
  if (!found) {
    return /* @__PURE__ */ new Date("");
  }
  const date = new Date(store.Y, store.M, store.D, store.h, store.m, store.s, store.ms);
  if (date.getMonth() !== store.M || date.getDate() !== store.D) {
    return /* @__PURE__ */ new Date("");
  }
  return date;
}
function isMatch(input, format2) {
  return !isNaN(+parse(input, format2));
}
function getMillisecondsToTomorrow(date) {
  return (0, import_dayjs.default)(endOfDay(date)).diff((0, import_dayjs.default)(date), "ms");
}

// node_modules/@vkontakte/vkui/dist/lib/calendar.js
var getYears = (currentYear, range2) => {
  const years = [];
  for (let i = currentYear - range2; i <= currentYear + range2; i++) {
    years.push({
      label: String(i).padStart(4, "0"),
      value: i
    });
  }
  return years;
};
var getMonths = (locale) => {
  const months = [];
  const formatter = new Intl.DateTimeFormat(locale, {
    month: "long"
  });
  for (let i = 0; i < 12; i++) {
    months.push({
      label: formatter.format((/* @__PURE__ */ new Date("1970-01-01")).setMonth(i)),
      value: i
    });
  }
  return months;
};
var getDaysNames = (now2, weekStartsOn, locale) => {
  const formatter = new Intl.DateTimeFormat(locale, {
    weekday: "short"
  });
  return eachDayOfInterval(startOfWeek(now2, weekStartsOn), endOfWeek(now2, weekStartsOn)).map((day) => formatter.format(day));
};
var navigateDate = (date, key) => {
  let newDate = date !== null && date !== void 0 ? date : /* @__PURE__ */ new Date();
  switch (key) {
    case "ArrowRight":
      newDate = addDays2(newDate, 1);
      break;
    case "ArrowLeft":
      newDate = subDays(newDate, 1);
      break;
    case "ArrowUp":
      newDate = subWeeks(newDate, 1);
      break;
    case "ArrowDown":
      newDate = addWeeks(newDate, 1);
      break;
  }
  return newDate;
};
var getWeeks = (viewDate, weekStartsOn) => {
  const start = startOfWeek(startOfMonth(viewDate), weekStartsOn);
  const end = endOfWeek(endOfMonth(viewDate), weekStartsOn);
  let count = 0;
  let current = start;
  const nestedWeeks = [];
  let lastDay = null;
  while (isBefore(current, end)) {
    const weekNumber = Math.floor(count / 7);
    nestedWeeks[weekNumber] = nestedWeeks[weekNumber] || [];
    const day = current.getDay();
    if (lastDay !== day) {
      lastDay = day;
      nestedWeeks[weekNumber].push(current);
      count += 1;
    }
    current = addDays2(current, 1);
  }
  return nestedWeeks;
};
var setTimeEqual = (to, from) => {
  if (from) {
    to.setHours(from.getHours());
    to.setMinutes(from.getMinutes());
    to.setSeconds(from.getSeconds());
    to.setMilliseconds(from.getMilliseconds());
  }
  return to;
};
var isFirstDay = (day, dayOfWeek) => dayOfWeek === 0 || isFirstDayOfMonth(day);
var isLastDay = (day, dayOfWeek) => dayOfWeek === 6 || isLastDayOfMonth(day);
function clamp3(day, options = {}) {
  const { min: min2, max: max2 } = options;
  if (min2 && isBefore(day, min2)) {
    return min2;
  }
  if (max2 && isAfter(day, max2)) {
    return max2;
  }
  return day;
}
function isDayMinMaxRestricted(day, options = {}) {
  const { min: min2, max: max2, withTime = false } = options;
  if (!withTime && (min2 && isSameDay(day, min2) || max2 && isSameDay(day, max2))) {
    return false;
  }
  return Boolean(min2 && isBefore(day, min2) || max2 && isAfter(day, max2));
}

// node_modules/@vkontakte/vkui/dist/hooks/useCalendar.js
function useCalendar({ value, disablePast, disableFuture, shouldDisableDate, onHeaderChange, onNextMonth, onPrevMonth, minDateTime, maxDateTime }) {
  var _ref;
  const [viewDate, setViewDate] = React234.useState((_ref = Array.isArray(value) ? value[0] : value) !== null && _ref !== void 0 ? _ref : /* @__PURE__ */ new Date());
  const [focusedDay, setFocusedDay] = React234.useState();
  const setPrevMonth = React234.useCallback(() => {
    onPrevMonth === null || onPrevMonth === void 0 ? void 0 : onPrevMonth();
    setViewDate(subMonths(viewDate, 1));
  }, [
    viewDate,
    onPrevMonth
  ]);
  const setNextMonth = React234.useCallback(() => {
    onNextMonth === null || onNextMonth === void 0 ? void 0 : onNextMonth();
    setViewDate(addMonths(viewDate, 1));
  }, [
    viewDate,
    onNextMonth
  ]);
  const handleSetViewDate = React234.useCallback((value2) => {
    onHeaderChange === null || onHeaderChange === void 0 ? void 0 : onHeaderChange(value2);
    setViewDate(value2);
  }, [
    onHeaderChange
  ]);
  const isDayFocused = React234.useCallback((day) => Boolean(focusedDay && isSameDay(day, focusedDay)), [
    focusedDay
  ]);
  const isDayDisabled = React234.useCallback((day, withTime) => {
    const now2 = /* @__PURE__ */ new Date();
    if (shouldDisableDate) {
      return shouldDisableDate(day);
    }
    if (disableFuture) {
      return isAfter(startOfDay(day), now2);
    }
    if (disablePast) {
      return isBefore(endOfDay(day), now2);
    }
    if (minDateTime || maxDateTime) {
      return isDayMinMaxRestricted(day, {
        min: minDateTime,
        max: maxDateTime,
        withTime
      });
    }
    return false;
  }, [
    disableFuture,
    disablePast,
    shouldDisableDate,
    minDateTime,
    maxDateTime
  ]);
  const resetSelectedDay = React234.useCallback(() => {
    setFocusedDay(void 0);
  }, [
    setFocusedDay
  ]);
  return {
    viewDate,
    setViewDate: handleSetViewDate,
    setPrevMonth,
    setNextMonth,
    focusedDay,
    setFocusedDay,
    isDayFocused,
    isDayDisabled,
    resetSelectedDay
  };
}

// node_modules/@vkontakte/vkui/dist/components/CalendarDays/CalendarDays.js
var React237 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useTodayDate.js
var React235 = __toESM(require_react());
function useTodayDate(listenDayChangesForUpdate = false) {
  const { document: document2, window: window2 } = useDOM();
  const [todayDate, setTodayDate] = React235.useState(() => /* @__PURE__ */ new Date());
  React235.useEffect(() => {
    if (!listenDayChangesForUpdate || !document2 || !window2) {
      return;
    }
    let timeout = void 0;
    const recalcTimeout = () => {
      if (document2.visibilityState === "visible") {
        const now2 = /* @__PURE__ */ new Date();
        const timeToDayChange = getMillisecondsToTomorrow(now2);
        window2.clearTimeout(timeout);
        timeout = window2.setTimeout(() => {
          setTodayDate(now2);
        }, timeToDayChange);
        if (!isSameDay(todayDate, now2)) {
          setTodayDate(now2);
        }
      }
    };
    recalcTimeout();
    document2.addEventListener("visibilitychange", recalcTimeout);
    return () => {
      window2.clearTimeout(timeout);
      document2.removeEventListener("visibilitychange", recalcTimeout);
    };
  }, [
    document2,
    listenDayChangesForUpdate,
    todayDate,
    window2
  ]);
  return todayDate;
}

// node_modules/@vkontakte/vkui/dist/components/CalendarDay/CalendarDay.js
var React236 = __toESM(require_react());
var CalendarDay = React236.memo((_param) => {
  var { day, today, selected, onChange, hidden, disabled, active, selectionStart, selectionEnd, focused, onEnter, onLeave, hinted, hintedSelectionStart, hintedSelectionEnd, sameMonth, size: size4, className, children } = _param, restProps = _object_without_properties(_param, [
    "day",
    "today",
    "selected",
    "onChange",
    "hidden",
    "disabled",
    "active",
    "selectionStart",
    "selectionEnd",
    "focused",
    "onEnter",
    "onLeave",
    "hinted",
    "hintedSelectionStart",
    "hintedSelectionEnd",
    "sameMonth",
    "size",
    "className",
    "children"
  ]);
  const { locale } = useConfigProvider();
  const ref = React236.useRef(null);
  const onClick = React236.useCallback(() => onChange(day), [
    day,
    onChange
  ]);
  const handleEnter = React236.useCallback(() => onEnter === null || onEnter === void 0 ? void 0 : onEnter(day), [
    day,
    onEnter
  ]);
  const handleLeave = React236.useCallback(() => onLeave === null || onLeave === void 0 ? void 0 : onLeave(day), [
    day,
    onLeave
  ]);
  const label = new Intl.DateTimeFormat(locale, {
    weekday: "long",
    year: "numeric",
    month: "long",
    day: "numeric"
  }).format(day);
  React236.useEffect(() => {
    if (focused && ref.current) {
      ref.current.dispatchEvent(new Event(ENABLE_KEYBOARD_INPUT_EVENT_NAME, {
        bubbles: true
      }));
      ref.current.focus();
    }
  }, [
    focused
  ]);
  if (hidden) {
    return React236.createElement("div", {
      className: "vkuiCalendarDay__hidden"
    });
  }
  return React236.createElement(Tappable, _object_spread({
    className: classNames("vkuiCalendarDay", size4 === "s" && "vkuiCalendarDay--size-s", today && "vkuiCalendarDay--today", selected && !disabled && "vkuiCalendarDay--selected", selectionStart && "vkuiCalendarDay--selection-start", selectionEnd && "vkuiCalendarDay--selection-end", disabled && "vkuiCalendarDay--disabled", !sameMonth && "vkuiCalendarDay--not-same-month", className),
    hoverMode: active ? "" : "vkuiCalendarDay--hover",
    hasActive: false,
    onClick,
    disabled,
    tabIndex: -1,
    getRootRef: ref,
    focusVisibleMode: active ? "outside" : "inside",
    onPointerEnter: handleEnter,
    onPointerLeave: handleLeave
  }, restProps), React236.createElement("div", {
    className: classNames("vkuiCalendarDay__hinted", hinted && "vkuiCalendarDay__hinted--active", hintedSelectionStart && "vkuiCalendarDay__hinted--selection-start", hintedSelectionEnd && "vkuiCalendarDay__hinted--selection-end")
  }, React236.createElement("div", {
    className: classNames("vkuiCalendarDay__inner", active && !disabled && "vkuiCalendarDay__inner--active")
  }, React236.createElement("div", {
    className: "vkuiCalendarDay__day-number"
  }, React236.createElement(VisuallyHidden, null, children !== null && children !== void 0 ? children : label), React236.createElement("span", {
    "aria-hidden": true
  }, day.getDate())))));
});
CalendarDay.displayName = "CalendarDay";

// node_modules/@vkontakte/vkui/dist/components/CalendarDays/CalendarDays.js
var CalendarDays = (_param) => {
  var { viewDate, value, weekStartsOn, onDayChange, isDaySelected, isDayActive, isDaySelectionEnd, isDaySelectionStart, onDayEnter, onDayLeave, isDayHinted, isHintedDaySelectionStart, isHintedDaySelectionEnd, isDayFocused, isDayDisabled, size: size4, showNeighboringMonth = false, dayProps, listenDayChangesForUpdate = false, getRootRef } = _param, props = _object_without_properties(_param, [
    "viewDate",
    "value",
    "weekStartsOn",
    "onDayChange",
    "isDaySelected",
    "isDayActive",
    "isDaySelectionEnd",
    "isDaySelectionStart",
    "onDayEnter",
    "onDayLeave",
    "isDayHinted",
    "isHintedDaySelectionStart",
    "isHintedDaySelectionEnd",
    "isDayFocused",
    "isDayDisabled",
    "size",
    "showNeighboringMonth",
    "dayProps",
    "listenDayChangesForUpdate",
    "getRootRef"
  ]);
  const { locale } = useConfigProvider();
  const ref = useExternRef(getRootRef);
  const now2 = useTodayDate(listenDayChangesForUpdate);
  const weeks = React237.useMemo(() => getWeeks(viewDate, weekStartsOn), [
    weekStartsOn,
    viewDate
  ]);
  const daysNames = React237.useMemo(() => getDaysNames(now2, weekStartsOn, locale), [
    locale,
    now2,
    weekStartsOn
  ]);
  const handleDayChange = React237.useCallback((date) => {
    var _ref_current;
    onDayChange(date);
    (_ref_current = ref.current) === null || _ref_current === void 0 ? void 0 : _ref_current.focus();
  }, [
    onDayChange,
    ref
  ]);
  return React237.createElement(RootComponent, _object_spread_props(_object_spread({}, props), {
    baseClassName: "vkuiCalendarDays",
    getRootRef: ref
  }), React237.createElement("div", {
    className: classNames("vkuiCalendarDays__row", size4 === "s" && "vkuiCalendarDays__row--size-s")
  }, daysNames.map((dayName) => React237.createElement(Footnote, {
    key: dayName,
    className: "vkuiCalendarDays__weekday"
  }, dayName))), weeks.map((week, i) => React237.createElement("div", {
    className: classNames("vkuiCalendarDays__row", size4 === "s" && "vkuiCalendarDays__row--size-s"),
    key: i
  }, week.map((day, i2) => {
    const sameMonth = isSameMonth(day, viewDate);
    return React237.createElement(CalendarDay, _object_spread({
      key: day.toISOString(),
      day,
      today: isSameDay(day, now2),
      active: isDayActive(day),
      onChange: handleDayChange,
      hidden: !showNeighboringMonth && !sameMonth,
      disabled: isDayDisabled(day),
      selectionStart: isDaySelectionStart(day, i2),
      selectionEnd: isDaySelectionEnd(day, i2),
      hintedSelectionStart: isHintedDaySelectionStart === null || isHintedDaySelectionStart === void 0 ? void 0 : isHintedDaySelectionStart(day, i2),
      hintedSelectionEnd: isHintedDaySelectionEnd === null || isHintedDaySelectionEnd === void 0 ? void 0 : isHintedDaySelectionEnd(day, i2),
      selected: isDaySelected === null || isDaySelected === void 0 ? void 0 : isDaySelected(day),
      focused: isDayFocused(day),
      onEnter: onDayEnter,
      onLeave: onDayLeave,
      hinted: isDayHinted === null || isDayHinted === void 0 ? void 0 : isDayHinted(day),
      sameMonth,
      size: size4
    }, dayProps));
  }))));
};

// node_modules/@vkontakte/vkui/dist/components/CalendarHeader/CalendarHeader.js
var React239 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/components/AdaptivityProvider/AdaptivityProvider.js
var React238 = __toESM(require_react());
var AdaptivityProvider = ({ viewWidth, viewHeight, sizeX: sizeXProp, sizeY: sizeYProp, hasPointer, hasHover: hasHover2, children }) => {
  const adaptivity = React238.useMemo(() => {
    const nextProps = {
      viewWidth,
      viewHeight,
      sizeX: sizeXProp,
      sizeY: sizeYProp,
      hasPointer,
      hasHover: hasHover2
    };
    if (sizeXProp === void 0 && viewWidth !== void 0) {
      nextProps.sizeX = getSizeX(viewWidth);
    }
    if (sizeYProp === void 0) {
      if (isCompactByViewWidth(viewWidth, hasPointer) || isCompactByViewHeight(viewHeight)) {
        nextProps.sizeY = "compact";
      } else if (viewWidth !== void 0 || viewHeight !== void 0) {
        nextProps.sizeY = "regular";
      }
    }
    return nextProps;
  }, [
    viewWidth,
    viewHeight,
    sizeXProp,
    sizeYProp,
    hasPointer,
    hasHover2
  ]);
  return React238.createElement(AdaptivityContext.Provider, {
    value: adaptivity
  }, children);
};

// node_modules/@vkontakte/vkui/dist/components/CalendarHeader/CalendarHeader.js
var CalendarHeader = (_param) => {
  var { viewDate, onChange, prevMonthHidden = false, nextMonthHidden = false, disablePickers = false, onNextMonth, onPrevMonth, prevMonthProps = {}, nextMonthProps = {}, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", prevMonthIcon = React239.createElement(Icon20ChevronLeftOutline, {
    className: "vkuiCalendarHeader__nav-icon--accent",
    width: 30,
    height: 30
  }), nextMonthIcon = React239.createElement(Icon20ChevronRightOutline, {
    className: "vkuiCalendarHeader__nav-icon--accent",
    width: 30,
    height: 30
  }) } = _param, restProps = _object_without_properties(_param, [
    "viewDate",
    "onChange",
    "prevMonthHidden",
    "nextMonthHidden",
    "disablePickers",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthProps",
    "nextMonthProps",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "prevMonthIcon",
    "nextMonthIcon"
  ]);
  const { locale } = useConfigProvider();
  const onMonthsChange = React239.useCallback((event) => onChange(setMonth(viewDate, Number(event.target.value))), [
    onChange,
    viewDate
  ]);
  const onYearChange = React239.useCallback((event) => onChange(setYear(viewDate, Number(event.target.value))), [
    onChange,
    viewDate
  ]);
  const months = React239.useMemo(() => getMonths(locale).map(({ value, label }) => ({
    value,
    label: React239.createElement("span", {
      className: "vkuiCalendarHeader__month"
    }, label)
  })), [
    locale
  ]);
  const currentYear = viewDate.getFullYear();
  const years = React239.useMemo(() => getYears(currentYear, 100), [
    currentYear
  ]);
  const formatter = new Intl.DateTimeFormat(locale, {
    year: "numeric",
    month: "long"
  });
  const { className: prevMonthClassName } = prevMonthProps, restPrevMonthProps = _object_without_properties(prevMonthProps, [
    "className"
  ]);
  const { className: nextMonthClassName } = nextMonthProps, restNextMonthProps = _object_without_properties(nextMonthProps, [
    "className"
  ]);
  return React239.createElement(RootComponent, _object_spread({
    baseClassName: "vkuiCalendarHeader"
  }, restProps), !prevMonthHidden && React239.createElement(AdaptivityProvider, {
    sizeX: "regular"
  }, React239.createElement(Tappable, _object_spread({
    className: classNames("vkuiCalendarHeader__nav-icon", "vkuiCalendarHeader__nav-icon-prev", prevMonthClassName),
    onClick: onPrevMonth
  }, restPrevMonthProps), React239.createElement(VisuallyHidden, null, prevMonthLabel, ", ", formatter.format(subMonths(viewDate, 1))), prevMonthIcon)), disablePickers ? React239.createElement(Paragraph, {
    className: classNames("vkuiCalendarHeader__pickers", "vkuiInternalCalendarHeader__pickers"),
    weight: "2"
  }, React239.createElement("span", {
    className: "vkuiCalendarHeader__month"
  }, new Intl.DateTimeFormat(locale, {
    month: "long"
  }).format(viewDate)), " ", new Intl.DateTimeFormat(locale, {
    year: "numeric"
  }).format(viewDate)) : React239.createElement(AdaptivityProvider, {
    sizeY: "compact"
  }, React239.createElement("div", {
    className: classNames("vkuiCalendarHeader__pickers", "vkuiInternalCalendarHeader__pickers")
  }, React239.createElement(CustomSelect, {
    className: classNames("vkuiCalendarHeader__picker", "vkuiInternalCalendarHeader__picker"),
    value: viewDate.getMonth(),
    options: months,
    dropdownOffsetDistance: 4,
    dropdownAutoWidth: true,
    icon: React239.createElement(Icon12Dropdown, null),
    onChange: onMonthsChange,
    forceDropdownPortal: false,
    selectType: "accent",
    "aria-label": changeMonthLabel
  }), React239.createElement(CustomSelect, {
    className: classNames("vkuiCalendarHeader__picker", "vkuiInternalCalendarHeader__picker"),
    value: viewDate.getFullYear(),
    options: years,
    dropdownOffsetDistance: 4,
    dropdownAutoWidth: true,
    icon: React239.createElement(Icon12Dropdown, null),
    onChange: onYearChange,
    forceDropdownPortal: false,
    selectType: "accent",
    "aria-label": changeYearLabel
  }))), !nextMonthHidden && React239.createElement(AdaptivityProvider, {
    sizeX: "regular"
  }, React239.createElement(Tappable, _object_spread({
    className: classNames("vkuiCalendarHeader__nav-icon", "vkuiCalendarHeader__nav-icon-next", nextMonthClassName),
    onClick: onNextMonth
  }, restNextMonthProps), React239.createElement(VisuallyHidden, null, nextMonthLabel, ", ", formatter.format(addMonths(viewDate, 1))), nextMonthIcon)));
};

// node_modules/@vkontakte/vkui/dist/components/CalendarTime/CalendarTime.js
var React240 = __toESM(require_react());
var hours = [];
for (let i = 0; i < 24; i += 1) {
  hours.push({
    value: i,
    label: String(i).padStart(2, "0")
  });
}
var minutes = [];
for (let i = 0; i < 60; i += 1) {
  minutes.push({
    value: i,
    label: String(i).padStart(2, "0")
  });
}
var CalendarTime = ({ value, doneButtonText = "Готово", onChange, onClose, changeHoursLabel, changeMinutesLabel, isDayDisabled }) => {
  const localHours = isDayDisabled ? hours.map((hour) => {
    return _object_spread_props(_object_spread({}, hour), {
      disabled: isDayDisabled(setHours(value, hour.value), true)
    });
  }) : hours;
  const localMinutes = isDayDisabled ? minutes.map((minute) => {
    return _object_spread_props(_object_spread({}, minute), {
      disabled: isDayDisabled(setMinutes(value, minute.value), true)
    });
  }) : minutes;
  const onHoursChange = React240.useCallback((event) => onChange === null || onChange === void 0 ? void 0 : onChange(setHours(value, Number(event.target.value))), [
    onChange,
    value
  ]);
  const onMinutesChange = React240.useCallback((event) => onChange === null || onChange === void 0 ? void 0 : onChange(setMinutes(value, Number(event.target.value))), [
    onChange,
    value
  ]);
  return React240.createElement("div", {
    className: "vkuiCalendarTime"
  }, React240.createElement("div", {
    className: "vkuiCalendarTime__picker"
  }, React240.createElement(AdaptivityProvider, {
    sizeY: "compact"
  }, React240.createElement(CustomSelect, {
    value: value.getHours(),
    options: localHours,
    onChange: onHoursChange,
    forceDropdownPortal: false,
    "aria-label": changeHoursLabel
  }))), React240.createElement("div", {
    className: "vkuiCalendarTime__divider"
  }, ":"), React240.createElement("div", {
    className: "vkuiCalendarTime__picker"
  }, React240.createElement(AdaptivityProvider, {
    sizeY: "compact"
  }, React240.createElement(CustomSelect, {
    value: value.getMinutes(),
    options: localMinutes,
    onChange: onMinutesChange,
    forceDropdownPortal: false,
    "aria-label": changeMinutesLabel
  }))), React240.createElement("div", {
    className: "vkuiCalendarTime__button"
  }, React240.createElement(AdaptivityProvider, {
    sizeY: "compact"
  }, React240.createElement(Button, {
    mode: "secondary",
    onClick: onClose,
    size: "l"
  }, doneButtonText))));
};

// node_modules/@vkontakte/vkui/dist/components/Calendar/Calendar.js
var warn23 = warnOnce("Calendar");
var Calendar = (_param) => {
  var { value, onChange, disablePast, disableFuture, shouldDisableDate, onClose, enableTime = false, doneButtonText, weekStartsOn = 1, disablePickers, changeHoursLabel = "Изменить час", changeMinutesLabel = "Изменить минуту", prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", showNeighboringMonth, changeDayLabel = "Изменить день", size: size4 = "m", viewDate: externalViewDate, onHeaderChange, onNextMonth, onPrevMonth, prevMonthIcon, nextMonthIcon, prevMonthProps, nextMonthProps, dayProps, listenDayChangesForUpdate, minDateTime, maxDateTime } = _param, props = _object_without_properties(_param, [
    "value",
    "onChange",
    "disablePast",
    "disableFuture",
    "shouldDisableDate",
    "onClose",
    "enableTime",
    "doneButtonText",
    "weekStartsOn",
    "disablePickers",
    "changeHoursLabel",
    "changeMinutesLabel",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "showNeighboringMonth",
    "changeDayLabel",
    "size",
    "viewDate",
    "onHeaderChange",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthIcon",
    "nextMonthIcon",
    "prevMonthProps",
    "nextMonthProps",
    "dayProps",
    "listenDayChangesForUpdate",
    "minDateTime",
    "maxDateTime"
  ]);
  const { viewDate, setViewDate, setPrevMonth, setNextMonth, focusedDay, setFocusedDay, isDayFocused, isDayDisabled, resetSelectedDay } = useCalendar({
    value,
    disableFuture,
    disablePast,
    shouldDisableDate,
    onHeaderChange,
    onNextMonth,
    onPrevMonth,
    minDateTime,
    maxDateTime
  });
  useIsomorphicLayoutEffect(() => {
    if (value) {
      setViewDate(value);
    }
  }, [
    value
  ]);
  if (!disablePickers && size4 === "s") {
    warn23("Нельзя включить селекты выбора месяца/года, если размер календаря 's'", "error");
  }
  if (enableTime && size4 === "s") {
    warn23("Нельзя включить выбор времени, если размер календаря 's'", "error");
  }
  const handleKeyDown = React241.useCallback((event) => {
    if ([
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ].includes(event.key)) {
      event.preventDefault();
    }
    const newFocusedDay = navigateDate(focusedDay !== null && focusedDay !== void 0 ? focusedDay : value, event.key);
    if (newFocusedDay && !isSameMonth(newFocusedDay, viewDate)) {
      setViewDate(newFocusedDay);
    }
    setFocusedDay(newFocusedDay);
  }, [
    focusedDay,
    setFocusedDay,
    setViewDate,
    value,
    viewDate
  ]);
  const onDayChange = React241.useCallback((date) => {
    let actualDate = setTimeEqual(date, value);
    if (minDateTime || maxDateTime) {
      actualDate = clamp3(actualDate, {
        min: minDateTime,
        max: maxDateTime
      });
    }
    onChange === null || onChange === void 0 ? void 0 : onChange(actualDate);
  }, [
    value,
    onChange,
    maxDateTime,
    minDateTime
  ]);
  const isDayActive = React241.useCallback((day) => Boolean(value && isSameDay(day, value)), [
    value
  ]);
  return React241.createElement(RootComponent, _object_spread_props(_object_spread({}, props), {
    baseClassName: classNames("vkuiCalendar", size4 === "s" && "vkuiCalendar--size-s")
  }), React241.createElement(CalendarHeader, {
    viewDate: externalViewDate || viewDate,
    onChange: setViewDate,
    onNextMonth: setNextMonth,
    onPrevMonth: setPrevMonth,
    disablePickers: disablePickers || size4 === "s",
    className: "vkuiCalendar__header",
    prevMonthLabel,
    nextMonthLabel,
    changeMonthLabel,
    changeYearLabel,
    prevMonthIcon,
    nextMonthIcon,
    prevMonthProps,
    nextMonthProps
  }), React241.createElement(CalendarDays, {
    viewDate: externalViewDate || viewDate,
    value,
    weekStartsOn,
    isDayFocused,
    tabIndex: 0,
    "aria-label": changeDayLabel,
    onKeyDown: handleKeyDown,
    onDayChange,
    isDayActive,
    isDaySelectionStart: isFirstDay,
    isDaySelectionEnd: isLastDay,
    isDayDisabled,
    onBlur: resetSelectedDay,
    showNeighboringMonth,
    size: size4,
    dayProps,
    listenDayChangesForUpdate
  }), enableTime && value && size4 !== "s" && React241.createElement("div", {
    className: "vkuiCalendar__time"
  }, React241.createElement(CalendarTime, {
    value,
    onChange,
    onClose,
    doneButtonText,
    changeHoursLabel,
    changeMinutesLabel,
    isDayDisabled: minDateTime || maxDateTime ? isDayDisabled : void 0
  })));
};

// node_modules/@vkontakte/vkui/dist/components/CalendarRange/CalendarRange.js
var React242 = __toESM(require_react());
var getIsDaySelected = (day, value) => {
  if (!(value === null || value === void 0 ? void 0 : value[0]) || !value[1]) {
    return false;
  }
  return Boolean(isWithinInterval(day, startOfDay(value[0]), endOfDay(value[1])));
};
var CalendarRange = (_param) => {
  var { value, onChange, disablePast, disableFuture, shouldDisableDate, onClose, weekStartsOn = 1, disablePickers, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", changeDayLabel = "Изменить день", prevMonthIcon, nextMonthIcon, listenDayChangesForUpdate } = _param, props = _object_without_properties(_param, [
    "value",
    "onChange",
    "disablePast",
    "disableFuture",
    "shouldDisableDate",
    "onClose",
    "weekStartsOn",
    "disablePickers",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "changeDayLabel",
    "prevMonthIcon",
    "nextMonthIcon",
    "listenDayChangesForUpdate"
  ]);
  const { viewDate, setViewDate, setPrevMonth, setNextMonth, focusedDay, setFocusedDay, isDayFocused, isDayDisabled, resetSelectedDay } = useCalendar({
    value,
    disableFuture,
    disablePast,
    shouldDisableDate
  });
  const [hintedDate, setHintedDate] = React242.useState();
  const secondViewDate = addMonths(viewDate, 1);
  const handleKeyDown = React242.useCallback((event) => {
    if ([
      "ArrowUp",
      "ArrowDown",
      "ArrowLeft",
      "ArrowRight"
    ].includes(event.key)) {
      event.preventDefault();
    }
    const newFocusedDay = navigateDate(focusedDay !== null && focusedDay !== void 0 ? focusedDay : value === null || value === void 0 ? void 0 : value[1], event.key);
    if (newFocusedDay && !isSameMonth(newFocusedDay, viewDate) && !isSameMonth(newFocusedDay, addMonths(viewDate, 1))) {
      setViewDate(newFocusedDay);
    }
    setFocusedDay(newFocusedDay);
  }, [
    focusedDay,
    setFocusedDay,
    setViewDate,
    value,
    viewDate
  ]);
  const getNewValue = React242.useCallback((date) => {
    const isValueEmpty = !value || value[0] === null && value[1] === null;
    if (isValueEmpty) {
      return [
        date,
        null
      ];
    }
    const start = value[0];
    const end = value[1];
    if (start && isSameDay(date, start) || end && isSameDay(date, end)) {
      return [
        setTimeEqual(date, start),
        setTimeEqual(date, end)
      ];
    } else if (start && isBefore(date, start)) {
      return [
        setTimeEqual(date, start),
        end
      ];
    } else if (start && isAfter(date, start)) {
      return [
        start,
        setTimeEqual(date, end)
      ];
    }
    return value;
  }, [
    value
  ]);
  const onDayChange = React242.useCallback((date) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(getNewValue(date));
    setHintedDate(void 0);
  }, [
    onChange,
    getNewValue
  ]);
  const isDaySelected = React242.useCallback((day) => getIsDaySelected(day, value), [
    value
  ]);
  const isDayActive = React242.useCallback((day) => Boolean((value === null || value === void 0 ? void 0 : value[0]) && isSameDay(day, value[0]) || (value === null || value === void 0 ? void 0 : value[1]) && isSameDay(day, value[1])), [
    value
  ]);
  const isDaySelectionEnd = React242.useCallback((day, dayOfWeek) => Boolean(isLastDay(day, dayOfWeek) || (value === null || value === void 0 ? void 0 : value[1]) && isSameDay(day, value[1])), [
    value
  ]);
  const isHintedDaySelectionEnd = React242.useCallback((day, dayOfWeek) => Boolean(isLastDay(day, dayOfWeek) || (hintedDate === null || hintedDate === void 0 ? void 0 : hintedDate[1]) && isSameDay(day, hintedDate[1])), [
    hintedDate
  ]);
  const isDaySelectionStart = React242.useCallback((day, dayOfWeek) => Boolean(isFirstDay(day, dayOfWeek) || (value === null || value === void 0 ? void 0 : value[0]) && isSameDay(day, value[0])), [
    value
  ]);
  const isHintedDaySelectionStart = React242.useCallback((day, dayOfWeek) => Boolean(isFirstDay(day, dayOfWeek) || (hintedDate === null || hintedDate === void 0 ? void 0 : hintedDate[0]) && isSameDay(day, hintedDate[0])), [
    hintedDate
  ]);
  const onDayEnter = React242.useCallback((date) => setHintedDate(getNewValue(date)), [
    setHintedDate,
    getNewValue
  ]);
  const onDayLeave = React242.useCallback(() => setHintedDate(void 0), [
    setHintedDate
  ]);
  const isDayHinted = React242.useCallback((day) => getIsDaySelected(day, hintedDate), [
    hintedDate
  ]);
  return React242.createElement(RootComponent, _object_spread_props(_object_spread({}, props), {
    baseClassName: "vkuiCalendarRange"
  }), React242.createElement("div", {
    className: "vkuiCalendarRange__inner"
  }, React242.createElement(CalendarHeader, {
    viewDate,
    onChange: setViewDate,
    nextMonthHidden: true,
    onPrevMonth: setPrevMonth,
    disablePickers,
    className: "vkuiCalendarRange__header",
    prevMonthLabel,
    nextMonthLabel,
    changeMonthLabel,
    changeYearLabel,
    prevMonthIcon
  }), React242.createElement(CalendarDays, {
    viewDate,
    value,
    weekStartsOn,
    onKeyDown: handleKeyDown,
    isDayFocused,
    onDayChange,
    isDaySelected,
    isDayActive,
    isDaySelectionEnd,
    isDaySelectionStart,
    isDayHinted,
    onDayEnter,
    onDayLeave,
    isHintedDaySelectionEnd,
    isHintedDaySelectionStart,
    isDayDisabled,
    listenDayChangesForUpdate,
    "aria-label": changeDayLabel
  })), React242.createElement("div", {
    className: "vkuiCalendarRange__inner"
  }, React242.createElement(CalendarHeader, {
    viewDate: secondViewDate,
    onChange: setViewDate,
    prevMonthHidden: true,
    onNextMonth: setNextMonth,
    disablePickers,
    className: "vkuiCalendarRange__header",
    prevMonthLabel,
    nextMonthLabel,
    changeMonthLabel,
    changeYearLabel,
    nextMonthIcon
  }), React242.createElement(CalendarDays, {
    viewDate: secondViewDate,
    value,
    weekStartsOn,
    "aria-label": changeDayLabel,
    onKeyDown: handleKeyDown,
    isDayFocused,
    onDayChange,
    isDaySelected,
    isDayActive,
    isDaySelectionEnd,
    isDaySelectionStart,
    isDayHinted,
    onDayEnter,
    onDayLeave,
    isHintedDaySelectionEnd,
    isHintedDaySelectionStart,
    isDayDisabled,
    listenDayChangesForUpdate,
    tabIndex: 0,
    onBlur: resetSelectedDay
  })));
};

// node_modules/@vkontakte/vkui/dist/components/DateInput/DateInput.js
var React246 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useDateInput.js
var React243 = __toESM(require_react());
function useDateInput({ maxElement, refs, autoFocus, disabled, elementsConfig: elementsConfig3, onChange, onInternalValueChange, getInternalValue: getInternalValue3, value }) {
  const { document: document2 } = useDOM();
  const { value: open, setTrue: openCalendar, setFalse: closeCalendar } = useBooleanState(false);
  const rootRef = React243.useRef(null);
  const calendarRef = React243.useRef(null);
  const [internalValue, setInternalValue] = React243.useState([]);
  const [focusedElement, setFocusedElement] = React243.useState(null);
  const { window: window2 } = useDOM();
  const removeFocusFromField = React243.useCallback(() => {
    if (focusedElement !== null) {
      var _window_getSelection;
      setFocusedElement(null);
      closeCalendar();
      (_window_getSelection = window2.getSelection()) === null || _window_getSelection === void 0 ? void 0 : _window_getSelection.removeAllRanges();
      setInternalValue(getInternalValue3(value));
    }
  }, [
    focusedElement,
    closeCalendar,
    getInternalValue3,
    value,
    window2
  ]);
  const handleClickOutside = React243.useCallback((e) => {
    var _rootRef_current, _calendarRef_current;
    if (!((_rootRef_current = rootRef.current) === null || _rootRef_current === void 0 ? void 0 : _rootRef_current.contains(e.target)) && !((_calendarRef_current = calendarRef.current) === null || _calendarRef_current === void 0 ? void 0 : _calendarRef_current.contains(e.target))) {
      removeFocusFromField();
    }
  }, [
    removeFocusFromField
  ]);
  const selectFirst = React243.useCallback(() => {
    setFocusedElement(0);
  }, []);
  useGlobalEventListener(document2, "click", handleClickOutside, {
    capture: true
  });
  React243.useEffect(() => {
    setInternalValue(getInternalValue3(value));
  }, [
    getInternalValue3,
    value
  ]);
  React243.useEffect(() => {
    if (autoFocus) {
      selectFirst();
    }
  }, [
    autoFocus,
    selectFirst
  ]);
  React243.useEffect(() => {
    if (disabled || focusedElement === null) {
      return;
    }
    const range2 = window2.document.createRange();
    let element = refs[focusedElement].current;
    if (element) {
      element.focus();
      openCalendar();
      range2.selectNodeContents(element);
      const selection = window2.getSelection();
      selection === null || selection === void 0 ? void 0 : selection.removeAllRanges();
      selection === null || selection === void 0 ? void 0 : selection.addRange(range2);
    }
  }, [
    disabled,
    focusedElement,
    openCalendar,
    refs,
    window2
  ]);
  const clear = React243.useCallback(() => {
    onChange === null || onChange === void 0 ? void 0 : onChange(void 0);
    selectFirst();
  }, [
    onChange,
    selectFirst
  ]);
  const handleFieldEnter = React243.useCallback(() => {
    if (!open) {
      selectFirst();
    }
  }, [
    open,
    selectFirst
  ]);
  const handleKeyDown = React243.useCallback((e) => {
    if (focusedElement === null) {
      return;
    }
    const _value = [
      ...internalValue
    ];
    const config = elementsConfig3(focusedElement);
    if (/^\d+$/.test(e.key)) {
      if (_value[focusedElement].length >= config.length) {
        _value[focusedElement] = e.key;
      } else {
        _value[focusedElement] += e.key;
        if (_value[focusedElement].length >= config.length && focusedElement < maxElement) {
          setFocusedElement(focusedElement + 1);
        }
      }
    } else if (e.key === "Backspace") {
      if (!_value[focusedElement]) {
        setFocusedElement(focusedElement <= 0 ? maxElement : focusedElement - 1);
      } else {
        _value[focusedElement] = _value[focusedElement].slice(0, -1);
      }
    } else if (e.key === "ArrowDown" || e.key === "Down") {
      let currentValue = Number(_value[focusedElement]);
      _value[focusedElement] = String(currentValue <= config.min ? config.max : currentValue - 1).padStart(config.length, "0");
    } else if (e.key === "ArrowUp" || e.key === "Up") {
      let currentValue = Number(_value[focusedElement]);
      _value[focusedElement] = String(currentValue >= config.max ? config.min : currentValue + 1).padStart(config.length, "0");
    } else if (e.key === "Enter" || e.key === "Tab" && focusedElement === maxElement || e.key === "Tab" && e.shiftKey && focusedElement === 0) {
      removeFocusFromField();
      return;
    } else if (e.key === "ArrowLeft" || e.key === "Left" || e.key === "Tab" && e.shiftKey) {
      setFocusedElement(focusedElement <= 0 ? maxElement : focusedElement - 1);
    } else if (e.key === "ArrowRight" || e.key === "Right" || e.key === "Tab") {
      setFocusedElement(focusedElement >= maxElement ? 0 : focusedElement + 1);
    } else if (e.key === "Delete" || e.key === "Del") {
      _value[focusedElement] = "";
    } else {
      return;
    }
    e.preventDefault();
    setInternalValue(_value);
    onInternalValueChange(_value);
  }, [
    elementsConfig3,
    focusedElement,
    internalValue,
    maxElement,
    onInternalValueChange,
    removeFocusFromField
  ]);
  return {
    rootRef,
    calendarRef,
    open,
    openCalendar,
    closeCalendar,
    internalValue,
    focusedElement,
    setFocusedElement,
    handleKeyDown,
    clear,
    handleFieldEnter,
    removeFocusFromField
  };
}

// node_modules/@vkontakte/vkui/dist/components/InputLike/InputLike.js
var React244 = __toESM(require_react());
var MASK_SYMBOL = String.fromCharCode(8199);
function getMaskElements(length) {
  const result = [];
  for (let index2 = 0; index2 < length; index2 += 1) {
    result.push(React244.createElement("span", {
      key: index2,
      className: "vkuiInputLike__mask"
    }, MASK_SYMBOL));
  }
  return result;
}
var InputLike = (_param) => {
  var { value, length, index: index2, onElementSelect, onClick, onFocus, label } = _param, restProps = _object_without_properties(_param, [
    "value",
    "length",
    "index",
    "onElementSelect",
    "onClick",
    "onFocus",
    "label"
  ]);
  const handleElementSelect = React244.useCallback((event) => {
    stopPropagation(event);
    onElementSelect === null || onElementSelect === void 0 ? void 0 : onElementSelect(index2);
  }, [
    index2,
    onElementSelect
  ]);
  var _value_length;
  return React244.createElement(RootComponent, _object_spread({
    Component: "span",
    baseClassName: (value === null || value === void 0 ? void 0 : value.length) === length ? "vkuiInputLike--full" : void 0,
    tabIndex: 0,
    onClick: callMultiple(onClick, handleElementSelect),
    onFocus: callMultiple(stopPropagation, onFocus)
  }, restProps), label && React244.createElement(VisuallyHidden, null, label), value === null || value === void 0 ? void 0 : value.slice(0, length - 1), (value === null || value === void 0 ? void 0 : value.slice(length - 1)) && React244.createElement("span", {
    key: index2,
    className: "vkuiInputLike__last_character"
  }, value.slice(length - 1)), getMaskElements(length - ((_value_length = value === null || value === void 0 ? void 0 : value.length) !== null && _value_length !== void 0 ? _value_length : 0)));
};
InputLike.displayName = "InputLike";

// node_modules/@vkontakte/vkui/dist/components/InputLike/InputLikeDivider.js
var React245 = __toESM(require_react());
var InputLikeDivider = (_param) => {
  var { children, className } = _param, props = _object_without_properties(_param, [
    "children",
    "className"
  ]);
  return React245.createElement("span", _object_spread({
    className: classNames("vkuiInputLike__divider", className)
  }, props), children);
};

// node_modules/@vkontakte/vkui/dist/components/DateInput/DateInput.js
var sizeYClassNames29 = {
  none: "vkuiDateInput--sizeY-none",
  ["compact"]: "vkuiDateInput--sizeY-compact"
};
var elementsConfig = (index2) => {
  let length = 2;
  let min2 = 1;
  let max2 = 0;
  switch (index2) {
    case 0:
      max2 = 31;
      break;
    case 1:
      max2 = 12;
      break;
    case 2:
      max2 = 2100;
      min2 = 1900;
      length = 4;
      break;
    case 3:
      max2 = 23;
      break;
    case 4:
      max2 = 59;
      break;
  }
  return {
    length,
    min: min2,
    max: max2
  };
};
var getInternalValue = (value) => {
  const newValue = [
    "",
    "",
    "",
    "",
    ""
  ];
  if (value) {
    newValue[0] = String(value.getDate()).padStart(2, "0");
    newValue[1] = String(value.getMonth() + 1).padStart(2, "0");
    newValue[2] = String(value.getFullYear()).padStart(4, "0");
    newValue[3] = String(value.getHours()).padStart(2, "0");
    newValue[4] = String(value.getMinutes()).padStart(2, "0");
  }
  return newValue;
};
var DateInput = (_param) => {
  var { enableTime, shouldDisableDate, disableFuture, disablePast, minDateTime, maxDateTime, value, onChange, calendarPlacement = "bottom-start", style, className, doneButtonText, closeOnChange = true, disablePickers, getRootRef, name, autoFocus, disabled, onClick, onFocus, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", showNeighboringMonth, size: size4, changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", changeDayLabel = "Изменить день", changeHoursLabel = "Изменить час", changeMinutesLabel = "Изменить минуту", clearFieldLabel = "Очистить поле", showCalendarLabel = "Показать календарь", viewDate, onHeaderChange, onNextMonth, onPrevMonth, prevMonthIcon, nextMonthIcon, disableCalendar = false } = _param, props = _object_without_properties(_param, [
    "enableTime",
    "shouldDisableDate",
    "disableFuture",
    "disablePast",
    "minDateTime",
    "maxDateTime",
    "value",
    "onChange",
    "calendarPlacement",
    "style",
    "className",
    "doneButtonText",
    "closeOnChange",
    "disablePickers",
    "getRootRef",
    "name",
    "autoFocus",
    "disabled",
    "onClick",
    "onFocus",
    "prevMonthLabel",
    "nextMonthLabel",
    "showNeighboringMonth",
    "size",
    "changeMonthLabel",
    "changeYearLabel",
    "changeDayLabel",
    "changeHoursLabel",
    "changeMinutesLabel",
    "clearFieldLabel",
    "showCalendarLabel",
    "viewDate",
    "onHeaderChange",
    "onNextMonth",
    "onPrevMonth",
    "prevMonthIcon",
    "nextMonthIcon",
    "disableCalendar"
  ]);
  const daysRef = React246.useRef(null);
  const monthsRef = React246.useRef(null);
  const yearsRef = React246.useRef(null);
  const hoursRef = React246.useRef(null);
  const minutesRef = React246.useRef(null);
  const maxElement = enableTime ? 4 : 2;
  const onInternalValueChange = React246.useCallback((internalValue2) => {
    for (let i = 0; i <= maxElement; i += 1) {
      if (internalValue2[i].length < elementsConfig(i).length) {
        return;
      }
    }
    let formattedValue = `${internalValue2[0]}.${internalValue2[1]}.${internalValue2[2]}`;
    let mask = "DD.MM.YYYY";
    if (enableTime) {
      formattedValue += ` ${internalValue2[3]}:${internalValue2[4]}`;
      mask += " HH:mm";
    }
    if (isMatch(formattedValue, mask)) {
      onChange === null || onChange === void 0 ? void 0 : onChange(parse(formattedValue, mask, value !== null && value !== void 0 ? value : /* @__PURE__ */ new Date()));
    }
  }, [
    enableTime,
    maxElement,
    onChange,
    value
  ]);
  const refs = React246.useMemo(() => [
    daysRef,
    monthsRef,
    yearsRef,
    hoursRef,
    minutesRef
  ], [
    daysRef,
    monthsRef,
    yearsRef,
    hoursRef,
    minutesRef
  ]);
  const { rootRef, calendarRef, open, openCalendar, internalValue, handleKeyDown, setFocusedElement, handleFieldEnter, clear, removeFocusFromField } = useDateInput({
    maxElement,
    refs,
    autoFocus,
    disabled,
    elementsConfig,
    onChange,
    onInternalValueChange,
    getInternalValue,
    value
  });
  const { sizeY = "none" } = useAdaptivity();
  const handleRootRef = useExternRef(rootRef, getRootRef);
  const onCalendarChange = React246.useCallback((value2) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(value2);
    if (closeOnChange && !enableTime) {
      removeFocusFromField();
    }
  }, [
    onChange,
    removeFocusFromField,
    closeOnChange,
    enableTime
  ]);
  return React246.createElement(FormField, _object_spread({
    style,
    className: classNames(sizeY !== "regular" && sizeYClassNames29[sizeY], className),
    getRootRef: handleRootRef,
    after: value ? React246.createElement(IconButton, {
      hoverMode: "opacity",
      label: clearFieldLabel,
      onClick: clear
    }, React246.createElement(Icon16Clear, null)) : React246.createElement(IconButton, {
      hoverMode: "opacity",
      label: showCalendarLabel,
      onClick: openCalendar
    }, React246.createElement(Icon20CalendarOutline, null)),
    disabled,
    onClick: callMultiple(handleFieldEnter, onClick),
    onFocus: callMultiple(handleFieldEnter, onFocus)
  }, props), React246.createElement("input", {
    type: "hidden",
    name,
    value: value ? format(value, enableTime ? "DD.MM.YYYYTHH:mm" : "DD.MM.YYYY") : ""
  }), React246.createElement(Text, {
    className: "vkuiDateInput__input",
    onKeyDown: handleKeyDown
  }, React246.createElement(InputLike, {
    length: 2,
    getRootRef: daysRef,
    index: 0,
    onElementSelect: setFocusedElement,
    value: internalValue[0],
    label: changeDayLabel
  }), React246.createElement(InputLikeDivider, null, "."), React246.createElement(InputLike, {
    length: 2,
    getRootRef: monthsRef,
    index: 1,
    onElementSelect: setFocusedElement,
    value: internalValue[1],
    label: changeMonthLabel
  }), React246.createElement(InputLikeDivider, null, "."), React246.createElement(InputLike, {
    length: 4,
    getRootRef: yearsRef,
    index: 2,
    onElementSelect: setFocusedElement,
    value: internalValue[2],
    label: changeYearLabel
  }), enableTime && React246.createElement(React246.Fragment, null, React246.createElement(InputLikeDivider, {
    className: "vkuiDateInput__input--time-divider"
  }, " "), React246.createElement(InputLike, {
    length: 2,
    getRootRef: hoursRef,
    index: 3,
    onElementSelect: setFocusedElement,
    value: internalValue[3],
    label: changeHoursLabel
  }), React246.createElement(InputLikeDivider, null, ":"), React246.createElement(InputLike, {
    length: 2,
    getRootRef: minutesRef,
    index: 4,
    onElementSelect: setFocusedElement,
    value: internalValue[4],
    label: changeMinutesLabel
  }))), open && !disableCalendar && React246.createElement(Popper, {
    targetRef: rootRef,
    offsetByMainAxis: 8,
    placement: calendarPlacement,
    autoUpdateOnTargetResize: true
  }, React246.createElement(Calendar, {
    value,
    onChange: onCalendarChange,
    enableTime,
    disablePast,
    disableFuture,
    shouldDisableDate,
    onClose: removeFocusFromField,
    getRootRef: calendarRef,
    doneButtonText,
    disablePickers,
    changeHoursLabel,
    changeMinutesLabel,
    prevMonthLabel,
    nextMonthLabel,
    changeMonthLabel,
    changeYearLabel,
    changeDayLabel,
    showNeighboringMonth,
    size: size4,
    viewDate,
    onHeaderChange,
    onNextMonth,
    onPrevMonth,
    prevMonthIcon,
    nextMonthIcon,
    minDateTime,
    maxDateTime
  })));
};

// node_modules/@vkontakte/vkui/dist/components/DateRangeInput/DateRangeInput.js
var React247 = __toESM(require_react());
var sizeYClassNames30 = {
  none: "vkuiDateRangeInput--sizeY-none",
  ["compact"]: "vkuiDateRangeInput--sizeY-compact"
};
var elementsConfig2 = (index2) => {
  let length = 2;
  let min2 = 1;
  let max2 = 0;
  switch (index2) {
    case 0:
    case 3:
      max2 = 31;
      break;
    case 1:
    case 4:
      max2 = 12;
      break;
    case 2:
    case 5:
      max2 = 2100;
      min2 = 1900;
      length = 4;
      break;
  }
  return {
    length,
    min: min2,
    max: max2
  };
};
var getInternalValue2 = (value) => {
  const newValue = [
    "",
    "",
    "",
    "",
    "",
    ""
  ];
  if (value === null || value === void 0 ? void 0 : value[0]) {
    newValue[0] = String(value[0].getDate()).padStart(2, "0");
    newValue[1] = String(value[0].getMonth() + 1).padStart(2, "0");
    newValue[2] = String(value[0].getFullYear()).padStart(4, "0");
  }
  if (value === null || value === void 0 ? void 0 : value[1]) {
    newValue[3] = String(value[1].getDate()).padStart(2, "0");
    newValue[4] = String(value[1].getMonth() + 1).padStart(2, "0");
    newValue[5] = String(value[1].getFullYear()).padStart(4, "0");
  }
  return newValue;
};
var DateRangeInput = (_param) => {
  var { shouldDisableDate, disableFuture, disablePast, value, onChange, calendarPlacement = "bottom-start", style, className, closeOnChange = true, disablePickers, getRootRef, name, autoFocus, disabled, onClick, onFocus, prevMonthLabel = "Предыдущий месяц", nextMonthLabel = "Следующий месяц", changeDayLabel = "Изменить день", changeMonthLabel = "Изменить месяц", changeYearLabel = "Изменить год", changeStartDayLabel = "Изменить день начала", changeStartMonthLabel = "Изменить месяц начала", changeStartYearLabel = "Изменить год начала", changeEndDayLabel = "Изменить день окончания", changeEndMonthLabel = "Изменить месяц окончания", changeEndYearLabel = "Изменить год окончания", clearFieldLabel = "Очистить поле", showCalendarLabel = "Показать календарь", prevMonthIcon, nextMonthIcon, disableCalendar = false } = _param, props = _object_without_properties(_param, [
    "shouldDisableDate",
    "disableFuture",
    "disablePast",
    "value",
    "onChange",
    "calendarPlacement",
    "style",
    "className",
    "closeOnChange",
    "disablePickers",
    "getRootRef",
    "name",
    "autoFocus",
    "disabled",
    "onClick",
    "onFocus",
    "prevMonthLabel",
    "nextMonthLabel",
    "changeDayLabel",
    "changeMonthLabel",
    "changeYearLabel",
    "changeStartDayLabel",
    "changeStartMonthLabel",
    "changeStartYearLabel",
    "changeEndDayLabel",
    "changeEndMonthLabel",
    "changeEndYearLabel",
    "clearFieldLabel",
    "showCalendarLabel",
    "prevMonthIcon",
    "nextMonthIcon",
    "disableCalendar"
  ]);
  const daysStartRef = React247.useRef(null);
  const monthsStartRef = React247.useRef(null);
  const yearsStartRef = React247.useRef(null);
  const daysEndRef = React247.useRef(null);
  const monthsEndRef = React247.useRef(null);
  const yearsEndRef = React247.useRef(null);
  const onInternalValueChange = React247.useCallback((internalValue2) => {
    let isStartValid = true;
    let isEndValid = true;
    for (let i = 0; i <= 2; i += 1) {
      if (internalValue2[i].length < elementsConfig2(i).length) {
        isStartValid = false;
      }
    }
    for (let i = 3; i <= 5; i += 1) {
      if (internalValue2[i].length < elementsConfig2(i).length) {
        isEndValid = false;
      }
    }
    const formattedStartValue = `${internalValue2[0]}.${internalValue2[1]}.${internalValue2[2]}`;
    const formattedEndValue = `${internalValue2[3]}.${internalValue2[4]}.${internalValue2[5]}`;
    const mask = "DD.MM.YYYY";
    if (!isMatch(formattedStartValue, mask)) {
      isStartValid = false;
    }
    if (!isMatch(formattedEndValue, mask)) {
      isEndValid = false;
    }
    if (!isStartValid && !isEndValid) {
      return;
    }
    const valueExists = Array.isArray(value);
    const now2 = /* @__PURE__ */ new Date();
    const start = isStartValid ? parse(formattedStartValue, mask, valueExists && (value === null || value === void 0 ? void 0 : value[0]) || now2) : null;
    const end = isEndValid ? parse(formattedEndValue, mask, valueExists && (value === null || value === void 0 ? void 0 : value[1]) || now2) : null;
    if (start && end && isAfter(end, start)) {
      onChange === null || onChange === void 0 ? void 0 : onChange([
        start,
        end
      ]);
    }
  }, [
    onChange,
    value
  ]);
  const refs = React247.useMemo(() => [
    daysStartRef,
    monthsStartRef,
    yearsStartRef,
    daysEndRef,
    monthsEndRef,
    yearsEndRef
  ], [
    daysStartRef,
    monthsStartRef,
    yearsStartRef,
    daysEndRef,
    monthsEndRef,
    yearsEndRef
  ]);
  const { rootRef, calendarRef, open, openCalendar, closeCalendar, internalValue, handleKeyDown, setFocusedElement, handleFieldEnter, clear, removeFocusFromField } = useDateInput({
    maxElement: 5,
    refs,
    autoFocus,
    disabled,
    elementsConfig: elementsConfig2,
    onChange,
    onInternalValueChange,
    getInternalValue: getInternalValue2,
    value
  });
  const { sizeY = "none" } = useAdaptivity();
  const handleRootRef = useExternRef(rootRef, getRootRef);
  const onCalendarChange = React247.useCallback((newValue) => {
    onChange === null || onChange === void 0 ? void 0 : onChange(newValue);
    if (closeOnChange && (newValue === null || newValue === void 0 ? void 0 : newValue[1]) && newValue[1] !== (value === null || value === void 0 ? void 0 : value[1])) {
      removeFocusFromField();
    }
  }, [
    onChange,
    closeOnChange,
    value,
    removeFocusFromField
  ]);
  return React247.createElement(FormField, _object_spread({
    style,
    className: classNames(sizeY !== "regular" && sizeYClassNames30[sizeY], className),
    getRootRef: handleRootRef,
    after: value ? React247.createElement(IconButton, {
      hoverMode: "opacity",
      onClick: clear
    }, React247.createElement(VisuallyHidden, null, clearFieldLabel), React247.createElement(Icon16Clear, null)) : React247.createElement(IconButton, {
      hoverMode: "opacity",
      onClick: openCalendar
    }, React247.createElement(VisuallyHidden, null, showCalendarLabel), React247.createElement(Icon20CalendarOutline, null)),
    disabled,
    onClick: callMultiple(handleFieldEnter, onClick),
    onFocus: callMultiple(handleFieldEnter, onFocus)
  }, props), React247.createElement("input", {
    type: "hidden",
    name,
    value: value ? `${value[0] ? format(value[0], "DD.MM.YYYY") : ""} - ${value[1] ? format(value[1], "DD.MM.YYYY") : ""}` : ""
  }), React247.createElement(Text, {
    className: "vkuiDateInput__input",
    onKeyDown: handleKeyDown
  }, React247.createElement(InputLike, {
    length: 2,
    getRootRef: daysStartRef,
    index: 0,
    onElementSelect: setFocusedElement,
    value: internalValue[0],
    label: changeStartDayLabel
  }), React247.createElement(InputLikeDivider, null, "."), React247.createElement(InputLike, {
    length: 2,
    getRootRef: monthsStartRef,
    index: 1,
    onElementSelect: setFocusedElement,
    value: internalValue[1],
    label: changeStartMonthLabel
  }), React247.createElement(InputLikeDivider, null, "."), React247.createElement(InputLike, {
    length: 4,
    getRootRef: yearsStartRef,
    index: 2,
    onElementSelect: setFocusedElement,
    value: internalValue[2],
    label: changeStartYearLabel
  }), React247.createElement(InputLikeDivider, null, " — "), React247.createElement(InputLike, {
    length: 2,
    getRootRef: daysEndRef,
    index: 3,
    onElementSelect: setFocusedElement,
    value: internalValue[3],
    label: changeEndDayLabel
  }), React247.createElement(InputLikeDivider, null, "."), React247.createElement(InputLike, {
    length: 2,
    getRootRef: monthsEndRef,
    index: 4,
    onElementSelect: setFocusedElement,
    value: internalValue[4],
    label: changeEndMonthLabel
  }), React247.createElement(InputLikeDivider, null, "."), React247.createElement(InputLike, {
    length: 4,
    getRootRef: yearsEndRef,
    index: 5,
    onElementSelect: setFocusedElement,
    value: internalValue[5],
    label: changeEndYearLabel
  })), open && !disableCalendar && React247.createElement(Popper, {
    targetRef: rootRef,
    offsetByMainAxis: 8,
    placement: calendarPlacement
  }, React247.createElement(CalendarRange, {
    value,
    onChange: onCalendarChange,
    disablePast,
    disableFuture,
    shouldDisableDate,
    onClose: closeCalendar,
    getRootRef: calendarRef,
    disablePickers,
    prevMonthLabel,
    nextMonthLabel,
    changeMonthLabel,
    changeYearLabel,
    changeDayLabel,
    prevMonthIcon,
    nextMonthIcon
  })));
};

// node_modules/@vkontakte/vkui/dist/components/Div/Div.js
var React248 = __toESM(require_react());
var Div = (props) => React248.createElement(RootComponent, _object_spread({
  baseClassName: "vkuiDiv"
}, props));

// node_modules/@vkontakte/vkui/dist/components/PanelSpinner/PanelSpinner.js
var React249 = __toESM(require_react());
var PanelSpinner = React249.memo((_param) => {
  var { height = 96, style } = _param, restProps = _object_without_properties(_param, [
    "height",
    "style"
  ]);
  return React249.createElement(Spinner, _object_spread_props(_object_spread({
    size: "regular"
  }, restProps), {
    style: _object_spread({
      height
    }, style)
  }));
});
PanelSpinner.displayName = "PanelSpinner";

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderClose/PanelHeaderClose.js
var React250 = __toESM(require_react());
var PanelHeaderClose = (_param) => {
  var { children = "Отмена" } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const platform3 = usePlatform();
  return React250.createElement(PanelHeaderButton, restProps, platform3 === "ios" ? children : React250.createElement(React250.Fragment, null, React250.createElement(VisuallyHidden, null, children), React250.createElement(AdaptiveIconRenderer, {
    IconCompact: Icon24CancelOutline,
    IconRegular: Icon28CancelOutline
  })));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderBack/PanelHeaderBack.js
var React251 = __toESM(require_react());
var getBackIcon = (platform3) => {
  switch (platform3) {
    case "ios":
      return React251.createElement(Icon28ChevronBack, null);
    case "vkcom":
      return React251.createElement(AdaptiveIconRenderer, {
        IconCompact: Icon24ChevronLeftOutline,
        IconRegular: Icon28ChevronLeftOutline
      });
    default:
      return React251.createElement(AdaptiveIconRenderer, {
        IconCompact: Icon24ArrowLeftOutline,
        IconRegular: Icon28ArrowLeftOutline
      });
  }
};
var PanelHeaderBack = (_param) => {
  var { label, className, children = "Назад" } = _param, restProps = _object_without_properties(_param, [
    "label",
    "className",
    "children"
  ]);
  const platform3 = usePlatform();
  const { sizeX = "none" } = useAdaptivity();
  const showLabel = platform3 === "vkcom" || platform3 === "ios";
  return React251.createElement(PanelHeaderButton, _object_spread_props(_object_spread({}, restProps), {
    className: classNames(sizeX === "compact" && "vkuiPanelHeaderBack--sizeX-compact", platform3 === "ios" && "vkuiPanelHeaderBack--ios", platform3 === "vkcom" && "vkuiPanelHeaderBack--vkcom", showLabel && !!label && "vkuiPanelHeaderBack--has-label", className),
    label: showLabel && label
  }), children && React251.createElement(VisuallyHidden, null, children), getBackIcon(platform3));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderSubmit/PanelHeaderSubmit.js
var React252 = __toESM(require_react());
var PanelHeaderSubmit = (_param) => {
  var { children = "Готово" } = _param, restProps = _object_without_properties(_param, [
    "children"
  ]);
  const platform3 = usePlatform();
  return React252.createElement(PanelHeaderButton, _object_spread({
    primary: true
  }, restProps), platform3 === "ios" ? children : React252.createElement(React252.Fragment, null, React252.createElement(VisuallyHidden, null, children), React252.createElement(AdaptiveIconRenderer, {
    IconCompact: Icon24DoneOutline,
    IconRegular: Icon28DoneOutline
  })));
};

// node_modules/@vkontakte/vkui/dist/components/PanelHeaderEdit/PanelHeaderEdit.js
var React253 = __toESM(require_react());
var PanelHeaderEdit = (_param) => {
  var { isActive = false, editLabel = "Редактировать", doneLabel = "Готово" } = _param, restProps = _object_without_properties(_param, [
    "isActive",
    "editLabel",
    "doneLabel"
  ]);
  const platform3 = usePlatform();
  const label = isActive ? doneLabel : editLabel;
  return React253.createElement(PanelHeaderButton, restProps, platform3 === "ios" ? label : React253.createElement(React253.Fragment, null, React253.createElement(VisuallyHidden, null, label), React253.createElement(AdaptiveIconRenderer, {
    IconCompact: isActive ? Icon24DoneOutline : Icon24PenOutline,
    IconRegular: isActive ? Icon28DoneOutline : Icon28EditOutline
  })));
};

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProvider.js
var React255 = __toESM(require_react());

// node_modules/@vkontakte/vkui/dist/hooks/useAutoDetectAppearance.js
var React254 = __toESM(require_react());
var useAutoDetectAppearance = (appearanceProp) => {
  const { window: window2 } = useDOM();
  const [appearance, setAppearance] = React254.useState(appearanceProp || Appearance.LIGHT);
  useIsomorphicLayoutEffect(() => {
    if (appearanceProp) {
      setAppearance(appearanceProp);
      return noop;
    }
    const mediaQuery = window2 ? window2.matchMedia("(prefers-color-scheme: dark)") : void 0;
    if (!mediaQuery) {
      return noop;
    }
    const check = (event) => {
      setAppearance(event.matches ? Appearance.DARK : Appearance.LIGHT);
    };
    check(mediaQuery);
    matchMediaListAddListener(mediaQuery, check);
    return () => matchMediaListRemoveListener(mediaQuery, check);
  }, [
    window2,
    appearanceProp
  ]);
  return appearance;
};

// node_modules/@vkontakte/vkui/dist/components/ConfigProvider/ConfigProvider.js
var ConfigProvider = (propsRaw) => {
  const props = excludeKeysWithUndefined(propsRaw);
  const parentConfig = useConfigProvider();
  const { children, hasCustomPanelHeaderAfter, customPanelHeaderAfterMinWidth, isWebView, transitionMotionEnabled, platform: platform3, locale, appearance: appearanceProp, tokensClassNames } = _object_spread({}, parentConfig, props);
  const appearance = useAutoDetectAppearance(appearanceProp);
  const configContext = useObjectMemo({
    hasCustomPanelHeaderAfter,
    customPanelHeaderAfterMinWidth,
    isWebView,
    transitionMotionEnabled,
    platform: platform3,
    locale,
    tokensClassNames,
    appearance
  });
  return React255.createElement(ConfigProviderContext.Provider, {
    value: configContext
  }, React255.createElement(TokensClassProvider, null, children));
};

// node_modules/@vkontakte/vkui/dist/components/LocaleProvider/LocaleProvider.js
var React256 = __toESM(require_react());
function LocaleProvider({ value, children }) {
  return React256.createElement(ConfigProviderOverride, {
    locale: value
  }, children);
}

// node_modules/@vkontakte/vkui/dist/components/PlatformProvider/PlatformProvider.js
var React257 = __toESM(require_react());
function PlatformProvider({ value, children }) {
  return React257.createElement(ConfigProviderOverride, {
    platform: value
  }, React257.createElement(TokensClassProvider, null, children));
}

// node_modules/@vkontakte/vkui/dist/components/Popover/Popover.js
var React258 = __toESM(require_react());
var Popover = (_param) => {
  var {
    // UsePopoverProps
    placement: expectedPlacement = "bottom-start",
    onPlacementChange,
    trigger = "click",
    content,
    hoverDelay = 150,
    closeAfterClick,
    offsetByMainAxis = 8,
    offsetByCrossAxis = 0,
    sameWidth,
    hideWhenReferenceHidden,
    disabled,
    disableInteractive,
    disableCloseOnClickOutside,
    disableCloseOnEscKey,
    // uncontrolled
    defaultShown = false,
    // controlled
    shown: shownProp,
    onShownChange,
    // Для AppRootPortal
    usePortal = true,
    // FocusTrapProps
    autoFocus = true,
    restoreFocus = true,
    className,
    children,
    noStyling = false,
    zIndex = "var(--vkui--z_index_popout)",
    // a11y
    role
  } = _param, restPopoverProps = _object_without_properties(_param, [
    "placement",
    "onPlacementChange",
    "trigger",
    "content",
    "hoverDelay",
    "closeAfterClick",
    "offsetByMainAxis",
    "offsetByCrossAxis",
    "sameWidth",
    "hideWhenReferenceHidden",
    "disabled",
    "disableInteractive",
    "disableCloseOnClickOutside",
    "disableCloseOnEscKey",
    "defaultShown",
    "shown",
    "onShownChange",
    "usePortal",
    "autoFocus",
    "restoreFocus",
    "className",
    "children",
    "noStyling",
    "zIndex",
    "role"
  ]);
  const { middlewares, strictPlacement } = useFloatingMiddlewaresBootstrap({
    placement: expectedPlacement,
    offsetByMainAxis,
    offsetByCrossAxis,
    sameWidth,
    hideWhenReferenceHidden
  });
  const { placement, shown, willBeHide, refs, referenceProps, floatingProps, onClose, onRestoreFocus, onEscapeKeyDown } = useFloatingWithInteractions({
    middlewares,
    placement: strictPlacement,
    trigger,
    hoverDelay,
    closeAfterClick,
    disabled,
    disableInteractive,
    disableCloseOnClickOutside,
    disableCloseOnEscKey,
    defaultShown,
    shown: shownProp,
    onShownChange
  });
  usePlacementChangeCallback(placement, onPlacementChange);
  const [, child] = usePatchChildren(children, injectAriaExpandedPropByRole(referenceProps, shown, role), refs.setReference);
  let popover = null;
  if (shown) {
    floatingProps.style.zIndex = String(zIndex);
    popover = React258.createElement(AppRootPortal, {
      usePortal
    }, React258.createElement("div", _object_spread({
      ref: refs.setFloating,
      className: "vkuiPopover"
    }, floatingProps), React258.createElement(FocusTrap, _object_spread_props(_object_spread({}, restPopoverProps), {
      role,
      className: classNames("vkuiPopover__in", noStyling ? void 0 : "vkuiPopover__in--withStyling", willBeHide ? animationFadeClassNames.out : animationFadeClassNames.in, transformOriginClassNames[placement], className),
      autoFocus: disableInteractive ? false : autoFocus,
      restoreFocus: restoreFocus ? onRestoreFocus : false,
      onClose: onEscapeKeyDown
    }), typeof content === "function" ? content({
      onClose
    }) : content)));
  }
  return React258.createElement(React258.Fragment, null, child, popover);
};

// node_modules/@vkontakte/vkui/dist/components/NavIdContext/useNavId.js
var React259 = __toESM(require_react());
var useNavId = () => ({
  view: React259.useContext(NavViewIdContext),
  panel: React259.useContext(NavPanelIdContext)
});

// node_modules/@vkontakte/vkui/dist/components/ModalRoot/useModalRootContext.js
var React260 = __toESM(require_react());
var useModalRootContext = () => React260.useContext(ModalRootContext);

// node_modules/@vkontakte/vkui/dist/lib/removeObjectKeys.js
function removeObjectKeys(obj, keys = []) {
  let newObj = _object_spread({}, obj);
  keys.forEach((key) => delete newObj[key]);
  return newObj;
}

// node_modules/@vkontakte/vkui/dist/lib/SSR.js
var React261 = __toESM(require_react());
var SSRWrapper = ({ userAgent, browserInfo, children }) => {
  if (!browserInfo && userAgent) {
    browserInfo = computeBrowserInfo(userAgent);
  }
  const dom = useObjectMemo(getDOM());
  return React261.createElement(ConfigProviderOverride, {
    platform: platform(browserInfo)
  }, React261.createElement(DOMContext.Provider, {
    value: dom
  }, children));
};

// node_modules/@vkontakte/vkui/dist/helpers/avatar.js
function calcInitialsAvatarColor(objectId) {
  return objectId % 6 + 1;
}

// node_modules/@vkontakte/vkui/dist/components/View/ViewInfinite.js
var React262 = __toESM(require_react());
var warn24 = warnOnce("ViewInfinite");
var scrollsCache2 = {};
var _React_Component;
var ViewInfiniteComponent = class extends (_React_Component = React262.Component) {
  get document() {
    return this.props.document;
  }
  get window() {
    return this.props.window;
  }
  get panels() {
    return React262.Children.toArray(this.props.children);
  }
  componentWillUnmount() {
    const id = getNavId(this.props);
    if (id) {
      scrollsCache2[id] = this.scrolls;
    }
    if (this.animationFinishTimeout) {
      clearTimeout(this.animationFinishTimeout);
    }
  }
  componentDidUpdate(prevProps, prevState) {
    if (prevProps.activePanel !== this.props.activePanel && !prevState.swipingBack && !prevState.browserSwipe) {
      var _this_props_scroll;
      let isBack = false;
      if (this.props.isBackCheck) {
        isBack = this.props.isBackCheck({
          from: prevProps.activePanel,
          to: this.props.activePanel
        });
      } else {
        const firstLayerId = this.panels.map((panel) => getNavId(panel.props, warn24)).find((id) => id === prevProps.activePanel || id === this.props.activePanel);
        isBack = firstLayerId === this.props.activePanel;
      }
      this.blurActiveElement();
      const prevScrolls = this.scrolls[prevProps.activePanel] || [];
      const scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [prevProps.activePanel]: [
          ...prevScrolls,
          (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y
        ]
      });
      this.scrolls = scrolls;
      if (this.shouldDisableTransitionMotion()) {
        this.flushTransition(prevProps.activePanel, isBack);
      } else {
        this.setState({
          visiblePanels: [
            prevProps.activePanel,
            this.props.activePanel
          ],
          prevPanel: prevProps.activePanel,
          nextPanel: this.props.activePanel,
          activePanel: null,
          animated: true,
          isBack
        });
        if (!animationEvent2.supported) {
          if (this.animationFinishTimeout) {
            clearTimeout(this.animationFinishTimeout);
          }
          this.animationFinishTimeout = setTimeout(this.transitionEndHandler, this.props.platform === "android" || this.props.platform === "vkcom" ? 300 : 600);
        }
      }
    }
    if (prevProps.activePanel !== this.props.activePanel && prevState.swipingBack) {
      const nextPanel = this.state.swipeBackNextPanel;
      const prevPanel = this.state.swipeBackPrevPanel;
      let scrollPosition = void 0;
      this.scrolls = _object_spread({}, this.scrolls);
      if (prevPanel !== null) {
        const prevPanelScrolls = [
          ...this.scrolls[prevPanel] || []
        ].slice(0, -1);
        this.scrolls[prevPanel] = prevPanelScrolls;
      }
      if (nextPanel !== null) {
        const newPanelScrolls = [
          ...this.scrolls[nextPanel] || []
        ];
        scrollPosition = newPanelScrolls.pop();
        this.scrolls[nextPanel] = newPanelScrolls;
      }
      this.setState({
        swipeBackPrevPanel: null,
        swipeBackNextPanel: null,
        swipingBack: false,
        swipeBackResult: null,
        swipeBackStartX: 0,
        swipeBackShift: 0,
        activePanel: nextPanel,
        visiblePanels: [
          nextPanel
        ]
      }, () => {
        var _this_props_scroll2;
        (_this_props_scroll2 = this.props.scroll) === null || _this_props_scroll2 === void 0 ? void 0 : _this_props_scroll2.scrollTo(0, scrollPosition);
        prevProps.onTransition && prevProps.onTransition({
          isBack: true,
          from: prevPanel,
          to: nextPanel
        });
      });
    }
    if (!prevState.swipeBackResult && this.state.swipeBackResult) {
      this.waitTransitionFinish(this.pickPanel(this.state.swipeBackNextPanel), this.swipingBackTransitionEndHandler);
    }
    if (prevState.swipeBackResult === "fail" && !this.state.swipeBackResult && this.state.activePanel !== null) {
      var _this_props_scroll1;
      const newPanelScrolls = [
        ...this.scrolls[this.state.activePanel] || []
      ];
      const scrollPosition = newPanelScrolls.pop();
      this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [this.state.activePanel]: newPanelScrolls
      });
      (_this_props_scroll1 = this.props.scroll) === null || _this_props_scroll1 === void 0 ? void 0 : _this_props_scroll1.scrollTo(0, scrollPosition);
    }
    if (prevProps.activePanel !== this.props.activePanel && this.state.browserSwipe) {
      this.setState({
        browserSwipe: false,
        nextPanel: null,
        prevPanel: null,
        animated: false,
        visiblePanels: [
          this.props.activePanel
        ],
        activePanel: this.props.activePanel
      });
    }
  }
  shouldDisableTransitionMotion() {
    var _this_props_configProvider, _this_props_splitCol;
    return ((_this_props_configProvider = this.props.configProvider) === null || _this_props_configProvider === void 0 ? void 0 : _this_props_configProvider.transitionMotionEnabled) === false || !((_this_props_splitCol = this.props.splitCol) === null || _this_props_splitCol === void 0 ? void 0 : _this_props_splitCol.animate) || this.props.platform === "vkcom";
  }
  waitTransitionFinish(elem, eventHandler) {
    if (transitionEvent2.supported && transitionEvent2.name && elem) {
      elem.removeEventListener(transitionEvent2.name, eventHandler);
      elem.addEventListener(transitionEvent2.name, eventHandler);
    } else {
      if (this.transitionFinishTimeout) {
        clearTimeout(this.transitionFinishTimeout);
      }
      this.transitionFinishTimeout = setTimeout(eventHandler, this.props.platform === "android" || this.props.platform === "vkcom" ? 300 : 600);
    }
  }
  blurActiveElement() {
    var _this_document;
    if (typeof this.window !== "undefined" && ((_this_document = this.document) === null || _this_document === void 0 ? void 0 : _this_document.activeElement)) {
      this.document.activeElement.blur();
    }
  }
  pickPanel(id) {
    if (id === null) {
      return void 0;
    }
    return this.panelNodes[id];
  }
  flushTransition(prevPanel, isBack) {
    const activePanel = this.props.activePanel;
    const prevPanelScrolls = [
      ...this.scrolls[prevPanel] || []
    ].slice(0, -1);
    const newPanelScrolls = [
      ...this.scrolls[activePanel] || []
    ];
    const scrollPosition = isBack ? newPanelScrolls.pop() : 0;
    if (isBack) {
      this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
        [prevPanel]: prevPanelScrolls,
        [activePanel]: newPanelScrolls
      });
    }
    this.setState({
      prevPanel: null,
      nextPanel: null,
      visiblePanels: [
        activePanel
      ],
      activePanel,
      animated: false,
      isBack
    }, () => {
      var _this_props_scroll;
      (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.scrollTo(0, isBack ? scrollPosition : 0);
      this.props.onTransition && this.props.onTransition({
        isBack,
        from: prevPanel,
        to: activePanel
      });
    });
  }
  onSwipeBackSuccess() {
    this.props.onSwipeBack && this.props.onSwipeBack();
  }
  onSwipeBackCancel() {
    this.props.onSwipeBackCancel && this.props.onSwipeBackCancel();
    this.setState({
      swipeBackPrevPanel: null,
      swipeBackNextPanel: null,
      swipingBack: false,
      swipeBackResult: null,
      swipeBackStartX: 0,
      swipeBackShift: 0
    });
  }
  calcPanelSwipeStyles(panelId) {
    if (!canUseDOM || !this.window) {
      return {};
    }
    const isPrev = panelId === this.state.swipeBackPrevPanel;
    const isNext = panelId === this.state.swipeBackNextPanel;
    if (!isPrev && !isNext || this.state.swipeBackResult) {
      return {};
    }
    let prevPanelTranslate = `${this.state.swipeBackShift}px`;
    let nextPanelTranslate = `${-50 + this.state.swipeBackShift * 100 / this.window.innerWidth / 2}%`;
    let prevPanelShadow = 0.3 * (this.window.innerWidth - this.state.swipeBackShift) / this.window.innerWidth;
    if (this.state.swipeBackResult) {
      return isPrev ? {
        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`
      } : {};
    }
    if (isNext) {
      return {
        transform: `translate3d(${nextPanelTranslate}, 0, 0)`,
        WebkitTransform: `translate3d(${nextPanelTranslate}, 0, 0)`
      };
    }
    if (isPrev) {
      return {
        transform: `translate3d(${prevPanelTranslate}, 0, 0)`,
        WebkitTransform: `translate3d(${prevPanelTranslate}, 0, 0)`,
        boxShadow: `-2px 0 12px rgba(0, 0, 0, ${prevPanelShadow})`
      };
    }
    return {};
  }
  render() {
    const _this_props = this.props, { platform: platform3, activePanel: _1, splitCol, configProvider, history, id, nav, onTransition, onSwipeBack, onSwipeBackStart, onSwipeBackCancel, window: window2, document: document2, scroll, isBackCheck, className } = _this_props, restProps = _object_without_properties(_this_props, [
      "platform",
      "activePanel",
      "splitCol",
      "configProvider",
      "history",
      "id",
      "nav",
      "onTransition",
      "onSwipeBack",
      "onSwipeBackStart",
      "onSwipeBackCancel",
      "window",
      "document",
      "scroll",
      "isBackCheck",
      "className"
    ]);
    const { prevPanel, nextPanel, activePanel, isBack, animated, swipeBackPrevPanel, swipeBackNextPanel, swipeBackResult, swipingBack } = this.state;
    const panels = this.panels.filter((panel) => {
      const panelId = getNavId(panel.props, warn24);
      return panelId !== void 0 && this.state.visiblePanels.includes(panelId) || panelId === swipeBackPrevPanel || panelId === swipeBackNextPanel;
    }).sort((panel) => {
      const panelId = getNavId(panel.props, warn24);
      const isPrevPanel = panelId === prevPanel || panelId === swipeBackPrevPanel;
      const isNextPanel = panelId === nextPanel || panelId === swipeBackNextPanel;
      if (isNextPanel) {
        return swipingBack || this.state.isBack ? -1 : 1;
      }
      if (isPrevPanel) {
        return swipingBack || this.state.isBack ? 1 : -1;
      }
      return 0;
    });
    const disableAnimation = this.shouldDisableTransitionMotion();
    const iOSSwipeBackSimulationEnabled = !disableAnimation && platform3 === "ios" && (configProvider === null || configProvider === void 0 ? void 0 : configProvider.isWebView) && Boolean(onSwipeBack);
    return React262.createElement(NavViewIdContext.Provider, {
      value: id || nav
    }, React262.createElement(Touch, _object_spread_props(_object_spread({
      Component: "section"
    }, restProps), {
      className: classNames("vkuiView", platform3 === "ios" && classNames("vkuiView--ios", "vkuiInternalView--ios"), !disableAnimation && this.state.animated && "vkuiView--animated", !disableAnimation && this.state.swipingBack && "vkuiView--swiping-back", disableAnimation && "vkuiView--no-motion", className),
      onMoveX: iOSSwipeBackSimulationEnabled ? this.handleTouchMoveXForIOSSwipeBackSimulation : platform3 === "ios" ? this.handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext : void 0,
      onEnd: iOSSwipeBackSimulationEnabled ? this.handleTouchEndForIOSSwipeBackSimulation : void 0
    }), React262.createElement("div", {
      className: "vkuiView__panels"
    }, panels.map((panel) => {
      const panelId = getNavId(panel.props, warn24);
      const isPrev = panelId === prevPanel || panelId === swipeBackPrevPanel;
      const compensateScroll = isPrev || panelId === swipeBackNextPanel || panelId === nextPanel && isBack;
      const isTransitionTarget = animated && panelId === (isBack ? prevPanel : nextPanel);
      const scrollList = panelId && this.scrolls[panelId] || [];
      const scroll2 = scrollList[scrollList.length - 1] || 0;
      return React262.createElement("div", {
        className: classNames("vkuiView__panel", panelId === activePanel && "vkuiView__panel--active", panelId === prevPanel && "vkuiView__panel--prev", panelId === nextPanel && "vkuiView__panel--next", panelId === swipeBackPrevPanel && "vkuiView__panel--swipe-back-prev", panelId === swipeBackNextPanel && "vkuiView__panel--swipe-back-next", swipeBackResult === "success" && "vkuiView__panel--swipe-back-success", swipeBackResult === "fail" && "vkuiView__panel--swipe-back-failed"),
        onAnimationEnd: isTransitionTarget ? this.transitionEndHandler : void 0,
        ref: (el) => panelId !== void 0 && (this.panelNodes[panelId] = el),
        style: this.calcPanelSwipeStyles(panelId),
        key: panelId
      }, React262.createElement("div", {
        className: "vkuiView__panel-in",
        style: {
          marginTop: compensateScroll ? -scroll2 : void 0
        }
      }, React262.createElement(NavTransitionDirectionProvider, {
        isBack: swipingBack || isBack
      }, React262.createElement(NavTransitionProvider, {
        entering: panelId === nextPanel || panelId === swipeBackNextPanel
      }, panel))));
    }))));
  }
  constructor(props) {
    super(props);
    _define_property(this, "swipeBackPrevented", false);
    _define_property(this, "scrolls", scrollsCache2[getNavId(this.props, warn24)] || {});
    _define_property(this, "transitionFinishTimeout", void 0);
    _define_property(this, "animationFinishTimeout", void 0);
    _define_property(this, "panelNodes", {});
    _define_property(this, "transitionEndHandler", (e) => {
      if ((!e || [
        "vkuianimation-ios-next-forward",
        "vkuianimation-ios-prev-back",
        "vkuianimation-view-next-forward",
        "vkuianimation-view-prev-back"
      ].includes(e.animationName)) && this.state.prevPanel !== null) {
        this.flushTransition(this.state.prevPanel, Boolean(this.state.isBack));
      }
    });
    _define_property(this, "swipingBackTransitionEndHandler", (e) => {
      if (!e || e.propertyName.includes("transform") && e.target === this.pickPanel(this.state.swipeBackNextPanel)) {
        switch (this.state.swipeBackResult) {
          case "fail":
            this.onSwipeBackCancel();
            break;
          case "success":
            this.onSwipeBackSuccess();
        }
      }
    });
    _define_property(this, "handleTouchMoveXForNativeIOSSwipeBackOrSwipeNext", (event) => {
      if (this.state.browserSwipe) {
        return;
      }
      const { swipeBackTriggered, viewportStartEdgeTouched, viewportEndEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, this.window.innerWidth);
      if ((viewportStartEdgeTouched || viewportEndEdgeTouched) && swipeBackTriggered) {
        this.setState({
          browserSwipe: true
        });
      }
    });
    _define_property(this, "handleTouchMoveXForIOSSwipeBackSimulation", (event) => {
      if (this.swipeBackPrevented || swipeBackExcluded(event)) {
        return;
      }
      const { swipedToOpposite, swipeBackTriggered, viewportStartEdgeTouched } = getSwipeBackPredicates(event.startX, event.shiftX, this.window.innerWidth);
      if (this.state.animated && swipeBackTriggered) {
        return;
      }
      if (!this.state.swipingBack && this.props.history && this.props.history.length > 1) {
        if (swipedToOpposite) {
          this.swipeBackPrevented = true;
          return;
        }
        if (!swipeBackTriggered) {
          return;
        }
        if (!viewportStartEdgeTouched && hasHorizontalScrollableElementWithScrolledToLeft(event.originalEvent.target)) {
          this.swipeBackPrevented = true;
          return;
        }
        if (this.props.onSwipeBackStart) {
          const payload = this.props.onSwipeBackStart(this.state.activePanel);
          if (payload === "prevent") {
            this.swipeBackPrevented = true;
            return;
          }
        }
        if (this.state.activePanel !== null) {
          var _this_props_scroll;
          this.blurActiveElement();
          const prevScrolls = this.scrolls[this.state.activePanel] || [];
          this.scrolls = _object_spread_props(_object_spread({}, this.scrolls), {
            [this.state.activePanel]: [
              ...prevScrolls,
              (_this_props_scroll = this.props.scroll) === null || _this_props_scroll === void 0 ? void 0 : _this_props_scroll.getScroll().y
            ]
          });
        }
        this.setState({
          swipingBack: true,
          swipeBackStartX: event.startX,
          swipeBackPrevPanel: this.state.activePanel,
          swipeBackNextPanel: this.props.history.slice(-2)[0]
        });
      }
      if (this.state.swipingBack) {
        if (event.shiftX < 0) {
          this.setState({
            swipeBackShift: 0
          });
        } else if (event.shiftX > this.window.innerWidth - this.state.swipeBackStartX) {
          this.setState({
            swipeBackShift: this.window.innerWidth
          });
        } else {
          this.setState({
            swipeBackShift: event.shiftX
          });
        }
      }
    });
    _define_property(this, "handleTouchEndForIOSSwipeBackSimulation", (event) => {
      this.swipeBackPrevented = false;
      if (this.state.swipingBack && this.window) {
        const speed = this.state.swipeBackShift / event.duration * 1e3;
        if (this.state.swipeBackShift === 0) {
          this.onSwipeBackCancel();
        } else if (this.state.swipeBackShift >= this.window.innerWidth) {
          this.onSwipeBackSuccess();
        } else if (speed > 250 || this.state.swipeBackShift >= this.window.innerWidth / 2) {
          this.setState({
            swipeBackResult: "success"
          });
        } else {
          this.setState({
            swipeBackResult: "fail"
          });
        }
      }
    });
    this.state = {
      animated: false,
      visiblePanels: [
        props.activePanel
      ],
      activePanel: props.activePanel,
      isBack: void 0,
      prevPanel: null,
      nextPanel: null,
      swipingBack: void 0,
      swipeBackStartX: 0,
      swipeBackShift: 0,
      swipeBackNextPanel: null,
      swipeBackPrevPanel: null,
      swipeBackResult: null,
      browserSwipe: false
    };
  }
};
_define_property(ViewInfiniteComponent, "defaultProps", {
  history: []
});
var ViewInfinite = withContext(withContext(withContext(withPlatform(withDOM(ViewInfiniteComponent)), SplitColContext, "splitCol"), ConfigProviderContext, "configProvider"), ScrollContext, "scroll");

export {
  classNames,
  useAdaptivity,
  Platform,
  platform,
  ConfigProviderContext,
  useConfigProvider,
  Appearance,
  useScrollLock,
  AppRoot,
  Title,
  Headline,
  Text,
  Paragraph,
  Subhead,
  Footnote,
  Caption,
  ViewWidth,
  ViewHeight,
  SizeType,
  getViewWidthByViewportWidth,
  getViewHeightByViewportHeight,
  usePlatform,
  Tappable,
  OnboardingTooltipContainer,
  FixedLayout,
  ImageBaseContext,
  getFallbackIconSizeByImageBaseSize,
  getBadgeIconSizeByImageBaseSize,
  getOverlayIconSizeByImageBaseSize,
  useAppearance,
  ImageBase,
  VisuallyHidden,
  Spinner,
  Button,
  IconButton,
  useNavTransition,
  useNavDirection,
  Root,
  Touch,
  View,
  Panel,
  PanelHeaderButton,
  useAdaptivityConditionalRender,
  ModalRootContext,
  Separator,
  Spacing,
  PanelHeader,
  PanelHeaderContent,
  PanelHeaderContext,
  AppearanceProvider,
  SplitLayout,
  SplitCol,
  Epic,
  Tabbar,
  TabbarItem,
  ScrollArrow,
  HorizontalScroll,
  AspectRatio,
  PopoutWrapper,
  useAdaptivityWithJSMediaQueries,
  ModalDismissButton,
  Alert,
  AdaptiveIconRenderer,
  ActionSheetItem,
  ActionSheetDefaultIosCloseItem,
  Popper,
  ActionSheet,
  ScreenSpinner,
  Snackbar,
  Tooltip,
  withPlatform,
  ModalRoot,
  withModalRootContext,
  ModalPage,
  ModalPageHeader,
  ModalCardBase,
  ModalCard,
  Badge,
  ButtonGroup,
  Card,
  CardGrid,
  CardScroll,
  ContentCard,
  Header,
  Group,
  Gradient,
  List,
  SimpleCell,
  Cell,
  RichCell,
  CellButton,
  Avatar,
  HorizontalCell,
  HorizontalCellShowMore,
  Footer,
  InfoRow,
  animate2 as animate,
  Gallery,
  GridAvatar,
  Image,
  Progress,
  Search,
  Tabs,
  TabsItem,
  PullToRefresh,
  Link,
  OnboardingTooltip,
  Counter,
  UsersStack,
  Placeholder,
  Banner,
  MiniInfoCell,
  WriteBar,
  WriteBarIcon,
  SubnavigationBar,
  SubnavigationButton,
  usePagination,
  Pagination,
  Accordion,
  FormItem,
  FormField,
  FormLayoutGroup,
  FormStatus,
  Switch,
  File,
  Input,
  Chip,
  ChipsInput,
  defaultFilterFn,
  CustomScrollView,
  CustomSelectOption,
  ChipsSelect,
  Slider,
  Textarea,
  Radio2 as Radio,
  RadioGroup,
  Checkbox,
  CustomSelect,
  NativeSelect,
  Select,
  SelectMimicry,
  DatePicker,
  SegmentedControl,
  useTodayDate,
  AdaptivityProvider,
  Calendar,
  CalendarRange,
  DateInput,
  DateRangeInput,
  Div,
  PanelSpinner,
  PanelHeaderClose,
  PanelHeaderBack,
  PanelHeaderSubmit,
  PanelHeaderEdit,
  ConfigProvider,
  LocaleProvider,
  PlatformProvider,
  Popover,
  useNavId,
  useModalRootContext,
  removeObjectKeys,
  SSRWrapper,
  calcInitialsAvatarColor,
  ViewInfinite
};
//# sourceMappingURL=chunk-3XA44QXF.js.map
